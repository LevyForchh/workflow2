#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'
require File.join File.dirname(__FILE__), 'audience_types'
require File.join File.dirname(__FILE__), 'parc_service_types'
require File.join File.dirname(__FILE__), 'importer_service_types'
require File.join File.dirname(__FILE__), 'new_person_data_types'


module Liveramp
  module Types
    module OnboardingService
      module OnboardingCoordinatorRequestStatus
        PENDING = 1
        RUNNING = 2
        FAILED = 3
        CONFIGURATION_ERROR = 4
        COMPLETED = 5
        IRRECOVERABLE_FAILURE = 6
        VALUE_MAP = {1 => "PENDING", 2 => "RUNNING", 3 => "FAILED", 4 => "CONFIGURATION_ERROR", 5 => "COMPLETED", 6 => "IRRECOVERABLE_FAILURE"}
        VALID_VALUES = Set.new([PENDING, RUNNING, FAILED, CONFIGURATION_ERROR, COMPLETED, IRRECOVERABLE_FAILURE]).freeze
      end

      module OnboardingParcMigrationStatus
        MIGRATED_FOR_LEGACY_IMPORTER_UI = 1
        MIGRATED_FOR_INGESTION_UI = 2
        VALUE_MAP = {1 => "MIGRATED_FOR_LEGACY_IMPORTER_UI", 2 => "MIGRATED_FOR_INGESTION_UI"}
        VALID_VALUES = Set.new([MIGRATED_FOR_LEGACY_IMPORTER_UI, MIGRATED_FOR_INGESTION_UI]).freeze
      end

      module OnboardingDataType
        ANONYMOUS_RECORDS = 1
        ANONYMOUSLY_IDENTIFIED_FIELDS = 2
        VALUE_MAP = {1 => "ANONYMOUS_RECORDS", 2 => "ANONYMOUSLY_IDENTIFIED_FIELDS"}
        VALID_VALUES = Set.new([ANONYMOUS_RECORDS, ANONYMOUSLY_IDENTIFIED_FIELDS]).freeze
      end

      class OnboardingImportParams; end

      class AudienceInfo; end

      class StringEnum; end

      class NumericEnum; end

      class RawNumeric; end

      class RawString; end

      class FieldTypeInfo < ::Thrift::Union; end

      class SingleKeyFieldExtractionInfo; end

      class MultiKeyFieldExtractionInfo; end

      class FilewideFieldExtractionInfo; end

      class ImportwideFieldExtractionInfo; end

      class FieldExtractionInfo < ::Thrift::Union; end

      class FieldConfig; end

      class UseAllIdentifiers; end

      class IdentifierConfig < ::Thrift::Union; end

      class UseLegacyAudienceKey; end

      class UseBestPel; end

      class AudienceKeyConfig < ::Thrift::Union; end

      class LegacyOrdering; end

      class ImportOrderingId < ::Thrift::Union; end

      class OnboardingConfig; end

      class ParcToArcOutput; end

      class FeedAudienceConfiguration; end

      class OnboardingFeedConfiguration; end

      class OnboardingRequestInfo; end

      class NonExistentLinkException < ::Thrift::Exception; end

      class NonExistentImportException < ::Thrift::Exception; end

      class OnboardingImportParams
        include ::Thrift::Struct, ::Thrift::Struct_Union
        AUDIENCE_ID = 1
        IMPORT_NAME = 2
        CREATED_BY_USER_ID = 3
        PARC_IDS = 4
        IMPORTTYPE = 5
        FEED_ID = 7
        PARC_SUMMARIES = 8
        OUTPUT_TYPE = 9

        FIELDS = {
          AUDIENCE_ID => {:type => ::Thrift::Types::I64, :name => 'audience_id'},
          IMPORT_NAME => {:type => ::Thrift::Types::STRING, :name => 'import_name'},
          CREATED_BY_USER_ID => {:type => ::Thrift::Types::I64, :name => 'created_by_user_id'},
          PARC_IDS => {:type => ::Thrift::Types::SET, :name => 'parc_ids', :element => {:type => ::Thrift::Types::I64}},
          IMPORTTYPE => {:type => ::Thrift::Types::I32, :name => 'importType', :enum_class => ::Rapleaf::ImporterService::ImportType},
          FEED_ID => {:type => ::Thrift::Types::I64, :name => 'feed_id'},
          PARC_SUMMARIES => {:type => ::Thrift::Types::SET, :name => 'parc_summaries', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::ParcService::ParcSummary}, :optional => true},
          OUTPUT_TYPE => {:type => ::Thrift::Types::I32, :name => 'output_type', :optional => true, :enum_class => ::Liveramp::Types::OnboardingService::OnboardingDataType}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field audience_id is unset!') unless @audience_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field import_name is unset!') unless @import_name
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field created_by_user_id is unset!') unless @created_by_user_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field parc_ids is unset!') unless @parc_ids
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field importType is unset!') unless @importType
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field feed_id is unset!') unless @feed_id
          unless @importType.nil? || ::Rapleaf::ImporterService::ImportType::VALID_VALUES.include?(@importType)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field importType!')
          end
          unless @output_type.nil? || ::Liveramp::Types::OnboardingService::OnboardingDataType::VALID_VALUES.include?(@output_type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field output_type!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class AudienceInfo
        include ::Thrift::Struct, ::Thrift::Struct_Union
        AUDIENCE_ID = 1
        DISPLAY_NAME = 2
        NUM_AUDIENCE_MEMBERS = 3
        FAST_LANE = 4

        FIELDS = {
          AUDIENCE_ID => {:type => ::Thrift::Types::I64, :name => 'audience_id'},
          DISPLAY_NAME => {:type => ::Thrift::Types::STRING, :name => 'display_name', :optional => true},
          NUM_AUDIENCE_MEMBERS => {:type => ::Thrift::Types::I64, :name => 'num_audience_members', :optional => true},
          FAST_LANE => {:type => ::Thrift::Types::BOOL, :name => 'fast_lane', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field audience_id is unset!') unless @audience_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      class StringEnum
        include ::Thrift::Struct, ::Thrift::Struct_Union
        FIELD_VALUE_TO_VALUE_ID = 1

        FIELDS = {
          FIELD_VALUE_TO_VALUE_ID => {:type => ::Thrift::Types::MAP, :name => 'field_value_to_value_id', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::I64}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field field_value_to_value_id is unset!') unless @field_value_to_value_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      class NumericEnum
        include ::Thrift::Struct, ::Thrift::Struct_Union
        FIELD_VALUE_TO_VALUE_ID = 1

        FIELDS = {
          FIELD_VALUE_TO_VALUE_ID => {:type => ::Thrift::Types::MAP, :name => 'field_value_to_value_id', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::I64}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field field_value_to_value_id is unset!') unless @field_value_to_value_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      class RawNumeric
        include ::Thrift::Struct, ::Thrift::Struct_Union

        FIELDS = {

        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class RawString
        include ::Thrift::Struct, ::Thrift::Struct_Union

        FIELDS = {

        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class FieldTypeInfo < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def raw_numeric(val)
            FieldTypeInfo.new(:raw_numeric, val)
          end

          def raw_string(val)
            FieldTypeInfo.new(:raw_string, val)
          end

          def string_enum(val)
            FieldTypeInfo.new(:string_enum, val)
          end

          def numeric_enum(val)
            FieldTypeInfo.new(:numeric_enum, val)
          end
        end

        RAW_NUMERIC = 1
        RAW_STRING = 2
        STRING_ENUM = 3
        NUMERIC_ENUM = 4

        FIELDS = {
          RAW_NUMERIC => {:type => ::Thrift::Types::STRUCT, :name => 'raw_numeric', :class => ::Liveramp::Types::OnboardingService::RawNumeric, :optional => true},
          RAW_STRING => {:type => ::Thrift::Types::STRUCT, :name => 'raw_string', :class => ::Liveramp::Types::OnboardingService::RawString, :optional => true},
          STRING_ENUM => {:type => ::Thrift::Types::STRUCT, :name => 'string_enum', :class => ::Liveramp::Types::OnboardingService::StringEnum, :optional => true},
          NUMERIC_ENUM => {:type => ::Thrift::Types::STRUCT, :name => 'numeric_enum', :class => ::Liveramp::Types::OnboardingService::NumericEnum, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class SingleKeyFieldExtractionInfo
        include ::Thrift::Struct, ::Thrift::Struct_Union
        KEY = 1
        FIELD_TYPE_INFO = 2

        FIELDS = {
          KEY => {:type => ::Thrift::Types::STRING, :name => 'key'},
          FIELD_TYPE_INFO => {:type => ::Thrift::Types::STRUCT, :name => 'field_type_info', :class => ::Liveramp::Types::OnboardingService::FieldTypeInfo}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field key is unset!') unless @key
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field field_type_info is unset!') unless @field_type_info
        end

        ::Thrift::Struct.generate_accessors self
      end

      class MultiKeyFieldExtractionInfo
        include ::Thrift::Struct, ::Thrift::Struct_Union
        KEYS = 1
        DELIMITER = 2
        FIELD_TYPE_INFO = 3

        FIELDS = {
          KEYS => {:type => ::Thrift::Types::LIST, :name => 'keys', :element => {:type => ::Thrift::Types::STRING}},
          DELIMITER => {:type => ::Thrift::Types::STRING, :name => 'delimiter'},
          FIELD_TYPE_INFO => {:type => ::Thrift::Types::STRUCT, :name => 'field_type_info', :class => ::Liveramp::Types::OnboardingService::FieldTypeInfo}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field keys is unset!') unless @keys
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field delimiter is unset!') unless @delimiter
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field field_type_info is unset!') unless @field_type_info
        end

        ::Thrift::Struct.generate_accessors self
      end

      class FilewideFieldExtractionInfo
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PARC_ID = 1
        STRING_ENUM_VALUE_ID = 2

        FIELDS = {
          PARC_ID => {:type => ::Thrift::Types::I64, :name => 'parc_id'},
          STRING_ENUM_VALUE_ID => {:type => ::Thrift::Types::I32, :name => 'string_enum_value_id'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field parc_id is unset!') unless @parc_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field string_enum_value_id is unset!') unless @string_enum_value_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Used to support the legacy importer UI use case of having many files per import.
# 
      class ImportwideFieldExtractionInfo
        include ::Thrift::Struct, ::Thrift::Struct_Union
        STRING_ENUM_VALUE_ID = 1

        FIELDS = {
          STRING_ENUM_VALUE_ID => {:type => ::Thrift::Types::I32, :name => 'string_enum_value_id'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field string_enum_value_id is unset!') unless @string_enum_value_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      class FieldExtractionInfo < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def single_key_field_extraction_info(val)
            FieldExtractionInfo.new(:single_key_field_extraction_info, val)
          end

          def multi_key_field_extraction_info(val)
            FieldExtractionInfo.new(:multi_key_field_extraction_info, val)
          end

          def filewide_field_extraction_info(val)
            FieldExtractionInfo.new(:filewide_field_extraction_info, val)
          end

          def importwide_field_extraction_info(val)
            FieldExtractionInfo.new(:importwide_field_extraction_info, val)
          end
        end

        SINGLE_KEY_FIELD_EXTRACTION_INFO = 1
        MULTI_KEY_FIELD_EXTRACTION_INFO = 2
        FILEWIDE_FIELD_EXTRACTION_INFO = 3
        IMPORTWIDE_FIELD_EXTRACTION_INFO = 4

        FIELDS = {
          SINGLE_KEY_FIELD_EXTRACTION_INFO => {:type => ::Thrift::Types::STRUCT, :name => 'single_key_field_extraction_info', :class => ::Liveramp::Types::OnboardingService::SingleKeyFieldExtractionInfo, :optional => true},
          MULTI_KEY_FIELD_EXTRACTION_INFO => {:type => ::Thrift::Types::STRUCT, :name => 'multi_key_field_extraction_info', :class => ::Liveramp::Types::OnboardingService::MultiKeyFieldExtractionInfo, :optional => true},
          FILEWIDE_FIELD_EXTRACTION_INFO => {:type => ::Thrift::Types::STRUCT, :name => 'filewide_field_extraction_info', :class => ::Liveramp::Types::OnboardingService::FilewideFieldExtractionInfo, :optional => true},
          IMPORTWIDE_FIELD_EXTRACTION_INFO => {:type => ::Thrift::Types::STRUCT, :name => 'importwide_field_extraction_info', :class => ::Liveramp::Types::OnboardingService::ImportwideFieldExtractionInfo, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      # Specifies how to configure fields in given PARs. We can configure fields by either reading keys and data associated
# with them, or by adding them as filewide or importwide fields.
# 
# A field can be configured via two ways:
#   1) Key-based: Extract the data that is associated with one or more keys in a PAR. If the field is an enum, we map the
#      extracted data to the value ID of the field via mappings found in FieldTypeInfo. Otherwise, if the field is a
#      raw value, we just insert the extracted data token as the field value.
# 
#   2) File/Import-wide: We add the field with a default value to all PARs coming from a given file or import.
# 
      class FieldConfig
        include ::Thrift::Struct, ::Thrift::Struct_Union
        FIELD_EXTRACTION_INFO = 1
        FIELD_ID = 2

        FIELDS = {
          FIELD_EXTRACTION_INFO => {:type => ::Thrift::Types::STRUCT, :name => 'field_extraction_info', :class => ::Liveramp::Types::OnboardingService::FieldExtractionInfo},
          FIELD_ID => {:type => ::Thrift::Types::I64, :name => 'field_id'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field field_extraction_info is unset!') unless @field_extraction_info
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field field_id is unset!') unless @field_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      class UseAllIdentifiers
        include ::Thrift::Struct, ::Thrift::Struct_Union

        FIELDS = {

        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Specifies how to parse identifiers. Potential use cases:
# - Parse all identifiers
# - Parse some identifiers e.g: if a file contains EMAIL and NAP, then we might want to only parse EMAIL.
# - Apply some transformation or grouping of identifiers
# 
      class IdentifierConfig < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def use_all_identifiers(val)
            IdentifierConfig.new(:use_all_identifiers, val)
          end
        end

        USE_ALL_IDENTIFIERS = 1

        FIELDS = {
          USE_ALL_IDENTIFIERS => {:type => ::Thrift::Types::STRUCT, :name => 'use_all_identifiers', :class => ::Liveramp::Types::OnboardingService::UseAllIdentifiers, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class UseLegacyAudienceKey
        include ::Thrift::Struct, ::Thrift::Struct_Union

        FIELDS = {

        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Using "Best" Pel comprises:
#  - using first mPEL in the list, OR if there is not an mPEL present
#  - using first dPEL in the list
# 
      class UseBestPel
        include ::Thrift::Struct, ::Thrift::Struct_Union

        FIELDS = {

        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class AudienceKeyConfig < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def use_legacy_audience_key(val)
            AudienceKeyConfig.new(:use_legacy_audience_key, val)
          end

          def use_best_pel(val)
            AudienceKeyConfig.new(:use_best_pel, val)
          end
        end

        USE_LEGACY_AUDIENCE_KEY = 1
        USE_BEST_PEL = 2

        FIELDS = {
          USE_LEGACY_AUDIENCE_KEY => {:type => ::Thrift::Types::STRUCT, :name => 'use_legacy_audience_key', :class => ::Liveramp::Types::OnboardingService::UseLegacyAudienceKey, :optional => true},
          USE_BEST_PEL => {:type => ::Thrift::Types::STRUCT, :name => 'use_best_pel', :class => ::Liveramp::Types::OnboardingService::UseBestPel, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class LegacyOrdering
        include ::Thrift::Struct, ::Thrift::Struct_Union
        LIR_ID = 1
        IRC_ID = 2

        FIELDS = {
          LIR_ID => {:type => ::Thrift::Types::I64, :name => 'lir_id'},
          IRC_ID => {:type => ::Thrift::Types::I64, :name => 'irc_id'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field lir_id is unset!') unless @lir_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field irc_id is unset!') unless @irc_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Used for the onboarding use case of determining how to order imports. This has an effect on how onboarding processes
# data like import deletion and import refreshes.
# 
      class ImportOrderingId < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def legacy_ordering_ids(val)
            ImportOrderingId.new(:legacy_ordering_ids, val)
          end
        end

        LEGACY_ORDERING_IDS = 1

        FIELDS = {
          LEGACY_ORDERING_IDS => {:type => ::Thrift::Types::STRUCT, :name => 'legacy_ordering_ids', :class => ::Liveramp::Types::OnboardingService::LegacyOrdering, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class OnboardingConfig
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PARC_IDS = 1
        AUDIENCE_ID = 2
        IMPORT_ORDERING_ID = 3
        IMPORT_TYPE = 4
        MERGE_DATA_TYPES = 5
        FIELD_CONFIGS = 6
        IDENTIFIER_CONFIG = 7
        AUDIENCE_KEY_CONFIG = 8

        FIELDS = {
          PARC_IDS => {:type => ::Thrift::Types::SET, :name => 'parc_ids', :element => {:type => ::Thrift::Types::I64}},
          AUDIENCE_ID => {:type => ::Thrift::Types::I64, :name => 'audience_id'},
          IMPORT_ORDERING_ID => {:type => ::Thrift::Types::STRUCT, :name => 'import_ordering_id', :class => ::Liveramp::Types::OnboardingService::ImportOrderingId},
          IMPORT_TYPE => {:type => ::Thrift::Types::I32, :name => 'import_type', :enum_class => ::Rapleaf::ImporterService::ImportType},
          MERGE_DATA_TYPES => {:type => ::Thrift::Types::SET, :name => 'merge_data_types', :element => {:type => ::Thrift::Types::I32, :enum_class => ::Liveramp::Audience::MergeDataType}},
          FIELD_CONFIGS => {:type => ::Thrift::Types::SET, :name => 'field_configs', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::OnboardingService::FieldConfig}},
          IDENTIFIER_CONFIG => {:type => ::Thrift::Types::STRUCT, :name => 'identifier_config', :class => ::Liveramp::Types::OnboardingService::IdentifierConfig},
          AUDIENCE_KEY_CONFIG => {:type => ::Thrift::Types::STRUCT, :name => 'audience_key_config', :class => ::Liveramp::Types::OnboardingService::AudienceKeyConfig}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field parc_ids is unset!') unless @parc_ids
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field audience_id is unset!') unless @audience_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field import_ordering_id is unset!') unless @import_ordering_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field import_type is unset!') unless @import_type
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field merge_data_types is unset!') unless @merge_data_types
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field field_configs is unset!') unless @field_configs
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field identifier_config is unset!') unless @identifier_config
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field audience_key_config is unset!') unless @audience_key_config
          unless @import_type.nil? || ::Rapleaf::ImporterService::ImportType::VALID_VALUES.include?(@import_type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field import_type!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ParcToArcOutput
        include ::Thrift::Struct, ::Thrift::Struct_Union
        OUTPUT_PATH = 1

        FIELDS = {
          OUTPUT_PATH => {:type => ::Thrift::Types::STRING, :name => 'output_path'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class FeedAudienceConfiguration
        include ::Thrift::Struct, ::Thrift::Struct_Union
        IMPORT_TYPE = 1

        FIELDS = {
          IMPORT_TYPE => {:type => ::Thrift::Types::I32, :name => 'import_type', :enum_class => ::Rapleaf::ImporterService::ImportType}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field import_type is unset!') unless @import_type
          unless @import_type.nil? || ::Rapleaf::ImporterService::ImportType::VALID_VALUES.include?(@import_type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field import_type!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class OnboardingFeedConfiguration
        include ::Thrift::Struct, ::Thrift::Struct_Union
        FEED_ID = 1
        AUDIENCE_TO_CONFIGURATION = 2

        FIELDS = {
          FEED_ID => {:type => ::Thrift::Types::I64, :name => 'feed_id'},
          AUDIENCE_TO_CONFIGURATION => {:type => ::Thrift::Types::MAP, :name => 'audience_to_configuration', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::OnboardingService::FeedAudienceConfiguration}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field feed_id is unset!') unless @feed_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field audience_to_configuration is unset!') unless @audience_to_configuration
        end

        ::Thrift::Struct.generate_accessors self
      end

      class OnboardingRequestInfo
        include ::Thrift::Struct, ::Thrift::Struct_Union
        IMPORT_TYPE = 1

        FIELDS = {
          IMPORT_TYPE => {:type => ::Thrift::Types::I32, :name => 'import_type', :enum_class => ::Rapleaf::ImporterService::ImportType}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field import_type is unset!') unless @import_type
          unless @import_type.nil? || ::Rapleaf::ImporterService::ImportType::VALID_VALUES.include?(@import_type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field import_type!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class NonExistentLinkException < ::Thrift::Exception
        include ::Thrift::Struct, ::Thrift::Struct_Union
        FEED_ID = 1
        AUDIENCE_IDS = 2

        FIELDS = {
          FEED_ID => {:type => ::Thrift::Types::I64, :name => 'feed_id'},
          AUDIENCE_IDS => {:type => ::Thrift::Types::SET, :name => 'audience_ids', :element => {:type => ::Thrift::Types::I64}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field feed_id is unset!') unless @feed_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field audience_ids is unset!') unless @audience_ids
        end

        ::Thrift::Struct.generate_accessors self
      end

      class NonExistentImportException < ::Thrift::Exception
        include ::Thrift::Struct, ::Thrift::Struct_Union

        FIELDS = {

        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

    end
  end
end
