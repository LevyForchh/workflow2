#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'
require File.join File.dirname(__FILE__), 'enums_types'
require File.join File.dirname(__FILE__), 'new_person_data_types'
require File.join File.dirname(__FILE__), 'spruce_types'
require File.join File.dirname(__FILE__), 'audience_types'
require File.join File.dirname(__FILE__), 'mobile_types'
require File.join File.dirname(__FILE__), 'online_data_types'
require File.join File.dirname(__FILE__), 'bang_types'
require File.join File.dirname(__FILE__), 'util_types'
require File.join File.dirname(__FILE__), 'pii_integration_types'
require File.join File.dirname(__FILE__), 'user_agent_types'


module Rapleaf
  module Types
    module S2SIntegrations
      module S2SMode
        NONE = 0
        BERING_MEDIA = 5
        INTERNAL_ID = 6
        EXTERNAL_ID = 7
        COLLIDER = 8
        LINKEDIN = 9
        TWITTER = 10
        GOOGLE_ATTRIBUTION = 11
        MOBILE = 12
        MARIN_ATTRIBUTION = 13
        ATTRIBUTION = 14
        UNENCRYPTED_CUSTOM_ID = 17
        ENCRYPTED_CUSTOM_ID = 18
        LIVERAMP_PEL_CUSTOM_ID = 19
        PII_EMAIL = 20
        PII_NAP = 21
        PII_NAP_AND_EMAIL = 22
        VALUE_MAP = {0 => "NONE", 5 => "BERING_MEDIA", 6 => "INTERNAL_ID", 7 => "EXTERNAL_ID", 8 => "COLLIDER", 9 => "LINKEDIN", 10 => "TWITTER", 11 => "GOOGLE_ATTRIBUTION", 12 => "MOBILE", 13 => "MARIN_ATTRIBUTION", 14 => "ATTRIBUTION", 17 => "UNENCRYPTED_CUSTOM_ID", 18 => "ENCRYPTED_CUSTOM_ID", 19 => "LIVERAMP_PEL_CUSTOM_ID", 20 => "PII_EMAIL", 21 => "PII_NAP", 22 => "PII_NAP_AND_EMAIL"}
        VALID_VALUES = Set.new([NONE, BERING_MEDIA, INTERNAL_ID, EXTERNAL_ID, COLLIDER, LINKEDIN, TWITTER, GOOGLE_ATTRIBUTION, MOBILE, MARIN_ATTRIBUTION, ATTRIBUTION, UNENCRYPTED_CUSTOM_ID, ENCRYPTED_CUSTOM_ID, LIVERAMP_PEL_CUSTOM_ID, PII_EMAIL, PII_NAP, PII_NAP_AND_EMAIL]).freeze
      end

      module S2SFieldPackSource
        ESP = 1
        ATTRIBUTION = 2
        RETARGET = 3
        ID_SYNC = 4
        ONLINE_ESP = 5
        VALUE_MAP = {1 => "ESP", 2 => "ATTRIBUTION", 3 => "RETARGET", 4 => "ID_SYNC", 5 => "ONLINE_ESP"}
        VALID_VALUES = Set.new([ESP, ATTRIBUTION, RETARGET, ID_SYNC, ONLINE_ESP]).freeze
      end

      module BatchTemplateDelivererProtocol
        SFTP = 1
        FTP = 2
        FTPS_EXPLICIT = 3
        S3 = 4
        FS_COPY = 5
        APP_NEXUS = 6
        NO_OP = 7
        FTPS_IMPLICIT = 8
        IRON_BOX = 10
        YAHOO = 12
        ACXIOM_FULFILLMENT = 14
        FACEBOOK = 15
        LINKEDIN = 16
        GOOGLE = 17
        KBM = 18
        PINTEREST = 19
        GOOGLE_CUSTOMER_MATCH = 20
        LR_FULFILLMENT = 21
        SNAPCHAT = 22
        BIGQUERY = 23
        GOOGLE_STORE_TRANSACTIONS = 24
        VALUE_MAP = {1 => "SFTP", 2 => "FTP", 3 => "FTPS_EXPLICIT", 4 => "S3", 5 => "FS_COPY", 6 => "APP_NEXUS", 7 => "NO_OP", 8 => "FTPS_IMPLICIT", 10 => "IRON_BOX", 12 => "YAHOO", 14 => "ACXIOM_FULFILLMENT", 15 => "FACEBOOK", 16 => "LINKEDIN", 17 => "GOOGLE", 18 => "KBM", 19 => "PINTEREST", 20 => "GOOGLE_CUSTOMER_MATCH", 21 => "LR_FULFILLMENT", 22 => "SNAPCHAT", 23 => "BIGQUERY", 24 => "GOOGLE_STORE_TRANSACTIONS"}
        VALID_VALUES = Set.new([SFTP, FTP, FTPS_EXPLICIT, S3, FS_COPY, APP_NEXUS, NO_OP, FTPS_IMPLICIT, IRON_BOX, YAHOO, ACXIOM_FULFILLMENT, FACEBOOK, LINKEDIN, GOOGLE, KBM, PINTEREST, GOOGLE_CUSTOMER_MATCH, LR_FULFILLMENT, SNAPCHAT, BIGQUERY, GOOGLE_STORE_TRANSACTIONS]).freeze
      end

      module ApiTestStatus
        SUCCESS = 1
        UNKNOWN_ERROR = 99
        VALUE_MAP = {1 => "SUCCESS", 99 => "UNKNOWN_ERROR"}
        VALID_VALUES = Set.new([SUCCESS, UNKNOWN_ERROR]).freeze
      end

      module LiverampTestGenerationRequestReason
        NEW_INTEGRATION = 1
        REGENERATE_TEST = 2
        NEW_IMPORT = 3
        NO_OP_TEST = 4
        VALUE_MAP = {1 => "NEW_INTEGRATION", 2 => "REGENERATE_TEST", 3 => "NEW_IMPORT", 4 => "NO_OP_TEST"}
        VALID_VALUES = Set.new([NEW_INTEGRATION, REGENERATE_TEST, NEW_IMPORT, NO_OP_TEST]).freeze
      end

      module LiverampTestGenerationRequestStatus
        INITIALIZED = 1
        CREATING_TEST = 2
        TEST_CREATED = 3
        DEPLOYING_CONFIG = 4
        WAITING_FOR_CONFIG_DEPLOY = 5
        COMPLETED = 6
        FAILED = 7
        VALUE_MAP = {1 => "INITIALIZED", 2 => "CREATING_TEST", 3 => "TEST_CREATED", 4 => "DEPLOYING_CONFIG", 5 => "WAITING_FOR_CONFIG_DEPLOY", 6 => "COMPLETED", 7 => "FAILED"}
        VALID_VALUES = Set.new([INITIALIZED, CREATING_TEST, TEST_CREATED, DEPLOYING_CONFIG, WAITING_FOR_CONFIG_DEPLOY, COMPLETED, FAILED]).freeze
      end

      module SsaType
        STREAMING = 1
        BATCH = 2
        VALUE_MAP = {1 => "STREAMING", 2 => "BATCH"}
        VALID_VALUES = Set.new([STREAMING, BATCH]).freeze
      end

      module BackfillRequestStatus
        PENDING = 1
        IN_PROGRESS = 2
        COMPLETED = 3
        CANCELLED = 4
        FAILED = 5
        VALUE_MAP = {1 => "PENDING", 2 => "IN_PROGRESS", 3 => "COMPLETED", 4 => "CANCELLED", 5 => "FAILED"}
        VALID_VALUES = Set.new([PENDING, IN_PROGRESS, COMPLETED, CANCELLED, FAILED]).freeze
      end

      module SsaRefreshRequestStatus
        PENDING = 1
        IN_PROGRESS = 2
        COMPLETED = 3
        CANCELLED = 4
        FAILED = 5
        VALUE_MAP = {1 => "PENDING", 2 => "IN_PROGRESS", 3 => "COMPLETED", 4 => "CANCELLED", 5 => "FAILED"}
        VALID_VALUES = Set.new([PENDING, IN_PROGRESS, COMPLETED, CANCELLED, FAILED]).freeze
      end

      module SsaDataSyncStatType
        BACKLOG = 1
        NEW_DATA = 2
        DELTA = 3
        BACKFILL = 4
        DELETION = 6
        # Only to be used in persisting these stats to the database. Producers of these stats shouldn't use this.
# This is the total only for addition deliveries
        TOTAL = 5
        TOTAL_ADDITION = 7
        VALUE_MAP = {1 => "BACKLOG", 2 => "NEW_DATA", 3 => "DELTA", 4 => "BACKFILL", 6 => "DELETION", 5 => "TOTAL", 7 => "TOTAL_ADDITION"}
        VALID_VALUES = Set.new([BACKLOG, NEW_DATA, DELTA, BACKFILL, DELETION, TOTAL, TOTAL_ADDITION]).freeze
      end

      module DataSyncConfigParameterKey
        CONFIG_SNAPSHOT_ID = 1
        ESP_DIGEST_VERSION = 2
        ESP_VERSION = 3
        UIS_DELTA_VERSION_START = 4
        UIS_DELTA_VERSION_END = 5
        MOBILE_DELTA_VERSION_START = 6
        MOBILE_DELTA_VERSION_END = 7
        BACK_LOG_DAY_START = 8
        BACK_LOG_DAY_END = 9
        ONLINE_ESP_DIGEST_VERSION = 10
        ONLINE_ESP_VERSION = 11
        SF_DELTA_VERSION_START = 12
        SF_DELTA_VERSION_END = 13
        SYNC_FIELDS_VERSION = 14
        IS_INCLUDE_CROSS_DEVICE = 15
        MUIS_DELTA_VERSION = 16
        PP_ESP_VERSION = 17
        LATEST_AUDIENCE_VERSIONS = 18
        MATCHED_ENTITY_VERSIONS = 19
        BANG_STORE_VERSION = 20
        AUDIENCE_BATCHES = 21
        IBE_BACKLOG_DAY_START = 22
        IBE_BACKLOG_DAY_END = 23
        VALUE_MAP = {1 => "CONFIG_SNAPSHOT_ID", 2 => "ESP_DIGEST_VERSION", 3 => "ESP_VERSION", 4 => "UIS_DELTA_VERSION_START", 5 => "UIS_DELTA_VERSION_END", 6 => "MOBILE_DELTA_VERSION_START", 7 => "MOBILE_DELTA_VERSION_END", 8 => "BACK_LOG_DAY_START", 9 => "BACK_LOG_DAY_END", 10 => "ONLINE_ESP_DIGEST_VERSION", 11 => "ONLINE_ESP_VERSION", 12 => "SF_DELTA_VERSION_START", 13 => "SF_DELTA_VERSION_END", 14 => "SYNC_FIELDS_VERSION", 15 => "IS_INCLUDE_CROSS_DEVICE", 16 => "MUIS_DELTA_VERSION", 17 => "PP_ESP_VERSION", 18 => "LATEST_AUDIENCE_VERSIONS", 19 => "MATCHED_ENTITY_VERSIONS", 20 => "BANG_STORE_VERSION", 21 => "AUDIENCE_BATCHES", 22 => "IBE_BACKLOG_DAY_START", 23 => "IBE_BACKLOG_DAY_END"}
        VALID_VALUES = Set.new([CONFIG_SNAPSHOT_ID, ESP_DIGEST_VERSION, ESP_VERSION, UIS_DELTA_VERSION_START, UIS_DELTA_VERSION_END, MOBILE_DELTA_VERSION_START, MOBILE_DELTA_VERSION_END, BACK_LOG_DAY_START, BACK_LOG_DAY_END, ONLINE_ESP_DIGEST_VERSION, ONLINE_ESP_VERSION, SF_DELTA_VERSION_START, SF_DELTA_VERSION_END, SYNC_FIELDS_VERSION, IS_INCLUDE_CROSS_DEVICE, MUIS_DELTA_VERSION, PP_ESP_VERSION, LATEST_AUDIENCE_VERSIONS, MATCHED_ENTITY_VERSIONS, BANG_STORE_VERSION, AUDIENCE_BATCHES, IBE_BACKLOG_DAY_START, IBE_BACKLOG_DAY_END]).freeze
      end

      module SsaThrottleReason
        FAILED_INTEGRATION_TEST = 1
        FAILURES_IN_DELIVERY = 2
        TRANSIENT_FAILURES_IN_DELIVERY = 3
        VALUE_MAP = {1 => "FAILED_INTEGRATION_TEST", 2 => "FAILURES_IN_DELIVERY", 3 => "TRANSIENT_FAILURES_IN_DELIVERY"}
        VALID_VALUES = Set.new([FAILED_INTEGRATION_TEST, FAILURES_IN_DELIVERY, TRANSIENT_FAILURES_IN_DELIVERY]).freeze
      end

      module DeliveryPrioritizationRequestType
        JOB = 1
        SSA = 2
        AUDIENCE = 3
        CUSTOMER = 4
        VALUE_MAP = {1 => "JOB", 2 => "SSA", 3 => "AUDIENCE", 4 => "CUSTOMER"}
        VALID_VALUES = Set.new([JOB, SSA, AUDIENCE, CUSTOMER]).freeze
      end

      module DeliveryPrioritizationRequestStatus
        ACTIVE = 1
        CANCELED = 2
        VALUE_MAP = {1 => "ACTIVE", 2 => "CANCELED"}
        VALID_VALUES = Set.new([ACTIVE, CANCELED]).freeze
      end

      module StreamingChunkStatus
        WAITING = 1
        DELIVERING = 2
        DONE = 3
        FAILED = 4
        VALUE_MAP = {1 => "WAITING", 2 => "DELIVERING", 3 => "DONE", 4 => "FAILED"}
        VALID_VALUES = Set.new([WAITING, DELIVERING, DONE, FAILED]).freeze
      end

      module EspFieldReachType
        COOKIE = 1
        MOBILE = 2
        CUSTOM_ID = 3
        ANY = 4
        VALUE_MAP = {1 => "COOKIE", 2 => "MOBILE", 3 => "CUSTOM_ID", 4 => "ANY"}
        VALID_VALUES = Set.new([COOKIE, MOBILE, CUSTOM_ID, ANY]).freeze
      end

      module FieldTransformationType
        NONE = 0
        MD5 = 1
        AES = 2
        VALUE_MAP = {0 => "NONE", 1 => "MD5", 2 => "AES"}
        VALID_VALUES = Set.new([NONE, MD5, AES]).freeze
      end

      module SsaUserDeletionMechanism
        SEPARATE_ADD_AND_DELETE = 1
        ADDELETION = 2
        FULL_OVERWRITE = 3
        VALUE_MAP = {1 => "SEPARATE_ADD_AND_DELETE", 2 => "ADDELETION", 3 => "FULL_OVERWRITE"}
        VALID_VALUES = Set.new([SEPARATE_ADD_AND_DELETE, ADDELETION, FULL_OVERWRITE]).freeze
      end

      class S2SDataKey < ::Thrift::Union; end

      class S2SDataKeyMap; end

      class S2SDataSyncTracker; end

      class S2SUserInSync; end

      class BadHeid; end

      class MobileUserInSync; end

      class CustomIdUserInSync; end

      class EHPiiUserInSync; end

      class PIIFileKeyInfo; end

      class PIIDataSyncRequest; end

      class DeviceInfo < ::Thrift::Union; end

      class S2SDataSyncRequest; end

      class S2SDataSyncRequestWithEsp; end

      class OldSync; end

      class OldCookieSyncs; end

      class S2SDataKeyESP; end

      class TargetEvent; end

      class CookieSync; end

      class CookieSyncs; end

      class SyncFields; end

      class ExternalIdSyncFields; end

      class SyncFieldsImportRecord; end

      class MuidAnaMappings; end

      class MuidInfoMappings; end

      class S2SFieldPack; end

      class S2SDataSyncRequestWithFP; end

      class HyperLogLogKeyValuePair; end

      class BatchFile; end

      class BatchSampleOutput; end

      class StreamingSampleOutput; end

      class StreamingSampleOutputResponse < ::Thrift::Union; end

      class StreamingJobState; end

      class ApiTestResult; end

      class SsaDataSyncStat; end

      class UISMatchSnapshot; end

      class AnaCookieStatSyncFields; end

      class AnaCookieStatUsersInSync; end

      class OnlineAudienceMemberData; end

      class NullPuidExternalCookieSyncCounter; end

      class UserInSyncStatCount; end

      class AnonymousIdentifierAndFields; end

      class MatchedAnonymousIdentifierAndFields; end

      class PotentialDataMatch; end

      class BangRecordMatch; end

      class BatchSampleOutputResponse < ::Thrift::Union; end

      class UserInSyncAndRelatedEdges; end

      class DeliveryDigest; end

      class BacklogRange; end

      class S2SDataKey < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def heid(val)
            S2SDataKey.new(:heid, val)
          end

          def zip(val)
            S2SDataKey.new(:zip, val)
          end

          def cookie_id(val)
            S2SDataKey.new(:cookie_id, val)
          end

          def matched_heid(val)
            S2SDataKey.new(:matched_heid, val)
          end

          def device_id(val)
            S2SDataKey.new(:device_id, val)
          end
        end

        HEID = 1
        ZIP = 2
        COOKIE_ID = 3
        MATCHED_HEID = 4
        DEVICE_ID = 5

        FIELDS = {
          # Deprecated. Use matched_heid instead.
          HEID => {:type => ::Thrift::Types::STRING, :name => 'heid', :binary => true, :optional => true},
          # Deprecated.
          ZIP => {:type => ::Thrift::Types::STRING, :name => 'zip', :optional => true},
          # Deprecated. Use device_id instead.
          COOKIE_ID => {:type => ::Thrift::Types::STRING, :name => 'cookie_id', :binary => true, :optional => true},
          MATCHED_HEID => {:type => ::Thrift::Types::STRUCT, :name => 'matched_heid', :class => ::Rapleaf::Types::Spruce::MatchedHeid, :optional => true},
          DEVICE_ID => {:type => ::Thrift::Types::STRUCT, :name => 'device_id', :class => ::Rapleaf::Types::Spruce::DeviceId, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class S2SDataKeyMap
        include ::Thrift::Struct, ::Thrift::Struct_Union
        DATA_KEY_BY_SUBNETWORKS = 1

        FIELDS = {
          DATA_KEY_BY_SUBNETWORKS => {:type => ::Thrift::Types::MAP, :name => 'data_key_by_subnetworks', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::S2SIntegrations::S2SDataKey}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Data structure used in S2SDataSyncRequests to track/identify a group of requests
# as all belonging to some higher level grouping like a DataSyncConfig
      class S2SDataSyncTracker
        include ::Thrift::Struct, ::Thrift::Struct_Union
        DATA_SYNC_JOB_IDS = 1
        END_OF_STREAM = 2
        DATA_SYNC_JOB_ID = 3
        UID = 4
        SERVICE_REQUEST_ID = 5

        FIELDS = {
          # Depreciated
          DATA_SYNC_JOB_IDS => {:type => ::Thrift::Types::SET, :name => 'data_sync_job_ids', :element => {:type => ::Thrift::Types::I64}, :optional => true},
          # Specifies that this request is a sentinel value specifying the end of a stream of requests
          END_OF_STREAM => {:type => ::Thrift::Types::BOOL, :name => 'end_of_stream'},
          # Depreciated
          DATA_SYNC_JOB_ID => {:type => ::Thrift::Types::I64, :name => 'data_sync_job_id', :optional => true},
          UID => {:type => ::Thrift::Types::I32, :name => 'uid', :optional => true},
          SERVICE_REQUEST_ID => {:type => ::Thrift::Types::I64, :name => 'service_request_id', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field end_of_stream is unset!') if @end_of_stream.nil?
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Struct to keep track of users in sync.
      class S2SUserInSync
        include ::Thrift::Struct, ::Thrift::Struct_Union
        OLD_COOKIE_ID = 2
        AD_NETWORK_ACCOUNT_ID = 3
        SYNCED_AT = 4
        EXTERNAL_COOKIE_ID = 6
        LAST_SEEN_AT = 10
        COOKIEABLE = 11
        DATA_KEY_BY_SUBNETWORKS = 12
        DEVICE_ID = 13
        PARTNER_LINK_INDIVIDUAL_PEL = 15
        PARTNER_LINK_HOUSEHOLD_PEL = 16
        USER_AGENT = 14
        USER_AGENT_ENUM = 17

        FIELDS = {
          # This field is only provided for legacy support reasons. If you want the cookie ID, you should use
# the cookie_id field instead.
          OLD_COOKIE_ID => {:type => ::Thrift::Types::STRING, :name => 'old_cookie_id', :binary => true, :optional => true},
          # The ad network account the user is in sync with.
          AD_NETWORK_ACCOUNT_ID => {:type => ::Thrift::Types::I64, :name => 'ad_network_account_id'},
          SYNCED_AT => {:type => ::Thrift::Types::I32, :name => 'synced_at'},
          EXTERNAL_COOKIE_ID => {:type => ::Thrift::Types::STRING, :name => 'external_cookie_id', :optional => true},
          # timestamp corresponding to the last time we saw this user
          LAST_SEEN_AT => {:type => ::Thrift::Types::I32, :name => 'last_seen_at', :optional => true},
          # boolean indicating whether or not this user is cookieable. this will be true
# if we've seen even one request from the user that indicates they're cookieable.
          COOKIEABLE => {:type => ::Thrift::Types::BOOL, :name => 'cookieable', :optional => true},
          DATA_KEY_BY_SUBNETWORKS => {:type => ::Thrift::Types::MAP, :name => 'data_key_by_subnetworks', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::S2SIntegrations::S2SDataKey}, :optional => true},
          # The REAL cookie id.
          DEVICE_ID => {:type => ::Thrift::Types::STRUCT, :name => 'device_id', :class => ::Rapleaf::Types::Spruce::DeviceId, :optional => true},
          # These fields enable us to send a DeviceId plus up to two additional
# PELs to a destination.
          PARTNER_LINK_INDIVIDUAL_PEL => {:type => ::Thrift::Types::STRING, :name => 'partner_link_individual_pel', :optional => true},
          PARTNER_LINK_HOUSEHOLD_PEL => {:type => ::Thrift::Types::STRING, :name => 'partner_link_household_pel', :optional => true},
          # This field enables matched device stats to include mobile browser reporting.
          USER_AGENT => {:type => ::Thrift::Types::STRING, :name => 'user_agent', :optional => true},
          USER_AGENT_ENUM => {:type => ::Thrift::Types::STRUCT, :name => 'user_agent_enum', :class => ::Liveramp::UserAgent::UserAgent, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field ad_network_account_id is unset!') unless @ad_network_account_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field synced_at is unset!') unless @synced_at
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A HEID is considered bad if it has too many cookie ids attached to it.
      class BadHeid
        include ::Thrift::Struct, ::Thrift::Struct_Union
        HEID = 1
        DEVICE_COUNT = 2
        LAST_FLAGGED_AS_BAD = 3

        FIELDS = {
          HEID => {:type => ::Thrift::Types::STRING, :name => 'heid', :binary => true},
          DEVICE_COUNT => {:type => ::Thrift::Types::I32, :name => 'device_count'},
          LAST_FLAGGED_AS_BAD => {:type => ::Thrift::Types::I32, :name => 'last_flagged_as_bad'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field heid is unset!') unless @heid
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field device_count is unset!') unless @device_count
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field last_flagged_as_bad is unset!') unless @last_flagged_as_bad
        end

        ::Thrift::Struct.generate_accessors self
      end

      class MobileUserInSync
        include ::Thrift::Struct, ::Thrift::Struct_Union
        LRMID = 1
        MUID = 2
        DATA_KEY_BY_SUBNETWORKS = 3
        LAST_IMPORTED_AT = 4
        LAST_SEEN_AT = 5
        AD_NETWORK_ACCOUNT_ID = 6
        PARTNER_LINK_INDIVIDUAL_PEL = 7
        PARTNER_LINK_HOUSEHOLD_PEL = 8

        FIELDS = {
          # This should always be the Liveramp Mobile User ID (LRMID). It's wrapped in
# a DeviceId because that way sorting is compatible with the way logs are sorted.
          LRMID => {:type => ::Thrift::Types::STRUCT, :name => 'lrmid', :class => ::Rapleaf::Types::Spruce::DeviceId},
          MUID => {:type => ::Thrift::Types::STRUCT, :name => 'muid', :class => ::Liveramp::Types::Mobile::MUID},
          DATA_KEY_BY_SUBNETWORKS => {:type => ::Thrift::Types::MAP, :name => 'data_key_by_subnetworks', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::S2SIntegrations::S2SDataKey}},
          LAST_IMPORTED_AT => {:type => ::Thrift::Types::I32, :name => 'last_imported_at'},
          # timestamp corresponding to the last time the device was seen (may be before the import time)
          LAST_SEEN_AT => {:type => ::Thrift::Types::I32, :name => 'last_seen_at', :optional => true},
          AD_NETWORK_ACCOUNT_ID => {:type => ::Thrift::Types::I64, :name => 'ad_network_account_id'},
          # These fields enable us to send a DeviceId plus up to two additional
# PELs to a destination.
          PARTNER_LINK_INDIVIDUAL_PEL => {:type => ::Thrift::Types::STRING, :name => 'partner_link_individual_pel', :optional => true},
          PARTNER_LINK_HOUSEHOLD_PEL => {:type => ::Thrift::Types::STRING, :name => 'partner_link_household_pel', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field lrmid is unset!') unless @lrmid
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field muid is unset!') unless @muid
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field data_key_by_subnetworks is unset!') unless @data_key_by_subnetworks
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field last_imported_at is unset!') unless @last_imported_at
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field ad_network_account_id is unset!') unless @ad_network_account_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      class CustomIdUserInSync
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CID_DEVICE_ID = 1
        DATA_KEY_BY_SUBNETWORKS = 2
        CID_EXTERNAL_ID = 3
        AD_NETWORK_ACCOUNT_ID = 4
        PARTNER_LINK_INDIVIDUAL_PEL = 5
        PARTNER_LINK_HOUSEHOLD_PEL = 6
        USER_METADATA_HASH = 7

        FIELDS = {
          CID_DEVICE_ID => {:type => ::Thrift::Types::STRUCT, :name => 'cid_device_id', :class => ::Rapleaf::Types::Spruce::DeviceId},
          DATA_KEY_BY_SUBNETWORKS => {:type => ::Thrift::Types::MAP, :name => 'data_key_by_subnetworks', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::S2SIntegrations::S2SDataKey}},
          CID_EXTERNAL_ID => {:type => ::Thrift::Types::STRING, :name => 'cid_external_id'},
          AD_NETWORK_ACCOUNT_ID => {:type => ::Thrift::Types::I64, :name => 'ad_network_account_id'},
          # These fields enable us to send a DeviceId plus up to two additional
# PELs to a destination.
          PARTNER_LINK_INDIVIDUAL_PEL => {:type => ::Thrift::Types::STRING, :name => 'partner_link_individual_pel', :optional => true},
          PARTNER_LINK_HOUSEHOLD_PEL => {:type => ::Thrift::Types::STRING, :name => 'partner_link_household_pel', :optional => true},
          USER_METADATA_HASH => {:type => ::Thrift::Types::STRING, :name => 'user_metadata_hash', :binary => true, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field cid_device_id is unset!') unless @cid_device_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field data_key_by_subnetworks is unset!') unless @data_key_by_subnetworks
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field cid_external_id is unset!') unless @cid_external_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field ad_network_account_id is unset!') unless @ad_network_account_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      class EHPiiUserInSync
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ENC_SHA256_EMAIL = 1
        ENC_SHA256_NAP = 2

        FIELDS = {
          ENC_SHA256_EMAIL => {:type => ::Thrift::Types::STRING, :name => 'enc_sha256_email', :binary => true, :optional => true},
          ENC_SHA256_NAP => {:type => ::Thrift::Types::STRUCT, :name => 'enc_sha256_nap', :class => ::Liveramp::Types::PiiIntegration::EncSHA256Nap, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class PIIFileKeyInfo
        include ::Thrift::Struct, ::Thrift::Struct_Union
        IDENTIFIER = 1

        FIELDS = {
          IDENTIFIER => {:type => ::Thrift::Types::STRING, :name => 'identifier'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field identifier is unset!') unless @identifier
        end

        ::Thrift::Struct.generate_accessors self
      end

      class PIIDataSyncRequest
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PII_INFO = 1
        SERVER_SIDE_ACCOUNT_IDS = 2

        FIELDS = {
          PII_INFO => {:type => ::Thrift::Types::STRUCT, :name => 'pii_info', :class => ::Rapleaf::Types::S2SIntegrations::PIIFileKeyInfo},
          SERVER_SIDE_ACCOUNT_IDS => {:type => ::Thrift::Types::SET, :name => 'server_side_account_ids', :element => {:type => ::Thrift::Types::I64}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field pii_info is unset!') unless @pii_info
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field server_side_account_ids is unset!') unless @server_side_account_ids
        end

        ::Thrift::Struct.generate_accessors self
      end

      class DeviceInfo < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def s2s_user_in_sync(val)
            DeviceInfo.new(:s2s_user_in_sync, val)
          end

          def mobile_user_in_sync(val)
            DeviceInfo.new(:mobile_user_in_sync, val)
          end

          def cid_user_in_sync(val)
            DeviceInfo.new(:cid_user_in_sync, val)
          end

          def ehpii_user_in_sync(val)
            DeviceInfo.new(:ehpii_user_in_sync, val)
          end

          def encrypted_hashed_pii(val)
            DeviceInfo.new(:encrypted_hashed_pii, val)
          end
        end

        S2S_USER_IN_SYNC = 1
        MOBILE_USER_IN_SYNC = 2
        CID_USER_IN_SYNC = 3
        EHPII_USER_IN_SYNC = 4
        ENCRYPTED_HASHED_PII = 5

        FIELDS = {
          S2S_USER_IN_SYNC => {:type => ::Thrift::Types::STRUCT, :name => 's2s_user_in_sync', :class => ::Rapleaf::Types::S2SIntegrations::S2SUserInSync, :optional => true},
          MOBILE_USER_IN_SYNC => {:type => ::Thrift::Types::STRUCT, :name => 'mobile_user_in_sync', :class => ::Rapleaf::Types::S2SIntegrations::MobileUserInSync, :optional => true},
          CID_USER_IN_SYNC => {:type => ::Thrift::Types::STRUCT, :name => 'cid_user_in_sync', :class => ::Rapleaf::Types::S2SIntegrations::CustomIdUserInSync, :optional => true},
          EHPII_USER_IN_SYNC => {:type => ::Thrift::Types::STRUCT, :name => 'ehpii_user_in_sync', :class => ::Rapleaf::Types::S2SIntegrations::EHPiiUserInSync, :optional => true},
          ENCRYPTED_HASHED_PII => {:type => ::Thrift::Types::STRUCT, :name => 'encrypted_hashed_pii', :class => ::Liveramp::Types::PiiIntegration::EncryptedHashedPii, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      # Data structure used by the s2s streaming and batch data syncers.
      class S2SDataSyncRequest
        include ::Thrift::Struct, ::Thrift::Struct_Union
        DEVICE_INFO = 1
        TRACKER = 4
        SERVER_SIDE_ACCOUNT_IDS = 5
        PUBLISHER_SUBNETWORK_ID = 6
        QA_REQUEST = 7
        CONFIDENCE = 8

        FIELDS = {
          DEVICE_INFO => {:type => ::Thrift::Types::STRUCT, :name => 'device_info', :class => ::Rapleaf::Types::S2SIntegrations::DeviceInfo},
          TRACKER => {:type => ::Thrift::Types::STRUCT, :name => 'tracker', :class => ::Rapleaf::Types::S2SIntegrations::S2SDataSyncTracker, :optional => true},
          SERVER_SIDE_ACCOUNT_IDS => {:type => ::Thrift::Types::SET, :name => 'server_side_account_ids', :element => {:type => ::Thrift::Types::I64}},
          PUBLISHER_SUBNETWORK_ID => {:type => ::Thrift::Types::I64, :name => 'publisher_subnetwork_id', :optional => true},
          QA_REQUEST => {:type => ::Thrift::Types::BOOL, :name => 'qa_request', :optional => true},
          # The confidence of the AIMRecord that was used to create this request. This is a small hack to allow us
# to support attribution on the SOA refresher. For attribution, we don't want audience member consistency,
# but we do want to be able to send just one record per input line. This field lets us choose the best record
# per input line in a self-contained post-refresher step.
          CONFIDENCE => {:type => ::Thrift::Types::I32, :name => 'confidence', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field device_info is unset!') unless @device_info
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field server_side_account_ids is unset!') unless @server_side_account_ids
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Data structure used by s2s streaming and batch after joining esps with S2SDataSyncRequests
      class S2SDataSyncRequestWithEsp
        include ::Thrift::Struct, ::Thrift::Struct_Union
        S2S_DATA_SYNC_REQUEST = 1
        ESP = 2

        FIELDS = {
          S2S_DATA_SYNC_REQUEST => {:type => ::Thrift::Types::STRUCT, :name => 's2s_data_sync_request', :class => ::Rapleaf::Types::S2SIntegrations::S2SDataSyncRequest},
          ESP => {:type => ::Thrift::Types::STRUCT, :name => 'esp', :class => ::Rapleaf::Types::Spruce::EntitySegmentPack}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field s2s_data_sync_request is unset!') unless @s2s_data_sync_request
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field esp is unset!') unless @esp
        end

        ::Thrift::Struct.generate_accessors self
      end

      class OldSync
        include ::Thrift::Struct, ::Thrift::Struct_Union
        AD_NETWORK_ACCOUNT_ID = 1
        PARTNER_UID = 2

        FIELDS = {
          AD_NETWORK_ACCOUNT_ID => {:type => ::Thrift::Types::I64, :name => 'ad_network_account_id'},
          PARTNER_UID => {:type => ::Thrift::Types::STRING, :name => 'partner_uid', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field ad_network_account_id is unset!') unless @ad_network_account_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Data structure to store all s2s syncs we made before we started
# storing them in a cookie on the browser. This is a temporary solution
# for backwards compatibility only.
      class OldCookieSyncs
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COOKIE_ID = 1
        SYNCS = 2
        NEW_COOKIE_ID = 3

        FIELDS = {
          COOKIE_ID => {:type => ::Thrift::Types::STRING, :name => 'cookie_id', :binary => true},
          SYNCS => {:type => ::Thrift::Types::SET, :name => 'syncs', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::S2SIntegrations::OldSync}},
          NEW_COOKIE_ID => {:type => ::Thrift::Types::STRUCT, :name => 'new_cookie_id', :class => ::Rapleaf::Types::Spruce::DeviceId, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field cookie_id is unset!') unless @cookie_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field syncs is unset!') unless @syncs
        end

        ::Thrift::Struct.generate_accessors self
      end

      class S2SDataKeyESP
        include ::Thrift::Struct, ::Thrift::Struct_Union
        S2S_DATA_KEY = 1
        ESP = 2

        FIELDS = {
          S2S_DATA_KEY => {:type => ::Thrift::Types::STRUCT, :name => 's2s_data_key', :class => ::Rapleaf::Types::S2SIntegrations::S2SDataKey},
          ESP => {:type => ::Thrift::Types::STRUCT, :name => 'esp', :class => ::Rapleaf::Types::Spruce::EntitySegmentPack}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field s2s_data_key is unset!') unless @s2s_data_key
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field esp is unset!') unless @esp
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Used for keeping track of who to retarget
      class TargetEvent
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COOKIE_ID = 1
        S2S_USER_IN_SYNC = 4
        RETARGET_FIELD_ID = 6

        FIELDS = {
          COOKIE_ID => {:type => ::Thrift::Types::STRING, :name => 'cookie_id', :binary => true},
          S2S_USER_IN_SYNC => {:type => ::Thrift::Types::STRUCT, :name => 's2s_user_in_sync', :class => ::Rapleaf::Types::S2SIntegrations::S2SUserInSync},
          RETARGET_FIELD_ID => {:type => ::Thrift::Types::I32, :name => 'retarget_field_id'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field cookie_id is unset!') unless @cookie_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field s2s_user_in_sync is unset!') unless @s2s_user_in_sync
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field retarget_field_id is unset!') unless @retarget_field_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      class CookieSync
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PARTNER_UID = 1
        SYNCED_AT = 2

        FIELDS = {
          PARTNER_UID => {:type => ::Thrift::Types::STRING, :name => 'partner_uid'},
          SYNCED_AT => {:type => ::Thrift::Types::I32, :name => 'synced_at'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field partner_uid is unset!') unless @partner_uid
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field synced_at is unset!') unless @synced_at
        end

        ::Thrift::Struct.generate_accessors self
      end

      class CookieSyncs
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COOKIE_ID = 1
        SYNCS_BY_ANA_ID = 2

        FIELDS = {
          COOKIE_ID => {:type => ::Thrift::Types::STRING, :name => 'cookie_id', :binary => true},
          SYNCS_BY_ANA_ID => {:type => ::Thrift::Types::MAP, :name => 'syncs_by_ana_id', :key => {:type => ::Thrift::Types::I32}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::S2SIntegrations::CookieSync}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field cookie_id is unset!') unless @cookie_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field syncs_by_ana_id is unset!') unless @syncs_by_ana_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      # This type is used for a temporary store that is the basis
# to create S2SUsersInSync and CookieSyncs. It cannot be a
# TupleStore because it needs to be usable by map-side joins.
      class SyncFields
        include ::Thrift::Struct, ::Thrift::Struct_Union
        OLD_COOKIE_ID = 1
        ID_SYNC_COOKIE = 2
        LAST_SEEN_AT = 5
        COOKIEABLE = 6
        COOKIE_ID = 7
        DATA_KEY_BY_SUBNETWORKS = 8
        USER_AGENT = 9
        USER_AGENT_ENUM = 10

        FIELDS = {
          # This field is only provided for legacy support reasons. If you want the cookie ID, you should use
# the cookie_id field instead.
          OLD_COOKIE_ID => {:type => ::Thrift::Types::STRING, :name => 'old_cookie_id', :binary => true, :optional => true},
          ID_SYNC_COOKIE => {:type => ::Thrift::Types::STRUCT, :name => 'id_sync_cookie', :class => ::Rapleaf::Types::Spruce::IdSyncCookie},
          LAST_SEEN_AT => {:type => ::Thrift::Types::I32, :name => 'last_seen_at', :optional => true},
          COOKIEABLE => {:type => ::Thrift::Types::BOOL, :name => 'cookieable', :optional => true},
          # The REAL cookie id.
          COOKIE_ID => {:type => ::Thrift::Types::STRUCT, :name => 'cookie_id', :class => ::Rapleaf::Types::Spruce::DeviceId, :optional => true},
          DATA_KEY_BY_SUBNETWORKS => {:type => ::Thrift::Types::MAP, :name => 'data_key_by_subnetworks', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::S2SIntegrations::S2SDataKey}, :optional => true},
          # This field enables matched device stats to include mobile browser reporting.
          USER_AGENT => {:type => ::Thrift::Types::STRING, :name => 'user_agent', :optional => true},
          USER_AGENT_ENUM => {:type => ::Thrift::Types::STRUCT, :name => 'user_agent_enum', :class => ::Liveramp::UserAgent::UserAgent, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field id_sync_cookie is unset!') unless @id_sync_cookie
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ExternalIdSyncFields
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SYNCED_COOKIE = 1
        SYNCED_AT = 2
        DEVICE_ID = 3
        COOKIEABLE = 4
        LAST_SEEN_AT = 5

        FIELDS = {
          SYNCED_COOKIE => {:type => ::Thrift::Types::STRUCT, :name => 'synced_cookie', :class => ::Liveramp::OnlineData::SyncedCookie},
          SYNCED_AT => {:type => ::Thrift::Types::I32, :name => 'synced_at'},
          DEVICE_ID => {:type => ::Thrift::Types::STRUCT, :name => 'device_id', :class => ::Rapleaf::Types::Spruce::DeviceId},
          COOKIEABLE => {:type => ::Thrift::Types::BOOL, :name => 'cookieable', :optional => true},
          LAST_SEEN_AT => {:type => ::Thrift::Types::I32, :name => 'last_seen_at', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field synced_cookie is unset!') unless @synced_cookie
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field synced_at is unset!') unless @synced_at
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field device_id is unset!') unless @device_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Struct to import id sync mappings from files and integrate them into our SyncFields store.
# 
      class SyncFieldsImportRecord
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SYNCED_COOKIE = 1
        ID_SYNC_COOKIE = 2

        FIELDS = {
          # The primary ANA and external cookie id that we join by.
# 
          SYNCED_COOKIE => {:type => ::Thrift::Types::STRUCT, :name => 'synced_cookie', :class => ::Liveramp::OnlineData::SyncedCookie},
          # All syncs we that we want to import.
# 
          ID_SYNC_COOKIE => {:type => ::Thrift::Types::STRUCT, :name => 'id_sync_cookie', :class => ::Rapleaf::Types::Spruce::IdSyncCookie}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field synced_cookie is unset!') unless @synced_cookie
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field id_sync_cookie is unset!') unless @id_sync_cookie
        end

        ::Thrift::Struct.generate_accessors self
      end

      class MuidAnaMappings
        include ::Thrift::Struct, ::Thrift::Struct_Union
        DEVICE_ID = 1
        MUIDS_BY_ANA_ID = 2

        FIELDS = {
          DEVICE_ID => {:type => ::Thrift::Types::STRUCT, :name => 'device_id', :class => ::Rapleaf::Types::Spruce::DeviceId},
          MUIDS_BY_ANA_ID => {:type => ::Thrift::Types::MAP, :name => 'muids_by_ana_id', :key => {:type => ::Thrift::Types::I32}, :value => {:type => ::Thrift::Types::SET, :element => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::Mobile::MUID}}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field device_id is unset!') unless @device_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field muids_by_ana_id is unset!') unless @muids_by_ana_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      class MuidInfoMappings
        include ::Thrift::Struct, ::Thrift::Struct_Union
        DEVICE_ID = 1
        MUID_TO_PUBLISHER_IDS = 2
        LAST_IMPORTED_AT = 3
        LAST_SEEN_AT = 4
        HEID = 5

        FIELDS = {
          DEVICE_ID => {:type => ::Thrift::Types::STRUCT, :name => 'device_id', :class => ::Rapleaf::Types::Spruce::DeviceId},
          MUID_TO_PUBLISHER_IDS => {:type => ::Thrift::Types::MAP, :name => 'muid_to_publisher_ids', :key => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::Mobile::MUID}, :value => {:type => ::Thrift::Types::SET, :element => {:type => ::Thrift::Types::I32}}},
          LAST_IMPORTED_AT => {:type => ::Thrift::Types::I32, :name => 'last_imported_at'},
          LAST_SEEN_AT => {:type => ::Thrift::Types::I32, :name => 'last_seen_at', :optional => true},
          HEID => {:type => ::Thrift::Types::STRING, :name => 'heid', :binary => true, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field device_id is unset!') unless @device_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field muid_to_publisher_ids is unset!') unless @muid_to_publisher_ids
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field last_imported_at is unset!') unless @last_imported_at
        end

        ::Thrift::Struct.generate_accessors self
      end

      class S2SFieldPack
        include ::Thrift::Struct, ::Thrift::Struct_Union
        DATA_KEY = 1
        AUDIENCE_FIELD_VALUES = 4
        SOURCE = 5

        FIELDS = {
          DATA_KEY => {:type => ::Thrift::Types::STRUCT, :name => 'data_key', :class => ::Rapleaf::Types::S2SIntegrations::S2SDataKey, :optional => true},
          AUDIENCE_FIELD_VALUES => {:type => ::Thrift::Types::MAP, :name => 'audience_field_values', :key => {:type => ::Thrift::Types::I32, :enum_class => ::Rapleaf::Types::PersonData::OnlineMatchPartner}, :value => {:type => ::Thrift::Types::MAP, :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Audience::AnonymousMemberFields}}, :optional => true},
          SOURCE => {:type => ::Thrift::Types::I32, :name => 'source', :optional => true, :enum_class => ::Rapleaf::Types::S2SIntegrations::S2SFieldPackSource}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @source.nil? || ::Rapleaf::Types::S2SIntegrations::S2SFieldPackSource::VALID_VALUES.include?(@source)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field source!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Data structure used by s2s streaming and batch after joining csps with S2SDataSyncRequests
      class S2SDataSyncRequestWithFP
        include ::Thrift::Struct, ::Thrift::Struct_Union
        S2S_DATA_SYNC_REQUEST = 1
        S2S_FIELD_PACK = 2

        FIELDS = {
          S2S_DATA_SYNC_REQUEST => {:type => ::Thrift::Types::STRUCT, :name => 's2s_data_sync_request', :class => ::Rapleaf::Types::S2SIntegrations::S2SDataSyncRequest},
          S2S_FIELD_PACK => {:type => ::Thrift::Types::STRUCT, :name => 's2s_field_pack', :class => ::Rapleaf::Types::S2SIntegrations::S2SFieldPack, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field s2s_data_sync_request is unset!') unless @s2s_data_sync_request
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Wrapper type used to contain a ANA ID and a HLL counter
      class HyperLogLogKeyValuePair
        include ::Thrift::Struct, ::Thrift::Struct_Union
        KEY = 1
        VALUE = 2

        FIELDS = {
          KEY => {:type => ::Thrift::Types::STRING, :name => 'key'},
          VALUE => {:type => ::Thrift::Types::STRING, :name => 'value', :binary => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field key is unset!') unless @key
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field value is unset!') unless @value
        end

        ::Thrift::Struct.generate_accessors self
      end

      class BatchFile
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PATH = 1
        CONTENT = 2

        FIELDS = {
          PATH => {:type => ::Thrift::Types::STRING, :name => 'path'},
          CONTENT => {:type => ::Thrift::Types::LIST, :name => 'content', :element => {:type => ::Thrift::Types::STRING}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class BatchSampleOutput
        include ::Thrift::Struct, ::Thrift::Struct_Union
        FILES = 1

        FIELDS = {
          FILES => {:type => ::Thrift::Types::LIST, :name => 'files', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::S2SIntegrations::BatchFile}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class StreamingSampleOutput
        include ::Thrift::Struct, ::Thrift::Struct_Union
        URL = 1
        POST_DATA = 2

        FIELDS = {
          URL => {:type => ::Thrift::Types::STRING, :name => 'url'},
          POST_DATA => {:type => ::Thrift::Types::STRING, :name => 'post_data'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class StreamingSampleOutputResponse < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def sample_output(val)
            StreamingSampleOutputResponse.new(:sample_output, val)
          end

          def error(val)
            StreamingSampleOutputResponse.new(:error, val)
          end
        end

        SAMPLE_OUTPUT = 1
        ERROR = 2

        FIELDS = {
          SAMPLE_OUTPUT => {:type => ::Thrift::Types::STRUCT, :name => 'sample_output', :class => ::Rapleaf::Types::S2SIntegrations::StreamingSampleOutput, :optional => true},
          ERROR => {:type => ::Thrift::Types::STRING, :name => 'error', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class StreamingJobState
        include ::Thrift::Struct, ::Thrift::Struct_Union
        NUM_ENQUEUED_REQUESTS = 1
        NUM_PENDING_REQUESTS = 2

        FIELDS = {
          NUM_ENQUEUED_REQUESTS => {:type => ::Thrift::Types::I64, :name => 'num_enqueued_requests'},
          NUM_PENDING_REQUESTS => {:type => ::Thrift::Types::I64, :name => 'num_pending_requests'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ApiTestResult
        include ::Thrift::Struct, ::Thrift::Struct_Union
        STATUS = 1
        REASON = 2

        FIELDS = {
          STATUS => {:type => ::Thrift::Types::I32, :name => 'status', :enum_class => ::Rapleaf::Types::S2SIntegrations::ApiTestStatus},
          REASON => {:type => ::Thrift::Types::STRING, :name => 'reason'}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @status.nil? || ::Rapleaf::Types::S2SIntegrations::ApiTestStatus::VALID_VALUES.include?(@status)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field status!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class SsaDataSyncStat
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SSA_ID = 1
        STAT_TYPE = 2
        COUNT = 3

        FIELDS = {
          SSA_ID => {:type => ::Thrift::Types::I64, :name => 'ssa_id'},
          STAT_TYPE => {:type => ::Thrift::Types::I32, :name => 'stat_type', :enum_class => ::Rapleaf::Types::S2SIntegrations::SsaDataSyncStatType},
          COUNT => {:type => ::Thrift::Types::I64, :name => 'count'}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @stat_type.nil? || ::Rapleaf::Types::S2SIntegrations::SsaDataSyncStatType::VALID_VALUES.include?(@stat_type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field stat_type!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Used for "Optimize Match Network Cost" project.
      class UISMatchSnapshot
        include ::Thrift::Struct, ::Thrift::Struct_Union
        HEID = 1
        DEVICE_ID = 2
        UIS_VERSION = 3
        LAST_SEEN_AT = 4
        ANA_IDS = 5
        COOKIEABLE = 6

        FIELDS = {
          HEID => {:type => ::Thrift::Types::STRING, :name => 'heid', :binary => true},
          DEVICE_ID => {:type => ::Thrift::Types::STRUCT, :name => 'device_id', :class => ::Rapleaf::Types::Spruce::DeviceId},
          UIS_VERSION => {:type => ::Thrift::Types::I32, :name => 'uis_version'},
          LAST_SEEN_AT => {:type => ::Thrift::Types::I32, :name => 'last_seen_at'},
          ANA_IDS => {:type => ::Thrift::Types::SET, :name => 'ana_ids', :element => {:type => ::Thrift::Types::I64}},
          COOKIEABLE => {:type => ::Thrift::Types::BOOL, :name => 'cookieable'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field heid is unset!') unless @heid
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field device_id is unset!') unless @device_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field uis_version is unset!') unless @uis_version
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field last_seen_at is unset!') unless @last_seen_at
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field ana_ids is unset!') unless @ana_ids
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field cookieable is unset!') if @cookieable.nil?
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Struct for caching database LiverampStatsS2sCookiePoolSize in S2SIdSyncRefresher / UpdateSyncFieldsStores
      class AnaCookieStatSyncFields
        include ::Thrift::Struct, ::Thrift::Struct_Union
        AD_NETWORK_ACCOUNT_ID = 1
        IS_BACKLOG = 2
        TOTAL_COOKIE = 3
        COOKIEABLE_TOTAL_COOKIE = 4

        FIELDS = {
          AD_NETWORK_ACCOUNT_ID => {:type => ::Thrift::Types::I64, :name => 'ad_network_account_id'},
          IS_BACKLOG => {:type => ::Thrift::Types::BOOL, :name => 'is_backlog'},
          TOTAL_COOKIE => {:type => ::Thrift::Types::I64, :name => 'total_cookie'},
          COOKIEABLE_TOTAL_COOKIE => {:type => ::Thrift::Types::I64, :name => 'cookieable_total_cookie'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field ad_network_account_id is unset!') unless @ad_network_account_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field is_backlog is unset!') if @is_backlog.nil?
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field total_cookie is unset!') unless @total_cookie
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field cookieable_total_cookie is unset!') unless @cookieable_total_cookie
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Struct for caching database LiverampStatsS2sCookiePoolSize in S2SIdSyncRefresher / UpdateUsersInSync
      class AnaCookieStatUsersInSync
        include ::Thrift::Struct, ::Thrift::Struct_Union
        AD_NETWORK_ACCOUNT_ID = 1
        IS_BACKLOG = 2
        HEID = 3
        COOKIE_ID_WITH_DATA_KEY = 4
        COOKIEABLE_COOKIE_ID_WITH_DATA_KEY = 5
        COOKIES_FROM_IP_MATCHING = 6

        FIELDS = {
          AD_NETWORK_ACCOUNT_ID => {:type => ::Thrift::Types::I64, :name => 'ad_network_account_id'},
          IS_BACKLOG => {:type => ::Thrift::Types::BOOL, :name => 'is_backlog'},
          HEID => {:type => ::Thrift::Types::I64, :name => 'heid'},
          COOKIE_ID_WITH_DATA_KEY => {:type => ::Thrift::Types::I64, :name => 'cookie_id_with_data_key'},
          COOKIEABLE_COOKIE_ID_WITH_DATA_KEY => {:type => ::Thrift::Types::I64, :name => 'cookieable_cookie_id_with_data_key'},
          COOKIES_FROM_IP_MATCHING => {:type => ::Thrift::Types::I64, :name => 'cookies_from_ip_matching'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field ad_network_account_id is unset!') unless @ad_network_account_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field is_backlog is unset!') if @is_backlog.nil?
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field heid is unset!') unless @heid
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field cookie_id_with_data_key is unset!') unless @cookie_id_with_data_key
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field cookieable_cookie_id_with_data_key is unset!') unless @cookieable_cookie_id_with_data_key
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field cookies_from_ip_matching is unset!') unless @cookies_from_ip_matching
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Struct to store OnlineAudienceMember data in a form that can be mapside-joined with
# SyncFields.
# 
      class OnlineAudienceMemberData
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SYNCED_COOKIE = 1
        FIELDS_BY_AUDIENCE_ID = 2

        FIELDS = {
          SYNCED_COOKIE => {:type => ::Thrift::Types::STRUCT, :name => 'synced_cookie', :class => ::Liveramp::OnlineData::SyncedCookie},
          FIELDS_BY_AUDIENCE_ID => {:type => ::Thrift::Types::STRUCT, :name => 'fields_by_audience_id', :class => ::Rapleaf::Types::Spruce::AudienceFieldsByAudienceId}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field synced_cookie is unset!') unless @synced_cookie
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field fields_by_audience_id is unset!') unless @fields_by_audience_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Struct to count null puid external cookie syncs
# 
      class NullPuidExternalCookieSyncCounter
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PUBLISHER_ID = 1
        ANA_ID = 2
        COUNT = 3

        FIELDS = {
          PUBLISHER_ID => {:type => ::Thrift::Types::I32, :name => 'publisher_id'},
          ANA_ID => {:type => ::Thrift::Types::I32, :name => 'ana_id'},
          COUNT => {:type => ::Thrift::Types::I64, :name => 'count'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field publisher_id is unset!') unless @publisher_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field ana_id is unset!') unless @ana_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field count is unset!') unless @count
        end

        ::Thrift::Struct.generate_accessors self
      end

      class UserInSyncStatCount
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ANA_ID = 1
        IS_BACKLOG = 2
        STAT_TYPE = 3
        COUNT = 4

        FIELDS = {
          ANA_ID => {:type => ::Thrift::Types::I32, :name => 'ana_id'},
          IS_BACKLOG => {:type => ::Thrift::Types::BOOL, :name => 'is_backlog'},
          STAT_TYPE => {:type => ::Thrift::Types::STRING, :name => 'stat_type'},
          COUNT => {:type => ::Thrift::Types::I64, :name => 'count'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field ana_id is unset!') unless @ana_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field is_backlog is unset!') if @is_backlog.nil?
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field stat_type is unset!') unless @stat_type
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field count is unset!') unless @count
        end

        ::Thrift::Struct.generate_accessors self
      end

      class AnonymousIdentifierAndFields
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ANONYMOUS_IDENTIFIER = 1
        FIELDS_BY_AUDIENCE_ID = 2

        FIELDS = {
          ANONYMOUS_IDENTIFIER => {:type => ::Thrift::Types::STRUCT, :name => 'anonymous_identifier', :class => ::Liveramp::Types::Bang::AnonymousIdentifier},
          FIELDS_BY_AUDIENCE_ID => {:type => ::Thrift::Types::STRUCT, :name => 'fields_by_audience_id', :class => ::Rapleaf::Types::Spruce::AudienceFieldsByAudienceId}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field anonymous_identifier is unset!') unless @anonymous_identifier
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field fields_by_audience_id is unset!') unless @fields_by_audience_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      class MatchedAnonymousIdentifierAndFields
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ANONYMOUS_IDENTIFIER = 1
        AUDIENCE_ID = 2
        AUDIENCE_FIELDS = 3

        FIELDS = {
          ANONYMOUS_IDENTIFIER => {:type => ::Thrift::Types::STRUCT, :name => 'anonymous_identifier', :class => ::Liveramp::Types::Bang::AnonymousIdentifier, :optional => true},
          AUDIENCE_ID => {:type => ::Thrift::Types::I64, :name => 'audience_id'},
          AUDIENCE_FIELDS => {:type => ::Thrift::Types::STRUCT, :name => 'audience_fields', :class => ::Liveramp::Audience::AnonymousMemberFields}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field audience_id is unset!') unless @audience_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field audience_fields is unset!') unless @audience_fields
        end

        ::Thrift::Struct.generate_accessors self
      end

      class PotentialDataMatch
        include ::Thrift::Struct, ::Thrift::Struct_Union
        KEY = 1
        PATH = 2
        ESP = 3
        SERVER_SIDE_ACCOUNT_ID = 4
        METADATA_BY_IDENTIFIER = 5

        FIELDS = {
          # This is the identifier at the end of the path, to which data
# is matched for delivery.
# 
          KEY => {:type => ::Thrift::Types::STRUCT, :name => 'key', :class => ::Liveramp::Types::Bang::AnonymousIdentifier},
          PATH => {:type => ::Thrift::Types::LIST, :name => 'path', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::Bang::BangEdge}},
          ESP => {:type => ::Thrift::Types::STRUCT, :name => 'esp', :class => ::Rapleaf::Types::Spruce::EntitySegmentPack},
          SERVER_SIDE_ACCOUNT_ID => {:type => ::Thrift::Types::I64, :name => 'server_side_account_id'},
          METADATA_BY_IDENTIFIER => {:type => ::Thrift::Types::MAP, :name => 'metadata_by_identifier', :key => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::Bang::AnonymousIdentifier}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::Bang::AnonymousIdentifierMetadata}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field key is unset!') unless @key
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field path is unset!') unless @path
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field esp is unset!') unless @esp
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field server_side_account_id is unset!') unless @server_side_account_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      class BangRecordMatch
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SERVER_SIDE_ACCOUNT_ID = 1
        AUDIENCE_ID = 2
        ANONYMOUS_MEMBER_FIELDS = 3
        PATH = 4
        METADATA_BY_IDENTIFIER = 5

        FIELDS = {
          SERVER_SIDE_ACCOUNT_ID => {:type => ::Thrift::Types::I64, :name => 'server_side_account_id'},
          AUDIENCE_ID => {:type => ::Thrift::Types::I64, :name => 'audience_id'},
          ANONYMOUS_MEMBER_FIELDS => {:type => ::Thrift::Types::STRUCT, :name => 'anonymous_member_fields', :class => ::Liveramp::Audience::AnonymousMemberFields},
          PATH => {:type => ::Thrift::Types::LIST, :name => 'path', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::Bang::BangEdge}, :optional => true},
          METADATA_BY_IDENTIFIER => {:type => ::Thrift::Types::MAP, :name => 'metadata_by_identifier', :key => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::Bang::AnonymousIdentifier}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::Bang::AnonymousIdentifierMetadata}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field server_side_account_id is unset!') unless @server_side_account_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field audience_id is unset!') unless @audience_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field anonymous_member_fields is unset!') unless @anonymous_member_fields
        end

        ::Thrift::Struct.generate_accessors self
      end

      class BatchSampleOutputResponse < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def sample_output(val)
            BatchSampleOutputResponse.new(:sample_output, val)
          end

          def error(val)
            BatchSampleOutputResponse.new(:error, val)
          end
        end

        SAMPLE_OUTPUT = 1
        ERROR = 2

        FIELDS = {
          SAMPLE_OUTPUT => {:type => ::Thrift::Types::STRUCT, :name => 'sample_output', :class => ::Rapleaf::Types::S2SIntegrations::BatchSampleOutput, :optional => true},
          ERROR => {:type => ::Thrift::Types::STRING, :name => 'error', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      # Temporary struct used to compare UIS against edges
      class UserInSyncAndRelatedEdges
        include ::Thrift::Struct, ::Thrift::Struct_Union
        UIS = 1
        SYNC_EDGES = 2
        PUB_EDGES = 3

        FIELDS = {
          UIS => {:type => ::Thrift::Types::SET, :name => 'uis', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::S2SIntegrations::S2SUserInSync}},
          SYNC_EDGES => {:type => ::Thrift::Types::SET, :name => 'sync_edges', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::Bang::BangEdge}},
          PUB_EDGES => {:type => ::Thrift::Types::SET, :name => 'pub_edges', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::Bang::BangEdge}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field uis is unset!') unless @uis
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sync_edges is unset!') unless @sync_edges
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field pub_edges is unset!') unless @pub_edges
        end

        ::Thrift::Struct.generate_accessors self
      end

      class DeliveryDigest
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SSA_ID = 1
        ANONYMOUS_ID = 2
        DIGEST_VALUE = 3
        LAST_DELIVERED_AT = 4

        FIELDS = {
          SSA_ID => {:type => ::Thrift::Types::I64, :name => 'ssa_id'},
          ANONYMOUS_ID => {:type => ::Thrift::Types::STRUCT, :name => 'anonymous_id', :class => ::Liveramp::Types::Bang::AnonymousIdentifier},
          DIGEST_VALUE => {:type => ::Thrift::Types::I32, :name => 'digest_value'},
          LAST_DELIVERED_AT => {:type => ::Thrift::Types::I32, :name => 'last_delivered_at'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field ssa_id is unset!') unless @ssa_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field anonymous_id is unset!') unless @anonymous_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field digest_value is unset!') unless @digest_value
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field last_delivered_at is unset!') unless @last_delivered_at
        end

        ::Thrift::Struct.generate_accessors self
      end

      class BacklogRange
        include ::Thrift::Struct, ::Thrift::Struct_Union
        START_RANGE = 1
        END_RANGE = 2
        CUTOFF_TIMESTAMP = 3

        FIELDS = {
          START_RANGE => {:type => ::Thrift::Types::I32, :name => 'start_range'},
          END_RANGE => {:type => ::Thrift::Types::I32, :name => 'end_range'},
          # This was first made so that SOA Refresher can allow delivery of data as part of backlog that's already been delivered during the month.
# However, this feature was later developed to apply to all SSAs, not as an option.
# See usage of SoaRefresherConstants.ALLOW_REDELIVERY_IN_SAME_MONTH.
# The usage of this field has been swept in SOA Refresher, but it still exists in DDTS
# 
          CUTOFF_TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'cutoff_timestamp', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field start_range is unset!') unless @start_range
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field end_range is unset!') unless @end_range
        end

        ::Thrift::Struct.generate_accessors self
      end

    end
  end
end
