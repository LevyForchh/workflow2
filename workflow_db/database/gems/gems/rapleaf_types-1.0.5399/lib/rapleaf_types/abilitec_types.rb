#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'
require File.join File.dirname(__FILE__), 'new_person_data_types'
require File.join File.dirname(__FILE__), 'custom_id_types'
require File.join File.dirname(__FILE__), 'pii_integration_types'
require File.join File.dirname(__FILE__), 'doc_ids_types'


module Liveramp
  module Abilitec
    module PinType
      EMAIL = 2
      ENTITY_ID = 3
      ES_PIN = 4
      URL = 5
      MESSENGER_ID = 8
      SITE_OBJECT = 9
      HASHED_EMAIL = 10
      DATA_PARTNER_PIN = 11
      NAPKIN = 12
      GROUP = 14
      SPEL = 15
      ABILITEC = 16
      FAKE_PIN = 17
      PHONE_NUMBER = 18
      ERL = 19
      VALUE_MAP = {2 => "EMAIL", 3 => "ENTITY_ID", 4 => "ES_PIN", 5 => "URL", 8 => "MESSENGER_ID", 9 => "SITE_OBJECT", 10 => "HASHED_EMAIL", 11 => "DATA_PARTNER_PIN", 12 => "NAPKIN", 14 => "GROUP", 15 => "SPEL", 16 => "ABILITEC", 17 => "FAKE_PIN", 18 => "PHONE_NUMBER", 19 => "ERL"}
      VALID_VALUES = Set.new([EMAIL, ENTITY_ID, ES_PIN, URL, MESSENGER_ID, SITE_OBJECT, HASHED_EMAIL, DATA_PARTNER_PIN, NAPKIN, GROUP, SPEL, ABILITEC, FAKE_PIN, PHONE_NUMBER, ERL]).freeze
    end

    module AbilitecMigrationMode
      IGNORE = 0
      TEST = 1
      MIGRATED = 2
      VALUE_MAP = {0 => "IGNORE", 1 => "TEST", 2 => "MIGRATED"}
      VALID_VALUES = Set.new([IGNORE, TEST, MIGRATED]).freeze
    end

    class Zip; end

    class ClinkMapping; end

    class ErfMapping; end

    class AshId; end

    class Arl; end

    class ArlWithPinType; end

    class PersonId < ::Thrift::Union; end

    class ARLToPELMapping; end

    class HouseholdPel; end

    class NameAndCityPearl; end

    class PEL < ::Thrift::Union; end

    class Zip4Pearl; end

    class HeidToPel; end

    class ClinkToClink; end

    class Zip
      include ::Thrift::Struct, ::Thrift::Struct_Union
      ZIP5 = 1
      ZIP4 = 2

      FIELDS = {
        ZIP5 => {:type => ::Thrift::Types::STRING, :name => 'zip5'},
        ZIP4 => {:type => ::Thrift::Types::STRING, :name => 'zip4', :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field zip5 is unset!') unless @zip5
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ClinkMapping
      include ::Thrift::Struct, ::Thrift::Struct_Union
      INDIVIDUAL = 1
      HOUSEHOLD = 2
      ZIP = 3
      NAME_AND_CITY = 4

      FIELDS = {
        INDIVIDUAL => {:type => ::Thrift::Types::STRUCT, :name => 'individual', :class => ::Rapleaf::Types::NewPersonData::AbiliTecId},
        HOUSEHOLD => {:type => ::Thrift::Types::STRUCT, :name => 'household', :class => ::Rapleaf::Types::NewPersonData::AbiliTecId},
        ZIP => {:type => ::Thrift::Types::STRUCT, :name => 'zip', :class => ::Liveramp::Abilitec::Zip, :optional => true},
        NAME_AND_CITY => {:type => ::Thrift::Types::STRUCT, :name => 'name_and_city', :class => ::Rapleaf::Types::NewPersonData::NameAndCity, :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field individual is unset!') unless @individual
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field household is unset!') unless @household
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ErfMapping
      include ::Thrift::Struct, ::Thrift::Struct_Union
      INDIVIDUAL = 1
      HOUSEHOLD = 2
      ZIP = 3

      FIELDS = {
        INDIVIDUAL => {:type => ::Thrift::Types::STRUCT, :name => 'individual', :class => ::Rapleaf::Types::NewPersonData::AbiliTecId},
        HOUSEHOLD => {:type => ::Thrift::Types::STRUCT, :name => 'household', :class => ::Rapleaf::Types::NewPersonData::AbiliTecId, :optional => true},
        ZIP => {:type => ::Thrift::Types::STRUCT, :name => 'zip', :class => ::Liveramp::Abilitec::Zip, :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field individual is unset!') unless @individual
      end

      ::Thrift::Struct.generate_accessors self
    end

    class AshId
      include ::Thrift::Struct, ::Thrift::Struct_Union
      ASH_ID = 1

      FIELDS = {
        ASH_ID => {:type => ::Thrift::Types::STRING, :name => 'ash_id', :binary => true}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field ash_id is unset!') unless @ash_id
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Arl
      include ::Thrift::Struct, ::Thrift::Struct_Union
      ARL = 1

      FIELDS = {
        ARL => {:type => ::Thrift::Types::STRING, :name => 'arl', :binary => true}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field arl is unset!') unless @arl
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ArlWithPinType
      include ::Thrift::Struct, ::Thrift::Struct_Union
      ARL = 1
      PIN_TYPE = 2

      FIELDS = {
        ARL => {:type => ::Thrift::Types::STRUCT, :name => 'arl', :class => ::Liveramp::Abilitec::Arl},
        PIN_TYPE => {:type => ::Thrift::Types::I32, :name => 'pin_type', :enum_class => ::Liveramp::Abilitec::PinType}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field arl is unset!') unless @arl
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field pin_type is unset!') unless @pin_type
        unless @pin_type.nil? || ::Liveramp::Abilitec::PinType::VALID_VALUES.include?(@pin_type)
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field pin_type!')
        end
      end

      ::Thrift::Struct.generate_accessors self
    end

    class PersonId < ::Thrift::Union
      include ::Thrift::Struct_Union
      class << self
        def arlWithType(val)
          PersonId.new(:arlWithType, val)
        end

        def abilitec_id(val)
          PersonId.new(:abilitec_id, val)
        end

        def zip4(val)
          PersonId.new(:zip4, val)
        end

        def eh_pii(val)
          PersonId.new(:eh_pii, val)
        end

        def anon_doc(val)
          PersonId.new(:anon_doc, val)
        end

        def zip4_anon_doc(val)
          PersonId.new(:zip4_anon_doc, val)
        end
      end

      ARLWITHTYPE = 1
      ABILITEC_ID = 2
      ZIP4 = 3
      EH_PII = 4
      ANON_DOC = 5
      ZIP4_ANON_DOC = 6

      FIELDS = {
        ARLWITHTYPE => {:type => ::Thrift::Types::STRUCT, :name => 'arlWithType', :class => ::Liveramp::Abilitec::ArlWithPinType, :optional => true},
        ABILITEC_ID => {:type => ::Thrift::Types::STRUCT, :name => 'abilitec_id', :class => ::Rapleaf::Types::NewPersonData::AbiliTecId, :optional => true},
        ZIP4 => {:type => ::Thrift::Types::STRUCT, :name => 'zip4', :class => ::Rapleaf::Types::NewPersonData::GroupPIN, :optional => true},
        EH_PII => {:type => ::Thrift::Types::STRUCT, :name => 'eh_pii', :class => ::Liveramp::Types::PiiIntegration::EncryptedHashedPii, :optional => true},
        ANON_DOC => {:type => ::Thrift::Types::STRUCT, :name => 'anon_doc', :class => ::Liveramp::DocIds::AnonDoc, :optional => true},
        ZIP4_ANON_DOC => {:type => ::Thrift::Types::STRUCT, :name => 'zip4_anon_doc', :class => ::Liveramp::DocIds::Zip4AnonDoc, :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
        raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
      end

      ::Thrift::Union.generate_accessors self
    end

    class ARLToPELMapping
      include ::Thrift::Struct, ::Thrift::Struct_Union
      ARL = 1
      PEL = 2
      DERIVED = 3
      CREATION_TIMESTAMP = 4

      FIELDS = {
        ARL => {:type => ::Thrift::Types::STRUCT, :name => 'arl', :class => ::Liveramp::Abilitec::Arl},
        PEL => {:type => ::Thrift::Types::STRUCT, :name => 'pel', :class => ::Liveramp::Types::CustomId::CustomId},
        DERIVED => {:type => ::Thrift::Types::BOOL, :name => 'derived', :optional => true},
        CREATION_TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'creation_timestamp'}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field arl is unset!') unless @arl
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field pel is unset!') unless @pel
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field creation_timestamp is unset!') unless @creation_timestamp
      end

      ::Thrift::Struct.generate_accessors self
    end

    class HouseholdPel
      include ::Thrift::Struct, ::Thrift::Struct_Union
      HOUSEHOLD_PEL = 1

      FIELDS = {
        HOUSEHOLD_PEL => {:type => ::Thrift::Types::STRING, :name => 'household_pel'}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field household_pel is unset!') unless @household_pel
      end

      ::Thrift::Struct.generate_accessors self
    end

    class NameAndCityPearl
      include ::Thrift::Struct, ::Thrift::Struct_Union
      NAME_AND_CITY_PEARL = 1

      FIELDS = {
        NAME_AND_CITY_PEARL => {:type => ::Thrift::Types::STRING, :name => 'name_and_city_pearl'}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field name_and_city_pearl is unset!') unless @name_and_city_pearl
      end

      ::Thrift::Struct.generate_accessors self
    end

    # In most parts of our system PEL is represented as CustomId, and the specific type of
# PEL (maintained, derived, etc.) can be extracted from the PEL's prefix. This capability
# will not be available mid-long term, and in anticipation of that this type encodes the
# PEL's type explicitly.
# 
    class PEL < ::Thrift::Union
      include ::Thrift::Struct_Union
      class << self
        def maintained_individual_pel(val)
          PEL.new(:maintained_individual_pel, val)
        end

        def maintained_household_pel(val)
          PEL.new(:maintained_household_pel, val)
        end

        def derived_individual_pel(val)
          PEL.new(:derived_individual_pel, val)
        end

        def derived_zip4_pel(val)
          PEL.new(:derived_zip4_pel, val)
        end

        def derived_cookie_pel(val)
          PEL.new(:derived_cookie_pel, val)
        end

        def derived_mobile_pel(val)
          PEL.new(:derived_mobile_pel, val)
        end
      end

      MAINTAINED_INDIVIDUAL_PEL = 1
      MAINTAINED_HOUSEHOLD_PEL = 2
      DERIVED_INDIVIDUAL_PEL = 3
      DERIVED_ZIP4_PEL = 4
      DERIVED_COOKIE_PEL = 5
      DERIVED_MOBILE_PEL = 6

      FIELDS = {
        MAINTAINED_INDIVIDUAL_PEL => {:type => ::Thrift::Types::STRUCT, :name => 'maintained_individual_pel', :class => ::Liveramp::Types::CustomId::CustomId, :optional => true},
        # This replaces HouseholdPel above
        MAINTAINED_HOUSEHOLD_PEL => {:type => ::Thrift::Types::STRUCT, :name => 'maintained_household_pel', :class => ::Liveramp::Types::CustomId::CustomId, :optional => true},
        DERIVED_INDIVIDUAL_PEL => {:type => ::Thrift::Types::STRUCT, :name => 'derived_individual_pel', :class => ::Liveramp::Types::CustomId::CustomId, :optional => true},
        DERIVED_ZIP4_PEL => {:type => ::Thrift::Types::STRUCT, :name => 'derived_zip4_pel', :class => ::Liveramp::Types::CustomId::CustomId, :optional => true},
        DERIVED_COOKIE_PEL => {:type => ::Thrift::Types::STRUCT, :name => 'derived_cookie_pel', :class => ::Liveramp::Types::CustomId::CustomId, :optional => true},
        DERIVED_MOBILE_PEL => {:type => ::Thrift::Types::STRUCT, :name => 'derived_mobile_pel', :class => ::Liveramp::Types::CustomId::CustomId, :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
        raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
      end

      ::Thrift::Union.generate_accessors self
    end

    class Zip4Pearl
      include ::Thrift::Struct, ::Thrift::Struct_Union
      ZIP4_PEARL = 1

      FIELDS = {
        ZIP4_PEARL => {:type => ::Thrift::Types::STRING, :name => 'zip4_pearl'}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field zip4_pearl is unset!') unless @zip4_pearl
      end

      ::Thrift::Struct.generate_accessors self
    end

    class HeidToPel
      include ::Thrift::Struct, ::Thrift::Struct_Union
      HEID = 1
      PEL = 2

      FIELDS = {
        HEID => {:type => ::Thrift::Types::STRING, :name => 'heid', :binary => true},
        PEL => {:type => ::Thrift::Types::STRUCT, :name => 'pel', :class => ::Liveramp::Types::CustomId::CustomId}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field heid is unset!') unless @heid
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field pel is unset!') unless @pel
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ClinkToClink
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SOURCE = 1
      TARGET = 2

      FIELDS = {
        SOURCE => {:type => ::Thrift::Types::STRUCT, :name => 'source', :class => ::Rapleaf::Types::NewPersonData::AbiliTecId},
        TARGET => {:type => ::Thrift::Types::STRUCT, :name => 'target', :class => ::Rapleaf::Types::NewPersonData::AbiliTecId}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field source is unset!') unless @source
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field target is unset!') unless @target
      end

      ::Thrift::Struct.generate_accessors self
    end

  end
end
