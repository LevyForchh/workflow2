#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'
require File.join File.dirname(__FILE__), 'enums_types'
require File.join File.dirname(__FILE__), 'spruce_types'
require File.join File.dirname(__FILE__), 'mobile_types'


module Rapleaf
  module Types
    module IpMatching
      module IpmAccuracyRequirement
        DIFF_HEID = 1
        DIFF_HEID_UA = 2
        DIFF_COOKIE_AND_HEID_UA = 3
        DIFF_COOKIE = 4
        NO_REQ = 5
        VALUE_MAP = {1 => "DIFF_HEID", 2 => "DIFF_HEID_UA", 3 => "DIFF_COOKIE_AND_HEID_UA", 4 => "DIFF_COOKIE", 5 => "NO_REQ"}
        VALID_VALUES = Set.new([DIFF_HEID, DIFF_HEID_UA, DIFF_COOKIE_AND_HEID_UA, DIFF_COOKIE, NO_REQ]).freeze
      end

      module IpmAccuracyMeasure
        STATE = 1
        CITY = 2
        ZIP5 = 3
        ZIP_PLUS4 = 4
        STREET = 5
        LAST_NAME = 6
        HOUSEHOLD = 7
        LAST_NAME_OR_STREET = 8
        INDIVIDUAL = 9
        VALUE_MAP = {1 => "STATE", 2 => "CITY", 3 => "ZIP5", 4 => "ZIP_PLUS4", 5 => "STREET", 6 => "LAST_NAME", 7 => "HOUSEHOLD", 8 => "LAST_NAME_OR_STREET", 9 => "INDIVIDUAL"}
        VALID_VALUES = Set.new([STATE, CITY, ZIP5, ZIP_PLUS4, STREET, LAST_NAME, HOUSEHOLD, LAST_NAME_OR_STREET, INDIVIDUAL]).freeze
      end

      module IpmAccuracyMatchType
        ANY = 1
        CHOSEN = 2
        VALUE_MAP = {1 => "ANY", 2 => "CHOSEN"}
        VALID_VALUES = Set.new([ANY, CHOSEN]).freeze
      end

      module IpmReachType
        TOTAL = 1
        COOKIEABLE = 2
        VALUE_MAP = {1 => "TOTAL", 2 => "COOKIEABLE"}
        VALID_VALUES = Set.new([TOTAL, COOKIEABLE]).freeze
      end

      module DiffType
        GAIN = 1
        LOSS = 2
        CHANGE = 3
        VALUE_MAP = {1 => "GAIN", 2 => "LOSS", 3 => "CHANGE"}
        VALID_VALUES = Set.new([GAIN, LOSS, CHANGE]).freeze
      end

      module StatisticalGroupDeviceType
        COOKIE_TO_COOKIE = 1
        COOKIE_TO_MOBILE = 2
        MOBILE_TO_COOKIE = 3
        MOBILE_TO_MOBILE = 4
        VALUE_MAP = {1 => "COOKIE_TO_COOKIE", 2 => "COOKIE_TO_MOBILE", 3 => "MOBILE_TO_COOKIE", 4 => "MOBILE_TO_MOBILE"}
        VALID_VALUES = Set.new([COOKIE_TO_COOKIE, COOKIE_TO_MOBILE, MOBILE_TO_COOKIE, MOBILE_TO_MOBILE]).freeze
      end

      class HashedHousehold; end

      class MatchLabel; end

      class DeviceLabel; end

      class EntityHashedHouseholds; end

      class IPLocation; end

      class IPTimeInfo; end

      class IpmatchingLog; end

      class DevicePairConfidence; end

      class StatisticallyMatchedGroup; end

      class StatisticallyGroupedDevice; end

      class IpmAccuracyBreakdown; end

      class IpmReachCount; end

      class DeviceHeidMatch; end

      class DeviceHeidPair; end

      class DeviceHeidHashedHouseholds; end

      class IpmDeviceLabel; end

      class CrossDeviceTargetInfo; end

      class CrossDeviceMatch; end

      class DeviceDataPoint; end

      class CrossDeviceAccuracyPair; end

      class IPInfoList; end

      class IPInfo; end

      class HeidInfo; end

      class HeidList; end

      class IpmCounts; end

      class DeviceFeatures; end

      class IpFeatures; end

      class MobileFeatures; end

      class MobileImportIpFeatures; end

      class CountsAggregation; end

      class MultipleIpFeatures; end

      class IpmMatchingSummary; end

      class IpmDeviceMetadata; end

      class CrossDeviceGroupDiff; end

      class IpmMatchingSummaryOverview; end

      class CrossDeviceAccuracyPairWithPublisherInfo; end

      class StatisticallyMatchedGroupMetaData; end

      class DevicePair; end

      class DevicePairWithSameExternalIdCount; end

      class DevicePairWithMultipleIpFeatures; end

      class HashedHousehold
        include ::Thrift::Struct, ::Thrift::Struct_Union
        LASTNAME = 1
        STREET = 2
        ZIP4 = 3
        CITY = 4
        ZIP5 = 5
        STATE = 6
        HOUSEHOLD_HEID = 8
        OWNERS = 9

        FIELDS = {
          LASTNAME => {:type => ::Thrift::Types::STRING, :name => 'lastname', :binary => true, :optional => true},
          STREET => {:type => ::Thrift::Types::STRING, :name => 'street', :binary => true, :optional => true},
          ZIP4 => {:type => ::Thrift::Types::STRING, :name => 'zip4', :binary => true, :optional => true},
          CITY => {:type => ::Thrift::Types::STRING, :name => 'city', :optional => true},
          ZIP5 => {:type => ::Thrift::Types::STRING, :name => 'zip5', :optional => true},
          STATE => {:type => ::Thrift::Types::STRING, :name => 'state', :optional => true},
          HOUSEHOLD_HEID => {:type => ::Thrift::Types::STRING, :name => 'household_heid', :binary => true, :optional => true},
          OWNERS => {:type => ::Thrift::Types::SET, :name => 'owners', :element => {:type => ::Thrift::Types::I32, :enum_class => ::Rapleaf::Types::PersonData::DataPartner}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class MatchLabel
        include ::Thrift::Struct, ::Thrift::Struct_Union
        HEID = 1
        SELECTED_DATA = 2
        DATA_CHOICES = 3
        SOURCE_COOKIE = 4

        FIELDS = {
          HEID => {:type => ::Thrift::Types::STRING, :name => 'heid', :binary => true},
          SELECTED_DATA => {:type => ::Thrift::Types::STRUCT, :name => 'selected_data', :class => ::Rapleaf::Types::IpMatching::HashedHousehold},
          DATA_CHOICES => {:type => ::Thrift::Types::SET, :name => 'data_choices', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::IpMatching::HashedHousehold}},
          SOURCE_COOKIE => {:type => ::Thrift::Types::STRUCT, :name => 'source_cookie', :class => ::Rapleaf::Types::Spruce::DeviceId}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field heid is unset!') unless @heid
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field selected_data is unset!') unless @selected_data
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field data_choices is unset!') unless @data_choices
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field source_cookie is unset!') unless @source_cookie
        end

        ::Thrift::Struct.generate_accessors self
      end

      class DeviceLabel
        include ::Thrift::Struct, ::Thrift::Struct_Union
        LABEL = 1
        DEVICE_ID = 2
        USER_AGENT = 3

        FIELDS = {
          LABEL => {:type => ::Thrift::Types::STRUCT, :name => 'label', :class => ::Rapleaf::Types::IpMatching::MatchLabel},
          DEVICE_ID => {:type => ::Thrift::Types::STRUCT, :name => 'device_id', :class => ::Rapleaf::Types::Spruce::DeviceId},
          USER_AGENT => {:type => ::Thrift::Types::STRING, :name => 'user_agent', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field label is unset!') unless @label
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field device_id is unset!') unless @device_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      class EntityHashedHouseholds
        include ::Thrift::Struct, ::Thrift::Struct_Union
        HEID = 2
        DERIVED_DATA = 3

        FIELDS = {
          HEID => {:type => ::Thrift::Types::STRING, :name => 'heid', :binary => true},
          DERIVED_DATA => {:type => ::Thrift::Types::SET, :name => 'derived_data', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::IpMatching::HashedHousehold}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field heid is unset!') unless @heid
        end

        ::Thrift::Struct.generate_accessors self
      end

      class IPLocation
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COUNTRY_CODE = 1
        COUNTRY_NAME = 2
        REGION = 3
        CITY = 4
        POSTAL_CODE = 5
        LATITUDE = 6
        LONGITUDE = 7
        DMA_CODE = 8
        AREA_CODE = 9
        METRO_CODE = 10

        FIELDS = {
          COUNTRY_CODE => {:type => ::Thrift::Types::STRING, :name => 'country_code', :optional => true},
          COUNTRY_NAME => {:type => ::Thrift::Types::STRING, :name => 'country_name', :optional => true},
          REGION => {:type => ::Thrift::Types::STRING, :name => 'region', :optional => true},
          CITY => {:type => ::Thrift::Types::STRING, :name => 'city', :optional => true},
          POSTAL_CODE => {:type => ::Thrift::Types::STRING, :name => 'postal_code', :optional => true},
          LATITUDE => {:type => ::Thrift::Types::DOUBLE, :name => 'latitude', :optional => true},
          LONGITUDE => {:type => ::Thrift::Types::DOUBLE, :name => 'longitude', :optional => true},
          DMA_CODE => {:type => ::Thrift::Types::I32, :name => 'dma_code', :optional => true},
          AREA_CODE => {:type => ::Thrift::Types::I32, :name => 'area_code', :optional => true},
          METRO_CODE => {:type => ::Thrift::Types::I32, :name => 'metro_code', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class IPTimeInfo
        include ::Thrift::Struct, ::Thrift::Struct_Union
        GMT_OFFSET = 1
        DAYLIGHT_SAVINGS = 2

        FIELDS = {
          GMT_OFFSET => {:type => ::Thrift::Types::I32, :name => 'gmt_offset', :optional => true},
          DAYLIGHT_SAVINGS => {:type => ::Thrift::Types::BOOL, :name => 'daylight_savings', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class IpmatchingLog
        include ::Thrift::Struct, ::Thrift::Struct_Union
        REMOTE_ADDR = 1
        DEVICE_ID = 2
        TIMESTAMP = 4
        USER_AGENT = 5
        ENTITY_DATA = 8
        LOCATION = 9
        TIMEZONE = 10
        ISP_NAME = 11
        COOKIEABLE = 12
        PUBLISHER = 13

        FIELDS = {
          REMOTE_ADDR => {:type => ::Thrift::Types::STRING, :name => 'remote_addr', :optional => true},
          DEVICE_ID => {:type => ::Thrift::Types::STRUCT, :name => 'device_id', :class => ::Rapleaf::Types::Spruce::DeviceId, :optional => true},
          TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'timestamp', :optional => true},
          USER_AGENT => {:type => ::Thrift::Types::STRING, :name => 'user_agent', :optional => true},
          ENTITY_DATA => {:type => ::Thrift::Types::STRUCT, :name => 'entity_data', :class => ::Rapleaf::Types::IpMatching::EntityHashedHouseholds, :optional => true},
          LOCATION => {:type => ::Thrift::Types::STRUCT, :name => 'location', :class => ::Rapleaf::Types::IpMatching::IPLocation, :optional => true},
          TIMEZONE => {:type => ::Thrift::Types::STRUCT, :name => 'timezone', :class => ::Rapleaf::Types::IpMatching::IPTimeInfo, :optional => true},
          ISP_NAME => {:type => ::Thrift::Types::STRING, :name => 'isp_name', :optional => true},
          COOKIEABLE => {:type => ::Thrift::Types::BOOL, :name => 'cookieable', :optional => true},
          PUBLISHER => {:type => ::Thrift::Types::I32, :name => 'publisher', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class DevicePairConfidence
        include ::Thrift::Struct, ::Thrift::Struct_Union
        DEVICE_A = 1
        DEVICE_B = 2
        CONFIDENCE = 3

        FIELDS = {
          DEVICE_A => {:type => ::Thrift::Types::STRUCT, :name => 'device_a', :class => ::Rapleaf::Types::Spruce::DeviceId},
          DEVICE_B => {:type => ::Thrift::Types::STRUCT, :name => 'device_b', :class => ::Rapleaf::Types::Spruce::DeviceId},
          CONFIDENCE => {:type => ::Thrift::Types::DOUBLE, :name => 'confidence'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field device_a is unset!') unless @device_a
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field device_b is unset!') unless @device_b
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field confidence is unset!') unless @confidence
        end

        ::Thrift::Struct.generate_accessors self
      end

      class StatisticallyMatchedGroup
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COOKIES_TO_USER_AGENTS = 2
        ALGORITHM_METADATA = 3
        GROUP = 4
        LABEL = 5
        PAIR_CONFIDENCES = 6

        FIELDS = {
          COOKIES_TO_USER_AGENTS => {:type => ::Thrift::Types::MAP, :name => 'cookies_to_user_agents', :key => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::Spruce::DeviceId}, :value => {:type => ::Thrift::Types::STRING}},
          ALGORITHM_METADATA => {:type => ::Thrift::Types::STRING, :name => 'algorithm_metadata', :optional => true},
          GROUP => {:type => ::Thrift::Types::STRING, :name => 'group'},
          LABEL => {:type => ::Thrift::Types::STRUCT, :name => 'label', :class => ::Rapleaf::Types::IpMatching::MatchLabel, :optional => true},
          PAIR_CONFIDENCES => {:type => ::Thrift::Types::LIST, :name => 'pair_confidences', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::IpMatching::DevicePairConfidence}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field cookies_to_user_agents is unset!') unless @cookies_to_user_agents
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field group is unset!') unless @group
        end

        ::Thrift::Struct.generate_accessors self
      end

      class StatisticallyGroupedDevice
        include ::Thrift::Struct, ::Thrift::Struct_Union
        DEVICE_ID = 1
        MATCHED_GROUP = 2
        HEID_SEEN = 3
        POSTAL_SEEN = 4

        FIELDS = {
          DEVICE_ID => {:type => ::Thrift::Types::STRUCT, :name => 'device_id', :class => ::Rapleaf::Types::Spruce::DeviceId},
          MATCHED_GROUP => {:type => ::Thrift::Types::STRUCT, :name => 'matched_group', :class => ::Rapleaf::Types::IpMatching::StatisticallyMatchedGroup},
          HEID_SEEN => {:type => ::Thrift::Types::BOOL, :name => 'heid_seen'},
          POSTAL_SEEN => {:type => ::Thrift::Types::BOOL, :name => 'postal_seen'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field device_id is unset!') unless @device_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field matched_group is unset!') unless @matched_group
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field heid_seen is unset!') if @heid_seen.nil?
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field postal_seen is unset!') if @postal_seen.nil?
        end

        ::Thrift::Struct.generate_accessors self
      end

      class IpmAccuracyBreakdown
        include ::Thrift::Struct, ::Thrift::Struct_Union
        REQUIREMENT = 1
        MEASURE = 2
        MATCH_TYPE = 3
        CORRECT = 4
        INCORRECT = 5

        FIELDS = {
          REQUIREMENT => {:type => ::Thrift::Types::I32, :name => 'requirement', :enum_class => ::Rapleaf::Types::IpMatching::IpmAccuracyRequirement},
          MEASURE => {:type => ::Thrift::Types::I32, :name => 'measure', :enum_class => ::Rapleaf::Types::IpMatching::IpmAccuracyMeasure},
          MATCH_TYPE => {:type => ::Thrift::Types::I32, :name => 'match_type', :enum_class => ::Rapleaf::Types::IpMatching::IpmAccuracyMatchType},
          CORRECT => {:type => ::Thrift::Types::I64, :name => 'correct', :optional => true},
          INCORRECT => {:type => ::Thrift::Types::I64, :name => 'incorrect', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field requirement is unset!') unless @requirement
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field measure is unset!') unless @measure
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field match_type is unset!') unless @match_type
          unless @requirement.nil? || ::Rapleaf::Types::IpMatching::IpmAccuracyRequirement::VALID_VALUES.include?(@requirement)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field requirement!')
          end
          unless @measure.nil? || ::Rapleaf::Types::IpMatching::IpmAccuracyMeasure::VALID_VALUES.include?(@measure)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field measure!')
          end
          unless @match_type.nil? || ::Rapleaf::Types::IpMatching::IpmAccuracyMatchType::VALID_VALUES.include?(@match_type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field match_type!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class IpmReachCount
        include ::Thrift::Struct, ::Thrift::Struct_Union
        NAME = 1
        COUNT = 2

        FIELDS = {
          NAME => {:type => ::Thrift::Types::I32, :name => 'name', :enum_class => ::Rapleaf::Types::IpMatching::IpmReachType},
          COUNT => {:type => ::Thrift::Types::I64, :name => 'count'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field name is unset!') unless @name
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field count is unset!') unless @count
          unless @name.nil? || ::Rapleaf::Types::IpMatching::IpmReachType::VALID_VALUES.include?(@name)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field name!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class DeviceHeidMatch
        include ::Thrift::Struct, ::Thrift::Struct_Union
        DEVICE_ID = 1
        HEID = 2
        COOKIE_LAST_SEEN_TIMESTAMP = 3
        CONFIDENCE = 4

        FIELDS = {
          DEVICE_ID => {:type => ::Thrift::Types::STRUCT, :name => 'device_id', :class => ::Rapleaf::Types::Spruce::DeviceId},
          HEID => {:type => ::Thrift::Types::STRING, :name => 'heid', :binary => true},
          COOKIE_LAST_SEEN_TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'cookie_last_seen_timestamp'},
          CONFIDENCE => {:type => ::Thrift::Types::DOUBLE, :name => 'confidence', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field device_id is unset!') unless @device_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field heid is unset!') unless @heid
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field cookie_last_seen_timestamp is unset!') unless @cookie_last_seen_timestamp
        end

        ::Thrift::Struct.generate_accessors self
      end

      class DeviceHeidPair
        include ::Thrift::Struct, ::Thrift::Struct_Union
        DEVICE_ID = 1
        HEID = 2
        TIMESTAMP = 3

        FIELDS = {
          DEVICE_ID => {:type => ::Thrift::Types::STRUCT, :name => 'device_id', :class => ::Rapleaf::Types::Spruce::DeviceId},
          HEID => {:type => ::Thrift::Types::STRING, :name => 'heid', :binary => true},
          TIMESTAMP => {:type => ::Thrift::Types::I32, :name => 'timestamp', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field device_id is unset!') unless @device_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field heid is unset!') unless @heid
        end

        ::Thrift::Struct.generate_accessors self
      end

      class DeviceHeidHashedHouseholds
        include ::Thrift::Struct, ::Thrift::Struct_Union
        DEVICE_ID = 1
        HEID = 2
        DERIVED_DATA = 3

        FIELDS = {
          DEVICE_ID => {:type => ::Thrift::Types::STRUCT, :name => 'device_id', :class => ::Rapleaf::Types::Spruce::DeviceId},
          HEID => {:type => ::Thrift::Types::STRING, :name => 'heid', :binary => true},
          DERIVED_DATA => {:type => ::Thrift::Types::SET, :name => 'derived_data', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::IpMatching::HashedHousehold}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field device_id is unset!') unless @device_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field heid is unset!') unless @heid
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field derived_data is unset!') unless @derived_data
        end

        ::Thrift::Struct.generate_accessors self
      end

      class IpmDeviceLabel
        include ::Thrift::Struct, ::Thrift::Struct_Union
        HEID = 1
        DERIVED_DATA = 2

        FIELDS = {
          HEID => {:type => ::Thrift::Types::STRING, :name => 'heid', :binary => true},
          DERIVED_DATA => {:type => ::Thrift::Types::SET, :name => 'derived_data', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::IpMatching::HashedHousehold}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field heid is unset!') unless @heid
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field derived_data is unset!') unless @derived_data
        end

        ::Thrift::Struct.generate_accessors self
      end

      class CrossDeviceTargetInfo
        include ::Thrift::Struct, ::Thrift::Struct_Union
        USER_AGENT = 1
        MATCH_CREATION_TIMESTAMP = 2
        CONFIDENCE = 3
        LABEL = 4

        FIELDS = {
          USER_AGENT => {:type => ::Thrift::Types::STRING, :name => 'user_agent'},
          MATCH_CREATION_TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'match_creation_timestamp'},
          CONFIDENCE => {:type => ::Thrift::Types::DOUBLE, :name => 'confidence', :default => 1, :optional => true},
          LABEL => {:type => ::Thrift::Types::STRUCT, :name => 'label', :class => ::Rapleaf::Types::IpMatching::IpmDeviceLabel, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field user_agent is unset!') unless @user_agent
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field match_creation_timestamp is unset!') unless @match_creation_timestamp
        end

        ::Thrift::Struct.generate_accessors self
      end

      class CrossDeviceMatch
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SOURCE_DEVICE_ID = 1
        SOURCE_USER_AGENT = 2
        MATCHED_COOKIES_TO_USER_AGENTS = 3
        GROUP = 4
        TARGETS = 5
        LABEL = 6

        FIELDS = {
          SOURCE_DEVICE_ID => {:type => ::Thrift::Types::STRUCT, :name => 'source_device_id', :class => ::Rapleaf::Types::Spruce::DeviceId},
          SOURCE_USER_AGENT => {:type => ::Thrift::Types::STRING, :name => 'source_user_agent'},
          MATCHED_COOKIES_TO_USER_AGENTS => {:type => ::Thrift::Types::MAP, :name => 'matched_cookies_to_user_agents', :key => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::Spruce::DeviceId}, :value => {:type => ::Thrift::Types::STRING}, :optional => true},
          GROUP => {:type => ::Thrift::Types::STRING, :name => 'group', :optional => true},
          TARGETS => {:type => ::Thrift::Types::MAP, :name => 'targets', :key => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::Spruce::DeviceId}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::IpMatching::CrossDeviceTargetInfo}, :optional => true},
          LABEL => {:type => ::Thrift::Types::STRUCT, :name => 'label', :class => ::Rapleaf::Types::IpMatching::IpmDeviceLabel, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field source_device_id is unset!') unless @source_device_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field source_user_agent is unset!') unless @source_user_agent
        end

        ::Thrift::Struct.generate_accessors self
      end

      class DeviceDataPoint
        include ::Thrift::Struct, ::Thrift::Struct_Union
        DEVICE_ID = 1
        USER_AGENT = 2
        HEID = 3
        DERIVED_DATA = 4

        FIELDS = {
          DEVICE_ID => {:type => ::Thrift::Types::STRUCT, :name => 'device_id', :class => ::Rapleaf::Types::Spruce::DeviceId},
          USER_AGENT => {:type => ::Thrift::Types::STRING, :name => 'user_agent'},
          HEID => {:type => ::Thrift::Types::STRING, :name => 'heid', :binary => true, :optional => true},
          DERIVED_DATA => {:type => ::Thrift::Types::SET, :name => 'derived_data', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::IpMatching::HashedHousehold}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field device_id is unset!') unless @device_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field user_agent is unset!') unless @user_agent
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Struct used to evaluate the accuracy of cross-device (cookie-to-cookie) matches.
      class CrossDeviceAccuracyPair
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COOKIE_DATA_POINT = 1
        MATCHED_COOKIE_DATA_POINT = 2
        SOURCE_NAME = 3
        CONFIDENCE = 4

        FIELDS = {
          COOKIE_DATA_POINT => {:type => ::Thrift::Types::STRUCT, :name => 'cookie_data_point', :class => ::Rapleaf::Types::IpMatching::DeviceDataPoint},
          MATCHED_COOKIE_DATA_POINT => {:type => ::Thrift::Types::STRUCT, :name => 'matched_cookie_data_point', :class => ::Rapleaf::Types::IpMatching::DeviceDataPoint},
          SOURCE_NAME => {:type => ::Thrift::Types::STRING, :name => 'source_name', :optional => true},
          CONFIDENCE => {:type => ::Thrift::Types::DOUBLE, :name => 'confidence', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field cookie_data_point is unset!') unless @cookie_data_point
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field matched_cookie_data_point is unset!') unless @matched_cookie_data_point
        end

        ::Thrift::Struct.generate_accessors self
      end

      class IPInfoList
        include ::Thrift::Struct, ::Thrift::Struct_Union
        DEVICE_IDS = 1
        IP_INFO = 2

        FIELDS = {
          DEVICE_IDS => {:type => ::Thrift::Types::LIST, :name => 'device_ids', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::Spruce::DeviceId}, :optional => true},
          IP_INFO => {:type => ::Thrift::Types::STRUCT, :name => 'ip_info', :class => ::Rapleaf::Types::IpMatching::IPLocation, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class IPInfo
        include ::Thrift::Struct, ::Thrift::Struct_Union
        LOCATION_INFO = 1
        ISP = 2
        ORGANIZATION = 3

        FIELDS = {
          LOCATION_INFO => {:type => ::Thrift::Types::STRUCT, :name => 'location_info', :class => ::Rapleaf::Types::IpMatching::IPLocation, :optional => true},
          ISP => {:type => ::Thrift::Types::STRING, :name => 'isp', :optional => true},
          ORGANIZATION => {:type => ::Thrift::Types::STRING, :name => 'organization', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class HeidInfo
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ENTITY_DATA = 1
        DEVICE_IDS = 2

        FIELDS = {
          ENTITY_DATA => {:type => ::Thrift::Types::STRUCT, :name => 'entity_data', :class => ::Rapleaf::Types::IpMatching::EntityHashedHouseholds, :optional => true},
          DEVICE_IDS => {:type => ::Thrift::Types::LIST, :name => 'device_ids', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::Spruce::DeviceId}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class HeidList
        include ::Thrift::Struct, ::Thrift::Struct_Union
        HEIDS = 1

        FIELDS = {
          HEIDS => {:type => ::Thrift::Types::LIST, :name => 'heids', :element => {:type => ::Thrift::Types::STRING, :binary => true}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field heids is unset!') unless @heids
        end

        ::Thrift::Struct.generate_accessors self
      end

      class IpmCounts
        include ::Thrift::Struct, ::Thrift::Struct_Union
        LOGS_COUNT = 1
        DISTINCT_DAYS_COUNT = 2

        FIELDS = {
          LOGS_COUNT => {:type => ::Thrift::Types::I32, :name => 'logs_count'},
          DISTINCT_DAYS_COUNT => {:type => ::Thrift::Types::I32, :name => 'distinct_days_count'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field logs_count is unset!') unless @logs_count
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field distinct_days_count is unset!') unless @distinct_days_count
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Used in statistical classifier for IPMatching
      class DeviceFeatures
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ENTITY_DATA = 1
        USER_AGENT = 2
        N_LOGS = 3
        N_DAYS = 4
        COOKIEABLE = 5
        MOST_FREQUENT_PUBLISHER = 6
        RELATIVE_OBSERVATIONS = 7
        PUBLISHER_COUNTS = 8

        FIELDS = {
          ENTITY_DATA => {:type => ::Thrift::Types::STRUCT, :name => 'entity_data', :class => ::Rapleaf::Types::IpMatching::EntityHashedHouseholds, :optional => true},
          USER_AGENT => {:type => ::Thrift::Types::STRING, :name => 'user_agent', :optional => true},
          N_LOGS => {:type => ::Thrift::Types::I32, :name => 'n_logs'},
          N_DAYS => {:type => ::Thrift::Types::I16, :name => 'n_days'},
          COOKIEABLE => {:type => ::Thrift::Types::BOOL, :name => 'cookieable'},
          MOST_FREQUENT_PUBLISHER => {:type => ::Thrift::Types::I32, :name => 'most_frequent_publisher'},
          RELATIVE_OBSERVATIONS => {:type => ::Thrift::Types::LIST, :name => 'relative_observations', :element => {:type => ::Thrift::Types::I16}},
          PUBLISHER_COUNTS => {:type => ::Thrift::Types::MAP, :name => 'publisher_counts', :key => {:type => ::Thrift::Types::I32}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::IpMatching::IpmCounts}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field n_logs is unset!') unless @n_logs
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field n_days is unset!') unless @n_days
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field cookieable is unset!') if @cookieable.nil?
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field most_frequent_publisher is unset!') unless @most_frequent_publisher
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field relative_observations is unset!') unless @relative_observations
        end

        ::Thrift::Struct.generate_accessors self
      end

      class IpFeatures
        include ::Thrift::Struct, ::Thrift::Struct_Union
        IP = 1
        ISP = 2
        N_LOGS = 3
        TIMESTAMP_OFFSSET = 4
        DEVICE_FEATURES = 5
        LOCATION = 6

        FIELDS = {
          IP => {:type => ::Thrift::Types::STRING, :name => 'ip'},
          ISP => {:type => ::Thrift::Types::STRING, :name => 'isp', :optional => true},
          N_LOGS => {:type => ::Thrift::Types::I32, :name => 'n_logs'},
          TIMESTAMP_OFFSSET => {:type => ::Thrift::Types::I32, :name => 'timestamp_offsset'},
          DEVICE_FEATURES => {:type => ::Thrift::Types::MAP, :name => 'device_features', :key => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::Spruce::DeviceId}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::IpMatching::DeviceFeatures}},
          LOCATION => {:type => ::Thrift::Types::STRUCT, :name => 'location', :class => ::Rapleaf::Types::IpMatching::IPLocation, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field ip is unset!') unless @ip
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field n_logs is unset!') unless @n_logs
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field timestamp_offsset is unset!') unless @timestamp_offsset
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field device_features is unset!') unless @device_features
        end

        ::Thrift::Struct.generate_accessors self
      end

      class MobileFeatures
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ENTITY_DATA = 1
        N_LOGS = 2
        N_DAYS = 3
        RELATIVE_OBSERVATIONS = 4
        PUBLISHERS = 5

        FIELDS = {
          ENTITY_DATA => {:type => ::Thrift::Types::STRUCT, :name => 'entity_data', :class => ::Rapleaf::Types::IpMatching::EntityHashedHouseholds, :optional => true},
          N_LOGS => {:type => ::Thrift::Types::I32, :name => 'n_logs'},
          N_DAYS => {:type => ::Thrift::Types::I16, :name => 'n_days'},
          RELATIVE_OBSERVATIONS => {:type => ::Thrift::Types::LIST, :name => 'relative_observations', :element => {:type => ::Thrift::Types::I16}},
          PUBLISHERS => {:type => ::Thrift::Types::SET, :name => 'publishers', :element => {:type => ::Thrift::Types::I32}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field n_logs is unset!') unless @n_logs
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field n_days is unset!') unless @n_days
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field relative_observations is unset!') unless @relative_observations
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field publishers is unset!') unless @publishers
        end

        ::Thrift::Struct.generate_accessors self
      end

      class MobileImportIpFeatures
        include ::Thrift::Struct, ::Thrift::Struct_Union
        IP = 1
        ISP = 2
        N_LOGS = 3
        TIMESTAMP_OFFSSET = 4
        MOBILE_FEATURES = 5
        LOCATION = 6

        FIELDS = {
          IP => {:type => ::Thrift::Types::STRING, :name => 'ip'},
          ISP => {:type => ::Thrift::Types::STRING, :name => 'isp', :optional => true},
          N_LOGS => {:type => ::Thrift::Types::I32, :name => 'n_logs'},
          TIMESTAMP_OFFSSET => {:type => ::Thrift::Types::I32, :name => 'timestamp_offsset'},
          MOBILE_FEATURES => {:type => ::Thrift::Types::MAP, :name => 'mobile_features', :key => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::Mobile::MUID}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::IpMatching::MobileFeatures}},
          LOCATION => {:type => ::Thrift::Types::STRUCT, :name => 'location', :class => ::Rapleaf::Types::IpMatching::IPLocation, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field ip is unset!') unless @ip
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field n_logs is unset!') unless @n_logs
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field timestamp_offsset is unset!') unless @timestamp_offsset
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field mobile_features is unset!') unless @mobile_features
        end

        ::Thrift::Struct.generate_accessors self
      end

      class CountsAggregation
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SUM_COUNTS = 1
        MIN_COUNTS = 2
        MAX_COUNTS = 3

        FIELDS = {
          SUM_COUNTS => {:type => ::Thrift::Types::I32, :name => 'sum_counts'},
          MIN_COUNTS => {:type => ::Thrift::Types::I32, :name => 'min_counts'},
          MAX_COUNTS => {:type => ::Thrift::Types::I32, :name => 'max_counts'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sum_counts is unset!') unless @sum_counts
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field min_counts is unset!') unless @min_counts
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field max_counts is unset!') unless @max_counts
        end

        ::Thrift::Struct.generate_accessors self
      end

      class MultipleIpFeatures
        include ::Thrift::Struct, ::Thrift::Struct_Union
        IP_FEATURES = 1
        N_LOGS = 2
        N_DEVICES = 3
        N_COOKIEABLE_DEVICES = 4

        FIELDS = {
          IP_FEATURES => {:type => ::Thrift::Types::SET, :name => 'ip_features', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::IpMatching::IpFeatures}},
          N_LOGS => {:type => ::Thrift::Types::STRUCT, :name => 'n_logs', :class => ::Rapleaf::Types::IpMatching::CountsAggregation},
          N_DEVICES => {:type => ::Thrift::Types::STRUCT, :name => 'n_devices', :class => ::Rapleaf::Types::IpMatching::CountsAggregation},
          N_COOKIEABLE_DEVICES => {:type => ::Thrift::Types::STRUCT, :name => 'n_cookieable_devices', :class => ::Rapleaf::Types::IpMatching::CountsAggregation}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field ip_features is unset!') unless @ip_features
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field n_logs is unset!') unless @n_logs
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field n_devices is unset!') unless @n_devices
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field n_cookieable_devices is unset!') unless @n_cookieable_devices
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Used to visualize/inspect the matching performed for an IP address
      class IpmMatchingSummary
        include ::Thrift::Struct, ::Thrift::Struct_Union
        IP_FEATURES = 1
        ORDERED_DEVICE_IDS = 2
        COMPRESSED_SCALED_PAIR_CONFIDENCES = 3
        HEID_MATCHES_BY_FILTER = 4
        XDEVICE_GROUPS_BY_GROUPER = 5

        FIELDS = {
          IP_FEATURES => {:type => ::Thrift::Types::STRUCT, :name => 'ip_features', :class => ::Rapleaf::Types::IpMatching::IpFeatures},
          ORDERED_DEVICE_IDS => {:type => ::Thrift::Types::LIST, :name => 'ordered_device_ids', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::Spruce::DeviceId}},
          COMPRESSED_SCALED_PAIR_CONFIDENCES => {:type => ::Thrift::Types::LIST, :name => 'compressed_scaled_pair_confidences', :element => {:type => ::Thrift::Types::I16}},
          HEID_MATCHES_BY_FILTER => {:type => ::Thrift::Types::MAP, :name => 'heid_matches_by_filter', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::MAP, :key => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::Spruce::DeviceId}, :value => {:type => ::Thrift::Types::STRING, :binary => true}}},
          XDEVICE_GROUPS_BY_GROUPER => {:type => ::Thrift::Types::MAP, :name => 'xdevice_groups_by_grouper', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::SET, :element => {:type => ::Thrift::Types::SET, :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::Spruce::DeviceId}}}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field ip_features is unset!') unless @ip_features
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field ordered_device_ids is unset!') unless @ordered_device_ids
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field compressed_scaled_pair_confidences is unset!') unless @compressed_scaled_pair_confidences
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field heid_matches_by_filter is unset!') unless @heid_matches_by_filter
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field xdevice_groups_by_grouper is unset!') unless @xdevice_groups_by_grouper
        end

        ::Thrift::Struct.generate_accessors self
      end

      class IpmDeviceMetadata
        include ::Thrift::Struct, ::Thrift::Struct_Union
        DEVICE_ID = 1
        LAST_SEEN_TIMESTAMP = 2
        USER_AGENT = 3
        LABEL = 4
        COOKIEABLE = 5
        LOGS_COUNT = 6
        DISTINCT_DAYS_COUNT = 7
        PUBLISHER_COUNTS = 8
        OBSERVED_ON_US_IP = 9
        IP_COUNTS = 10
        REFERRER_COUNTS = 11
        GIF_N_PARAMETER_COUNTS = 12

        FIELDS = {
          DEVICE_ID => {:type => ::Thrift::Types::STRUCT, :name => 'device_id', :class => ::Rapleaf::Types::Spruce::DeviceId},
          LAST_SEEN_TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'last_seen_timestamp'},
          USER_AGENT => {:type => ::Thrift::Types::STRING, :name => 'user_agent', :optional => true},
          LABEL => {:type => ::Thrift::Types::STRUCT, :name => 'label', :class => ::Rapleaf::Types::IpMatching::IpmDeviceLabel, :optional => true},
          COOKIEABLE => {:type => ::Thrift::Types::BOOL, :name => 'cookieable'},
          LOGS_COUNT => {:type => ::Thrift::Types::I32, :name => 'logs_count', :optional => true},
          DISTINCT_DAYS_COUNT => {:type => ::Thrift::Types::I32, :name => 'distinct_days_count', :optional => true},
          PUBLISHER_COUNTS => {:type => ::Thrift::Types::MAP, :name => 'publisher_counts', :key => {:type => ::Thrift::Types::I32}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::IpMatching::IpmCounts}, :optional => true},
          OBSERVED_ON_US_IP => {:type => ::Thrift::Types::BOOL, :name => 'observed_on_US_ip', :optional => true},
          IP_COUNTS => {:type => ::Thrift::Types::MAP, :name => 'ip_counts', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::IpMatching::IpmCounts}, :optional => true},
          REFERRER_COUNTS => {:type => ::Thrift::Types::MAP, :name => 'referrer_counts', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::IpMatching::IpmCounts}, :optional => true},
          GIF_N_PARAMETER_COUNTS => {:type => ::Thrift::Types::MAP, :name => 'gif_N_parameter_counts', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::IpMatching::IpmCounts}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field device_id is unset!') unless @device_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field last_seen_timestamp is unset!') unless @last_seen_timestamp
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field cookieable is unset!') if @cookieable.nil?
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Type to represent the diff between two CrossDeviceMatch stores, which is the basis
# for deciding which cookies need to have their cross device group delivered through the IDSyncer.
      class CrossDeviceGroupDiff
        include ::Thrift::Struct, ::Thrift::Struct_Union
        DEVICE_ID = 1
        GROUP = 2
        DIFF_TYPE = 3
        PRECISION_LEVEL = 4

        FIELDS = {
          DEVICE_ID => {:type => ::Thrift::Types::STRUCT, :name => 'device_id', :class => ::Rapleaf::Types::Spruce::DeviceId},
          GROUP => {:type => ::Thrift::Types::STRING, :name => 'group'},
          DIFF_TYPE => {:type => ::Thrift::Types::I32, :name => 'diff_type', :enum_class => ::Rapleaf::Types::IpMatching::DiffType},
          PRECISION_LEVEL => {:type => ::Thrift::Types::I32, :name => 'precision_level'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field device_id is unset!') unless @device_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field group is unset!') unless @group
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field diff_type is unset!') unless @diff_type
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field precision_level is unset!') unless @precision_level
          unless @diff_type.nil? || ::Rapleaf::Types::IpMatching::DiffType::VALID_VALUES.include?(@diff_type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field diff_type!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class IpmMatchingSummaryOverview
        include ::Thrift::Struct, ::Thrift::Struct_Union
        IP = 1
        ISP = 2
        N_LOGS = 3
        N_COOKIE_DEVICES = 4
        N_MOBILE_DEVICES = 5
        N_LABELED_COOKIE_DEVICES = 6
        N_LABELED_MOBILE_DEVICES = 7
        N_COOKIES_IN_XDEVICE_GROUPS = 8
        N_MOBILES_IN_XDEVICE_GROUPS = 9

        FIELDS = {
          IP => {:type => ::Thrift::Types::STRING, :name => 'ip'},
          ISP => {:type => ::Thrift::Types::STRING, :name => 'isp', :optional => true},
          N_LOGS => {:type => ::Thrift::Types::I32, :name => 'n_logs'},
          N_COOKIE_DEVICES => {:type => ::Thrift::Types::I16, :name => 'n_cookie_devices'},
          N_MOBILE_DEVICES => {:type => ::Thrift::Types::I16, :name => 'n_mobile_devices'},
          N_LABELED_COOKIE_DEVICES => {:type => ::Thrift::Types::I16, :name => 'n_labeled_cookie_devices'},
          N_LABELED_MOBILE_DEVICES => {:type => ::Thrift::Types::I16, :name => 'n_labeled_mobile_devices'},
          N_COOKIES_IN_XDEVICE_GROUPS => {:type => ::Thrift::Types::I16, :name => 'n_cookies_in_xdevice_groups'},
          N_MOBILES_IN_XDEVICE_GROUPS => {:type => ::Thrift::Types::I16, :name => 'n_mobiles_in_xdevice_groups'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field ip is unset!') unless @ip
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field n_logs is unset!') unless @n_logs
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field n_cookie_devices is unset!') unless @n_cookie_devices
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field n_mobile_devices is unset!') unless @n_mobile_devices
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field n_labeled_cookie_devices is unset!') unless @n_labeled_cookie_devices
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field n_labeled_mobile_devices is unset!') unless @n_labeled_mobile_devices
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field n_cookies_in_xdevice_groups is unset!') unless @n_cookies_in_xdevice_groups
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field n_mobiles_in_xdevice_groups is unset!') unless @n_mobiles_in_xdevice_groups
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Temporary structure used in measuring publisher traffic in cross device groups
# 
      class CrossDeviceAccuracyPairWithPublisherInfo
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COOKIE_DATA_POINT = 1
        MATCHED_COOKIE_DATA_POINT = 2
        PUBLISHERS = 3

        FIELDS = {
          COOKIE_DATA_POINT => {:type => ::Thrift::Types::STRUCT, :name => 'cookie_data_point', :class => ::Rapleaf::Types::IpMatching::DeviceDataPoint},
          MATCHED_COOKIE_DATA_POINT => {:type => ::Thrift::Types::STRUCT, :name => 'matched_cookie_data_point', :class => ::Rapleaf::Types::IpMatching::DeviceDataPoint},
          PUBLISHERS => {:type => ::Thrift::Types::SET, :name => 'publishers', :element => {:type => ::Thrift::Types::I32}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field cookie_data_point is unset!') unless @cookie_data_point
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field matched_cookie_data_point is unset!') unless @matched_cookie_data_point
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field publishers is unset!') unless @publishers
        end

        ::Thrift::Struct.generate_accessors self
      end

      class StatisticallyMatchedGroupMetaData
        include ::Thrift::Struct, ::Thrift::Struct_Union
        MATCHED_GROUP = 1
        GROUP_METADATA = 2

        FIELDS = {
          MATCHED_GROUP => {:type => ::Thrift::Types::STRUCT, :name => 'matched_group', :class => ::Rapleaf::Types::IpMatching::StatisticallyMatchedGroup},
          GROUP_METADATA => {:type => ::Thrift::Types::SET, :name => 'group_metadata', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::IpMatching::IpmDeviceMetadata}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field matched_group is unset!') unless @matched_group
        end

        ::Thrift::Struct.generate_accessors self
      end

      class DevicePair
        include ::Thrift::Struct, ::Thrift::Struct_Union
        DEVICE_A = 1
        DEVICE_B = 2

        FIELDS = {
          DEVICE_A => {:type => ::Thrift::Types::STRUCT, :name => 'device_a', :class => ::Rapleaf::Types::Spruce::DeviceId},
          DEVICE_B => {:type => ::Thrift::Types::STRUCT, :name => 'device_b', :class => ::Rapleaf::Types::Spruce::DeviceId}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field device_a is unset!') unless @device_a
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field device_b is unset!') unless @device_b
        end

        ::Thrift::Struct.generate_accessors self
      end

      class DevicePairWithSameExternalIdCount
        include ::Thrift::Struct, ::Thrift::Struct_Union
        DEVICE_PAIR = 1
        DISTINCT_EXTERNAL_ID_COUNT_BY_ANA = 2

        FIELDS = {
          DEVICE_PAIR => {:type => ::Thrift::Types::STRUCT, :name => 'device_pair', :class => ::Rapleaf::Types::IpMatching::DevicePair},
          DISTINCT_EXTERNAL_ID_COUNT_BY_ANA => {:type => ::Thrift::Types::MAP, :name => 'distinct_external_id_count_by_ana', :key => {:type => ::Thrift::Types::I32}, :value => {:type => ::Thrift::Types::I64}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field device_pair is unset!') unless @device_pair
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field distinct_external_id_count_by_ana is unset!') unless @distinct_external_id_count_by_ana
        end

        ::Thrift::Struct.generate_accessors self
      end

      class DevicePairWithMultipleIpFeatures
        include ::Thrift::Struct, ::Thrift::Struct_Union
        DEVICE_PAIR = 1
        MULTIPLE_IP_FEATURES = 2

        FIELDS = {
          DEVICE_PAIR => {:type => ::Thrift::Types::STRUCT, :name => 'device_pair', :class => ::Rapleaf::Types::IpMatching::DevicePair},
          MULTIPLE_IP_FEATURES => {:type => ::Thrift::Types::STRUCT, :name => 'multiple_ip_features', :class => ::Rapleaf::Types::IpMatching::MultipleIpFeatures}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field device_pair is unset!') unless @device_pair
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field multiple_ip_features is unset!') unless @multiple_ip_features
        end

        ::Thrift::Struct.generate_accessors self
      end

    end
  end
end
