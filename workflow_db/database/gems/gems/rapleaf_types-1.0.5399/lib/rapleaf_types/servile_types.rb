#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'
require File.join File.dirname(__FILE__), 'util_types'


module Liveramp
  module Types
    module Servile
      module ServiceRequestPriority
        CRITICAL = 1
        HIGH = 3
        DEFAULT = 5
        LOW = 7
        VALUE_MAP = {1 => "CRITICAL", 3 => "HIGH", 5 => "DEFAULT", 7 => "LOW"}
        VALID_VALUES = Set.new([CRITICAL, HIGH, DEFAULT, LOW]).freeze
      end

      module ServiceRequestStatus
        # These requests are still in the process of being created, and are not ready to be processed yet.
        CREATING = 1
        # These requests are ready to be processed, but are waiting for resources.
        PENDING = 2
        IN_PROGRESS = 3
        COMPLETED = 4
        FAILED = 5
        CANCELLED = 7
        # These are requests that failed because of the system and need to stop being processed.
# This is not for misconfigured requests; those should be cancelled because the config is immutable,
# so a resubmit is required anyways.
        QUARANTINED = 8
        EXPIRED = 9
        VALUE_MAP = {1 => "CREATING", 2 => "PENDING", 3 => "IN_PROGRESS", 4 => "COMPLETED", 5 => "FAILED", 7 => "CANCELLED", 8 => "QUARANTINED", 9 => "EXPIRED"}
        VALID_VALUES = Set.new([CREATING, PENDING, IN_PROGRESS, COMPLETED, FAILED, CANCELLED, QUARANTINED, EXPIRED]).freeze
      end

      module WebhookStatus
        PENDING = 1
        IN_PROGRESS = 2
        COMPLETED = 3
        FAILED = 4
        VALUE_MAP = {1 => "PENDING", 2 => "IN_PROGRESS", 3 => "COMPLETED", 4 => "FAILED"}
        VALID_VALUES = Set.new([PENDING, IN_PROGRESS, COMPLETED, FAILED]).freeze
      end

      module ServiceRequestApplication
        FORMATTER = 1
        PACKAGER = 2
        BATCH_DELIVERER = 3
        STREAMING_DELIVERER = 4
        RS_QUERY_RUNNER = 5
        RS_LOADER = 6
        AUDIENCE_COMPILER = 7
        DUMMY_DATA_RETRIEVER = 8
        RECOGNITION_SERVICE = 9
        RECORD_TRANSPOSER = 10
        SANDBOX = 11
        FETCHER = 12
        SPRUCE_INTEGRATION_TESTER = 13
        DATA_RETRIEVER = 14
        PEL_SELECTOR = 15
        AUDIENCE_STATS_SERVICE = 16
        PPR_SERVICE = 17
        TAXONOMY_SERVICE = 18
        SEGMENT_UNION_SIZE_CACHER = 19
        LIVERAMP_FILE_SERVICE = 20
        APPENDER = 21
        TRANSLATOR = 22
        FULFILLMENT_SERVICE = 23
        PARTNER_STATS_SERVICE = 24
        ESTIMATED_REACH_SERVICE = 25
        MATCHED_REACH_SERVICE = 26
        POTENTIAL_REACH_SERVICE = 27
        CID_FP_BUILDER = 28
        UPF_BUILDER = 29
        VALUE_MAP = {1 => "FORMATTER", 2 => "PACKAGER", 3 => "BATCH_DELIVERER", 4 => "STREAMING_DELIVERER", 5 => "RS_QUERY_RUNNER", 6 => "RS_LOADER", 7 => "AUDIENCE_COMPILER", 8 => "DUMMY_DATA_RETRIEVER", 9 => "RECOGNITION_SERVICE", 10 => "RECORD_TRANSPOSER", 11 => "SANDBOX", 12 => "FETCHER", 13 => "SPRUCE_INTEGRATION_TESTER", 14 => "DATA_RETRIEVER", 15 => "PEL_SELECTOR", 16 => "AUDIENCE_STATS_SERVICE", 17 => "PPR_SERVICE", 18 => "TAXONOMY_SERVICE", 19 => "SEGMENT_UNION_SIZE_CACHER", 20 => "LIVERAMP_FILE_SERVICE", 21 => "APPENDER", 22 => "TRANSLATOR", 23 => "FULFILLMENT_SERVICE", 24 => "PARTNER_STATS_SERVICE", 25 => "ESTIMATED_REACH_SERVICE", 26 => "MATCHED_REACH_SERVICE", 27 => "POTENTIAL_REACH_SERVICE", 28 => "CID_FP_BUILDER", 29 => "UPF_BUILDER"}
        VALID_VALUES = Set.new([FORMATTER, PACKAGER, BATCH_DELIVERER, STREAMING_DELIVERER, RS_QUERY_RUNNER, RS_LOADER, AUDIENCE_COMPILER, DUMMY_DATA_RETRIEVER, RECOGNITION_SERVICE, RECORD_TRANSPOSER, SANDBOX, FETCHER, SPRUCE_INTEGRATION_TESTER, DATA_RETRIEVER, PEL_SELECTOR, AUDIENCE_STATS_SERVICE, PPR_SERVICE, TAXONOMY_SERVICE, SEGMENT_UNION_SIZE_CACHER, LIVERAMP_FILE_SERVICE, APPENDER, TRANSLATOR, FULFILLMENT_SERVICE, PARTNER_STATS_SERVICE, ESTIMATED_REACH_SERVICE, MATCHED_REACH_SERVICE, POTENTIAL_REACH_SERVICE, CID_FP_BUILDER, UPF_BUILDER]).freeze
      end

      class OptionalRequestId; end

      class HttpWebhook; end

      class ThriftWebhook; end

      class Webhook < ::Thrift::Union; end

      class ExternalId; end

      class Request; end

      class RequestEvent; end

      class InvalidConfigException < ::Thrift::Exception; end

      class ServileException < ::Thrift::Exception; end

      class ServileError; end

      class OptionalServileError; end

      class EmptyOutput; end

      class RequestOptions; end

      class OptionalRequestId
        include ::Thrift::Struct, ::Thrift::Struct_Union
        REQUEST_ID = 1

        FIELDS = {
          REQUEST_ID => {:type => ::Thrift::Types::I64, :name => 'request_id', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # On completion, an http POST request will be sent to the given URL with the parameters:
# i64 service_request_id
# string external_application_type
# string external_id
# ServiceRequestStatus completion_status (COMPLETED, FAILED, CANCELED, QUARANTINED)
      class HttpWebhook
        include ::Thrift::Struct, ::Thrift::Struct_Union
        URL = 1
        GOOD_STATUS_CODES = 2

        FIELDS = {
          # Webhook url to send POST request to
          URL => {:type => ::Thrift::Types::STRING, :name => 'url'},
          # List of response status codes that represent a successful communication with the webhook url
          GOOD_STATUS_CODES => {:type => ::Thrift::Types::SET, :name => 'good_status_codes', :element => {:type => ::Thrift::Types::I32}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field url is unset!') unless @url
        end

        ::Thrift::Struct.generate_accessors self
      end

      # This is not currently implemented, and should be considered pre-alpha. Please feel free to change this interface.
      class ThriftWebhook
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CONSUL_DOMAIN = 1

        FIELDS = {
          CONSUL_DOMAIN => {:type => ::Thrift::Types::STRING, :name => 'consul_domain'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field consul_domain is unset!') unless @consul_domain
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Types of available webhooks.
      class Webhook < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def http_webhook(val)
            Webhook.new(:http_webhook, val)
          end

          def thrift_webhook(val)
            Webhook.new(:thrift_webhook, val)
          end
        end

        HTTP_WEBHOOK = 1
        THRIFT_WEBHOOK = 2

        FIELDS = {
          HTTP_WEBHOOK => {:type => ::Thrift::Types::STRUCT, :name => 'http_webhook', :class => ::Liveramp::Types::Servile::HttpWebhook, :optional => true},
          THRIFT_WEBHOOK => {:type => ::Thrift::Types::STRUCT, :name => 'thrift_webhook', :class => ::Liveramp::Types::Servile::ThriftWebhook, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      # The ExternalId exists to help clients associate their requests with each other, and outside objects.
      class ExternalId
        include ::Thrift::Struct, ::Thrift::Struct_Union
        APPLICATION_TYPE = 1
        ID = 2

        FIELDS = {
          # An identifier for the external application. (e.g. "data_sync_job")
          APPLICATION_TYPE => {:type => ::Thrift::Types::STRING, :name => 'application_type'},
          # An identifier for an instance from the external application. (e.g. id of DataSyncJob)
          ID => {:type => ::Thrift::Types::STRING, :name => 'id'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field application_type is unset!') unless @application_type
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field id is unset!') unless @id
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The request represents some work that has been submitted to the service.
      class Request
        include ::Thrift::Struct, ::Thrift::Struct_Union
        REQUEST_ID = 1
        STATUS = 2
        PRIORITY = 3
        EXTERNAL_ID = 4
        CREATED_AT = 5
        UPDATED_AT = 6
        EXPIRE_AT = 7

        FIELDS = {
          REQUEST_ID => {:type => ::Thrift::Types::I64, :name => 'request_id'},
          STATUS => {:type => ::Thrift::Types::I32, :name => 'status', :enum_class => ::Liveramp::Types::Servile::ServiceRequestStatus},
          PRIORITY => {:type => ::Thrift::Types::I32, :name => 'priority', :enum_class => ::Liveramp::Types::Servile::ServiceRequestPriority},
          EXTERNAL_ID => {:type => ::Thrift::Types::STRUCT, :name => 'external_id', :class => ::Liveramp::Types::Servile::ExternalId, :optional => true},
          CREATED_AT => {:type => ::Thrift::Types::I64, :name => 'created_at'},
          UPDATED_AT => {:type => ::Thrift::Types::I64, :name => 'updated_at'},
          EXPIRE_AT => {:type => ::Thrift::Types::I64, :name => 'expire_at', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field request_id is unset!') unless @request_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field priority is unset!') unless @priority
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field created_at is unset!') unless @created_at
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field updated_at is unset!') unless @updated_at
          unless @status.nil? || ::Liveramp::Types::Servile::ServiceRequestStatus::VALID_VALUES.include?(@status)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field status!')
          end
          unless @priority.nil? || ::Liveramp::Types::Servile::ServiceRequestPriority::VALID_VALUES.include?(@priority)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field priority!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A RequestEvent records a status change for a request.
      class RequestEvent
        include ::Thrift::Struct, ::Thrift::Struct_Union
        STATUS = 1
        TIME = 2

        FIELDS = {
          STATUS => {:type => ::Thrift::Types::I32, :name => 'status', :enum_class => ::Liveramp::Types::Servile::ServiceRequestStatus},
          TIME => {:type => ::Thrift::Types::I64, :name => 'time'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field time is unset!') unless @time
          unless @status.nil? || ::Liveramp::Types::Servile::ServiceRequestStatus::VALID_VALUES.include?(@status)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field status!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class InvalidConfigException < ::Thrift::Exception
        include ::Thrift::Struct, ::Thrift::Struct_Union
        def initialize(message=nil)
          super()
          self.message = message
        end

        MESSAGE = 1

        FIELDS = {
          MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ServileException < ::Thrift::Exception
        include ::Thrift::Struct, ::Thrift::Struct_Union
        def initialize(message=nil)
          super()
          self.message = message
        end

        MESSAGE = 1

        FIELDS = {
          MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ServileError
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CODE = 1
        MESSAGE = 2

        FIELDS = {
          # A code for the type of error.
# This is meant to be used for programmatically responding to the error so that you don't have to parse the message.
# You can think of this as something similar to http status codes.
          CODE => {:type => ::Thrift::Types::I32, :name => 'code'},
          # The error message.
          MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field code is unset!') unless @code
        end

        ::Thrift::Struct.generate_accessors self
      end

      class OptionalServileError
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ERROR = 1

        FIELDS = {
          ERROR => {:type => ::Thrift::Types::STRUCT, :name => 'error', :class => ::Liveramp::Types::Servile::ServileError, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class EmptyOutput
        include ::Thrift::Struct, ::Thrift::Struct_Union

        FIELDS = {

        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class RequestOptions
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PRIORITY = 1
        EXTERNAL_ID = 2
        WEBHOOK = 3

        FIELDS = {
          PRIORITY => {:type => ::Thrift::Types::I32, :name => 'priority', :default =>           5, :optional => true, :enum_class => ::Liveramp::Types::Servile::ServiceRequestPriority},
          EXTERNAL_ID => {:type => ::Thrift::Types::STRUCT, :name => 'external_id', :class => ::Liveramp::Types::Servile::ExternalId, :optional => true},
          # An optional webhook for publishing completion status for the job.
# If passed, a daemon will look for ServiceRequests with an incomplete webhook, and try to publish
# completion status to a given server route.
          WEBHOOK => {:type => ::Thrift::Types::STRUCT, :name => 'webhook', :class => ::Liveramp::Types::Servile::Webhook, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @priority.nil? || ::Liveramp::Types::Servile::ServiceRequestPriority::VALID_VALUES.include?(@priority)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field priority!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

    end
  end
end
