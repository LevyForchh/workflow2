#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'
require File.join File.dirname(__FILE__), 'mobile_types'
require File.join File.dirname(__FILE__), 'custom_id_types'


module Liveramp
  module OnlineData
    class SyncedCookie; end

    class DoubleMd5Email; end

    class DoubleSha1Email; end

    class Md5Sha1Email; end

    class DoubleHashedPin < ::Thrift::Union; end

    class OnlinePIN < ::Thrift::Union; end

    class DoubleHashedPinToHeid; end

    class SyncedCookie
      include ::Thrift::Struct, ::Thrift::Struct_Union
      AD_NETWORK_ACCOUNT_ID = 1
      COOKIE_ID = 2

      FIELDS = {
        AD_NETWORK_ACCOUNT_ID => {:type => ::Thrift::Types::I32, :name => 'ad_network_account_id'},
        COOKIE_ID => {:type => ::Thrift::Types::STRING, :name => 'cookie_id'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class DoubleMd5Email
      include ::Thrift::Struct, ::Thrift::Struct_Union
      DOUBLE_HASHED_EMAIL = 1

      FIELDS = {
        DOUBLE_HASHED_EMAIL => {:type => ::Thrift::Types::STRING, :name => 'double_hashed_email', :binary => true}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field double_hashed_email is unset!') unless @double_hashed_email
      end

      ::Thrift::Struct.generate_accessors self
    end

    class DoubleSha1Email
      include ::Thrift::Struct, ::Thrift::Struct_Union
      DOUBLE_HASHED_EMAIL = 1

      FIELDS = {
        DOUBLE_HASHED_EMAIL => {:type => ::Thrift::Types::STRING, :name => 'double_hashed_email', :binary => true}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field double_hashed_email is unset!') unless @double_hashed_email
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Md5Sha1Email
      include ::Thrift::Struct, ::Thrift::Struct_Union
      MD5_SHA1_EMAIL = 1

      FIELDS = {
        MD5_SHA1_EMAIL => {:type => ::Thrift::Types::STRING, :name => 'md5_sha1_email', :binary => true}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field md5_sha1_email is unset!') unless @md5_sha1_email
      end

      ::Thrift::Struct.generate_accessors self
    end

    # The twice hashed emails we get from our logs. We shouldn't store these next to PII.
# 
    class DoubleHashedPin < ::Thrift::Union
      include ::Thrift::Struct_Union
      class << self
        def double_md5_email(val)
          DoubleHashedPin.new(:double_md5_email, val)
        end

        def double_sha1_email(val)
          DoubleHashedPin.new(:double_sha1_email, val)
        end

        def md5_sha1_email(val)
          DoubleHashedPin.new(:md5_sha1_email, val)
        end
      end

      DOUBLE_MD5_EMAIL = 1
      DOUBLE_SHA1_EMAIL = 2
      MD5_SHA1_EMAIL = 3

      FIELDS = {
        DOUBLE_MD5_EMAIL => {:type => ::Thrift::Types::STRUCT, :name => 'double_md5_email', :class => ::Liveramp::OnlineData::DoubleMd5Email, :optional => true},
        DOUBLE_SHA1_EMAIL => {:type => ::Thrift::Types::STRUCT, :name => 'double_sha1_email', :class => ::Liveramp::OnlineData::DoubleSha1Email, :optional => true},
        MD5_SHA1_EMAIL => {:type => ::Thrift::Types::STRUCT, :name => 'md5_sha1_email', :class => ::Liveramp::OnlineData::Md5Sha1Email, :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
        raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
      end

      ::Thrift::Union.generate_accessors self
    end

    class OnlinePIN < ::Thrift::Union
      include ::Thrift::Struct_Union
      class << self
        def muid(val)
          OnlinePIN.new(:muid, val)
        end

        def synced_cookie(val)
          OnlinePIN.new(:synced_cookie, val)
        end

        def custom_id(val)
          OnlinePIN.new(:custom_id, val)
        end

        def double_hashed_pin(val)
          OnlinePIN.new(:double_hashed_pin, val)
        end
      end

      MUID = 1
      SYNCED_COOKIE = 2
      CUSTOM_ID = 3
      DOUBLE_HASHED_PIN = 4

      FIELDS = {
        MUID => {:type => ::Thrift::Types::STRUCT, :name => 'muid', :class => ::Liveramp::Types::Mobile::MUID, :optional => true},
        SYNCED_COOKIE => {:type => ::Thrift::Types::STRUCT, :name => 'synced_cookie', :class => ::Liveramp::OnlineData::SyncedCookie, :optional => true},
        CUSTOM_ID => {:type => ::Thrift::Types::STRUCT, :name => 'custom_id', :class => ::Liveramp::Types::CustomId::CustomId, :optional => true},
        DOUBLE_HASHED_PIN => {:type => ::Thrift::Types::STRUCT, :name => 'double_hashed_pin', :class => ::Liveramp::OnlineData::DoubleHashedPin, :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
        raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
      end

      ::Thrift::Union.generate_accessors self
    end

    class DoubleHashedPinToHeid
      include ::Thrift::Struct, ::Thrift::Struct_Union
      HEID = 1
      DOUBLE_HASHED_PIN = 2

      FIELDS = {
        HEID => {:type => ::Thrift::Types::STRING, :name => 'heid', :binary => true},
        DOUBLE_HASHED_PIN => {:type => ::Thrift::Types::STRUCT, :name => 'double_hashed_pin', :class => ::Liveramp::OnlineData::DoubleHashedPin}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field heid is unset!') unless @heid
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field double_hashed_pin is unset!') unless @double_hashed_pin
      end

      ::Thrift::Struct.generate_accessors self
    end

  end
end
