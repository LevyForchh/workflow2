#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'
require File.join File.dirname(__FILE__), 'online_data_types'
require File.join File.dirname(__FILE__), 'bang_types'
require File.join File.dirname(__FILE__), 'liveramp_importer_types'
require File.join File.dirname(__FILE__), 'util_types'
require File.join File.dirname(__FILE__), 'new_person_data_types'
require File.join File.dirname(__FILE__), 'mobile_types'
require File.join File.dirname(__FILE__), 'custom_id_types'
require File.join File.dirname(__FILE__), 'abilitec_types'


module Rapleaf
  module Types
    module NewMatchData
      module ImporterOutputSelector
        RECORDS = 1
        STATS = 2
        VALUE_MAP = {1 => "RECORDS", 2 => "STATS"}
        VALID_VALUES = Set.new([RECORDS, STATS]).freeze
      end

      class MappingMetadata < ::Thrift::Union; end

      class AnonIdMapping; end

      class CidPinMapping; end

      class AnonIdMappingImportRecord; end

      class CidAnonIdIntermediateRecord; end

      class MuidPinMappingImportRecord; end

      class AnonymizableIdentifier < ::Thrift::Union; end

      class MuidIdentifierMappingImportRecord; end

      class MuidIdentifierMappingImportRecordWithPublisherId; end

      class CidPinMappingImportRecord; end

      class PelPubidMappingImportRecord; end

      class PelHeidMappingImportRecord; end

      class MuidAndIrcId; end

      class IrcStatsContainer; end

      class AnonIdImportRecord; end

      class ClinkEmailMapping; end

      class BlacklistedIp; end

      class MappingMetadata < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def timestamp(val)
            MappingMetadata.new(:timestamp, val)
          end

          def ad_network_account_id(val)
            MappingMetadata.new(:ad_network_account_id, val)
          end

          def ip(val)
            MappingMetadata.new(:ip, val)
          end

          def mobile_publisher_id(val)
            MappingMetadata.new(:mobile_publisher_id, val)
          end
        end

        TIMESTAMP = 1
        AD_NETWORK_ACCOUNT_ID = 2
        IP = 3
        MOBILE_PUBLISHER_ID = 4

        FIELDS = {
          TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'timestamp', :optional => true},
          AD_NETWORK_ACCOUNT_ID => {:type => ::Thrift::Types::I32, :name => 'ad_network_account_id', :optional => true},
          IP => {:type => ::Thrift::Types::STRING, :name => 'ip', :optional => true},
          MOBILE_PUBLISHER_ID => {:type => ::Thrift::Types::I32, :name => 'mobile_publisher_id', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class AnonIdMapping
        include ::Thrift::Struct, ::Thrift::Struct_Union
        IDENTIFIER1 = 1
        IDENTIFIER2 = 2
        METADATA = 3

        FIELDS = {
          IDENTIFIER1 => {:type => ::Thrift::Types::STRUCT, :name => 'identifier1', :class => ::Liveramp::Types::Bang::AnonymousIdentifier},
          IDENTIFIER2 => {:type => ::Thrift::Types::STRUCT, :name => 'identifier2', :class => ::Liveramp::Types::Bang::AnonymousIdentifier},
          METADATA => {:type => ::Thrift::Types::SET, :name => 'metadata', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::NewMatchData::MappingMetadata}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field identifier1 is unset!') unless @identifier1
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field identifier2 is unset!') unless @identifier2
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field metadata is unset!') unless @metadata
        end

        ::Thrift::Struct.generate_accessors self
      end

      class CidPinMapping
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CUSTOM_ID = 1
        PIN = 2

        FIELDS = {
          CUSTOM_ID => {:type => ::Thrift::Types::STRUCT, :name => 'custom_id', :class => ::Liveramp::Types::CustomId::CustomId},
          PIN => {:type => ::Thrift::Types::STRUCT, :name => 'pin', :class => ::Rapleaf::Types::NewPersonData::PIN}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field custom_id is unset!') unless @custom_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field pin is unset!') unless @pin
        end

        ::Thrift::Struct.generate_accessors self
      end

      class AnonIdMappingImportRecord
        include ::Thrift::Struct, ::Thrift::Struct_Union
        RECORD_ID = 1
        UNIQUE_KEY = 2
        IDENTIFIER_MAPPINGS = 3

        FIELDS = {
          RECORD_ID => {:type => ::Thrift::Types::STRUCT, :name => 'record_id', :class => ::Liveramp::Importer::ImportRecordID},
          UNIQUE_KEY => {:type => ::Thrift::Types::MAP, :name => 'unique_key', :key => {:type => ::Thrift::Types::I32}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Util::StringOrNone}},
          IDENTIFIER_MAPPINGS => {:type => ::Thrift::Types::SET, :name => 'identifier_mappings', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::NewMatchData::AnonIdMapping}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field record_id is unset!') unless @record_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field unique_key is unset!') unless @unique_key
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field identifier_mappings is unset!') unless @identifier_mappings
        end

        ::Thrift::Struct.generate_accessors self
      end

      class CidAnonIdIntermediateRecord
        include ::Thrift::Struct, ::Thrift::Struct_Union
        IMPORT_RECORD = 1
        IDENTIFIER = 2
        MAPPING_ID = 3
        PRIMARY = 4

        FIELDS = {
          IMPORT_RECORD => {:type => ::Thrift::Types::STRUCT, :name => 'import_record', :class => ::Rapleaf::Types::NewMatchData::AnonIdMappingImportRecord},
          IDENTIFIER => {:type => ::Thrift::Types::STRUCT, :name => 'identifier', :class => ::Liveramp::Types::Bang::AnonymousIdentifier},
          MAPPING_ID => {:type => ::Thrift::Types::I32, :name => 'mapping_id'},
          PRIMARY => {:type => ::Thrift::Types::BOOL, :name => 'primary'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field import_record is unset!') unless @import_record
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field identifier is unset!') unless @identifier
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field mapping_id is unset!') unless @mapping_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field primary is unset!') if @primary.nil?
        end

        ::Thrift::Struct.generate_accessors self
      end

      class MuidPinMappingImportRecord
        include ::Thrift::Struct, ::Thrift::Struct_Union
        RECORD_ID = 1
        UNIQUE_KEY = 2
        PIN = 3
        MUIDS = 4
        TIMESTAMP = 5
        IP = 6

        FIELDS = {
          RECORD_ID => {:type => ::Thrift::Types::STRUCT, :name => 'record_id', :class => ::Liveramp::Importer::ImportRecordID},
          UNIQUE_KEY => {:type => ::Thrift::Types::MAP, :name => 'unique_key', :key => {:type => ::Thrift::Types::I32}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Util::StringOrNone}},
          PIN => {:type => ::Thrift::Types::STRUCT, :name => 'pin', :class => ::Rapleaf::Types::NewPersonData::PIN},
          MUIDS => {:type => ::Thrift::Types::SET, :name => 'muids', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::Mobile::MUID}},
          TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'timestamp'},
          IP => {:type => ::Thrift::Types::STRING, :name => 'ip', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field record_id is unset!') unless @record_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field unique_key is unset!') unless @unique_key
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field pin is unset!') unless @pin
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field muids is unset!') unless @muids
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field timestamp is unset!') unless @timestamp
        end

        ::Thrift::Struct.generate_accessors self
      end

      class AnonymizableIdentifier < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def pin(val)
            AnonymizableIdentifier.new(:pin, val)
          end

          def double_hashed_pin(val)
            AnonymizableIdentifier.new(:double_hashed_pin, val)
          end
        end

        PIN = 1
        DOUBLE_HASHED_PIN = 2

        FIELDS = {
          PIN => {:type => ::Thrift::Types::STRUCT, :name => 'pin', :class => ::Rapleaf::Types::NewPersonData::PIN, :optional => true},
          DOUBLE_HASHED_PIN => {:type => ::Thrift::Types::STRUCT, :name => 'double_hashed_pin', :class => ::Liveramp::OnlineData::DoubleHashedPin, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class MuidIdentifierMappingImportRecord
        include ::Thrift::Struct, ::Thrift::Struct_Union
        RECORD_ID = 1
        UNIQUE_KEY = 2
        ANONYMIZABLE_IDENTIFIER = 3
        MUIDS = 4
        TIMESTAMP = 5
        IP = 6
        METADATA = 7
        ARL = 8
        APPENDED = 9

        FIELDS = {
          RECORD_ID => {:type => ::Thrift::Types::STRUCT, :name => 'record_id', :class => ::Liveramp::Importer::ImportRecordID},
          UNIQUE_KEY => {:type => ::Thrift::Types::MAP, :name => 'unique_key', :key => {:type => ::Thrift::Types::I32}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Util::StringOrNone}},
          ANONYMIZABLE_IDENTIFIER => {:type => ::Thrift::Types::STRUCT, :name => 'anonymizable_identifier', :class => ::Rapleaf::Types::NewMatchData::AnonymizableIdentifier},
          MUIDS => {:type => ::Thrift::Types::SET, :name => 'muids', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::Mobile::MUID}},
          TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'timestamp'},
          IP => {:type => ::Thrift::Types::STRING, :name => 'ip', :optional => true},
          METADATA => {:type => ::Thrift::Types::SET, :name => 'metadata', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::NewMatchData::MappingMetadata}, :optional => true},
          ARL => {:type => ::Thrift::Types::STRUCT, :name => 'arl', :class => ::Liveramp::Abilitec::Arl, :optional => true},
          APPENDED => {:type => ::Thrift::Types::BOOL, :name => 'appended', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field record_id is unset!') unless @record_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field unique_key is unset!') unless @unique_key
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field anonymizable_identifier is unset!') unless @anonymizable_identifier
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field muids is unset!') unless @muids
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field timestamp is unset!') unless @timestamp
        end

        ::Thrift::Struct.generate_accessors self
      end

      class MuidIdentifierMappingImportRecordWithPublisherId
        include ::Thrift::Struct, ::Thrift::Struct_Union
        RECORD_ID = 1
        UNIQUE_KEY = 2
        ANONYMIZABLE_IDENTIFIER = 3
        MUIDS = 4
        TIMESTAMP = 5
        MOBILE_PUBLISHER_ID = 6
        IP = 7

        FIELDS = {
          RECORD_ID => {:type => ::Thrift::Types::STRUCT, :name => 'record_id', :class => ::Liveramp::Importer::ImportRecordID},
          UNIQUE_KEY => {:type => ::Thrift::Types::MAP, :name => 'unique_key', :key => {:type => ::Thrift::Types::I32}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Util::StringOrNone}},
          ANONYMIZABLE_IDENTIFIER => {:type => ::Thrift::Types::STRUCT, :name => 'anonymizable_identifier', :class => ::Rapleaf::Types::NewMatchData::AnonymizableIdentifier},
          MUIDS => {:type => ::Thrift::Types::SET, :name => 'muids', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::Mobile::MUID}},
          TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'timestamp'},
          MOBILE_PUBLISHER_ID => {:type => ::Thrift::Types::I32, :name => 'mobile_publisher_id'},
          IP => {:type => ::Thrift::Types::STRING, :name => 'ip', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field record_id is unset!') unless @record_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field unique_key is unset!') unless @unique_key
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field anonymizable_identifier is unset!') unless @anonymizable_identifier
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field muids is unset!') unless @muids
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field timestamp is unset!') unless @timestamp
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field mobile_publisher_id is unset!') unless @mobile_publisher_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      class CidPinMappingImportRecord
        include ::Thrift::Struct, ::Thrift::Struct_Union
        RECORD_ID = 1
        UNIQUE_KEY = 2
        PIN = 3
        CUSTOM_ID = 4

        FIELDS = {
          RECORD_ID => {:type => ::Thrift::Types::STRUCT, :name => 'record_id', :class => ::Liveramp::Importer::ImportRecordID},
          UNIQUE_KEY => {:type => ::Thrift::Types::MAP, :name => 'unique_key', :key => {:type => ::Thrift::Types::I32}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Util::StringOrNone}},
          PIN => {:type => ::Thrift::Types::STRUCT, :name => 'pin', :class => ::Rapleaf::Types::NewPersonData::PIN},
          CUSTOM_ID => {:type => ::Thrift::Types::STRUCT, :name => 'custom_id', :class => ::Liveramp::Types::CustomId::CustomId}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field record_id is unset!') unless @record_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field unique_key is unset!') unless @unique_key
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field pin is unset!') unless @pin
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field custom_id is unset!') unless @custom_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      class PelPubidMappingImportRecord
        include ::Thrift::Struct, ::Thrift::Struct_Union
        RECORD_ID = 1
        UNIQUE_KEY = 2
        PEL = 3
        PUBID = 4

        FIELDS = {
          RECORD_ID => {:type => ::Thrift::Types::STRUCT, :name => 'record_id', :class => ::Liveramp::Importer::ImportRecordID},
          UNIQUE_KEY => {:type => ::Thrift::Types::MAP, :name => 'unique_key', :key => {:type => ::Thrift::Types::I32}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Util::StringOrNone}},
          PEL => {:type => ::Thrift::Types::STRUCT, :name => 'pel', :class => ::Liveramp::Types::CustomId::CustomId},
          PUBID => {:type => ::Thrift::Types::STRUCT, :name => 'pubid', :class => ::Liveramp::Types::CustomId::CustomId}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field record_id is unset!') unless @record_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field unique_key is unset!') unless @unique_key
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field pel is unset!') unless @pel
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field pubid is unset!') unless @pubid
        end

        ::Thrift::Struct.generate_accessors self
      end

      class PelHeidMappingImportRecord
        include ::Thrift::Struct, ::Thrift::Struct_Union
        RECORD_ID = 1
        UNIQUE_KEY = 2
        PEL = 3
        HEID = 4

        FIELDS = {
          RECORD_ID => {:type => ::Thrift::Types::STRUCT, :name => 'record_id', :class => ::Liveramp::Importer::ImportRecordID},
          UNIQUE_KEY => {:type => ::Thrift::Types::MAP, :name => 'unique_key', :key => {:type => ::Thrift::Types::I32}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Util::StringOrNone}},
          PEL => {:type => ::Thrift::Types::STRUCT, :name => 'pel', :class => ::Liveramp::Types::CustomId::CustomId},
          HEID => {:type => ::Thrift::Types::STRING, :name => 'heid', :binary => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field record_id is unset!') unless @record_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field unique_key is unset!') unless @unique_key
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field pel is unset!') unless @pel
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field heid is unset!') unless @heid
        end

        ::Thrift::Struct.generate_accessors self
      end

      class MuidAndIrcId
        include ::Thrift::Struct, ::Thrift::Struct_Union
        IRC_ID = 1
        MUID = 2

        FIELDS = {
          IRC_ID => {:type => ::Thrift::Types::I64, :name => 'irc_id'},
          MUID => {:type => ::Thrift::Types::STRUCT, :name => 'muid', :class => ::Liveramp::Types::Mobile::MUID}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field irc_id is unset!') unless @irc_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field muid is unset!') unless @muid
        end

        ::Thrift::Struct.generate_accessors self
      end

      class IrcStatsContainer
        include ::Thrift::Struct, ::Thrift::Struct_Union
        IRC_ID = 1
        STAT_NAME = 2
        COUNT = 3

        FIELDS = {
          IRC_ID => {:type => ::Thrift::Types::I64, :name => 'irc_id'},
          STAT_NAME => {:type => ::Thrift::Types::STRING, :name => 'stat_name'},
          COUNT => {:type => ::Thrift::Types::I64, :name => 'count'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field irc_id is unset!') unless @irc_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field stat_name is unset!') unless @stat_name
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field count is unset!') unless @count
        end

        ::Thrift::Struct.generate_accessors self
      end

      class AnonIdImportRecord
        include ::Thrift::Struct, ::Thrift::Struct_Union
        RECORD_ID = 1
        UNIQUE_KEY = 2
        ANON_IDS = 3
        METADATA = 4

        FIELDS = {
          RECORD_ID => {:type => ::Thrift::Types::STRUCT, :name => 'record_id', :class => ::Liveramp::Importer::ImportRecordID},
          UNIQUE_KEY => {:type => ::Thrift::Types::MAP, :name => 'unique_key', :key => {:type => ::Thrift::Types::I32}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Util::StringOrNone}},
          ANON_IDS => {:type => ::Thrift::Types::SET, :name => 'anon_ids', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::Bang::AnonymousIdentifier}},
          METADATA => {:type => ::Thrift::Types::SET, :name => 'metadata', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::NewMatchData::MappingMetadata}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field record_id is unset!') unless @record_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field unique_key is unset!') unless @unique_key
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field anon_ids is unset!') unless @anon_ids
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field metadata is unset!') unless @metadata
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ClinkEmailMapping
        include ::Thrift::Struct, ::Thrift::Struct_Union
        EMAIL = 1
        CLINK = 2

        FIELDS = {
          EMAIL => {:type => ::Thrift::Types::STRUCT, :name => 'email', :class => ::Rapleaf::Types::NewPersonData::PIN},
          CLINK => {:type => ::Thrift::Types::STRUCT, :name => 'clink', :class => ::Rapleaf::Types::NewPersonData::PIN}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field email is unset!') unless @email
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field clink is unset!') unless @clink
        end

        ::Thrift::Struct.generate_accessors self
      end

      class BlacklistedIp
        include ::Thrift::Struct, ::Thrift::Struct_Union
        IP = 1
        TRAFFIC_VOLUME = 2
        LAST_BLACKLISTED_AT = 3

        FIELDS = {
          IP => {:type => ::Thrift::Types::STRING, :name => 'ip'},
          TRAFFIC_VOLUME => {:type => ::Thrift::Types::I64, :name => 'traffic_volume'},
          LAST_BLACKLISTED_AT => {:type => ::Thrift::Types::I32, :name => 'last_blacklisted_at'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field ip is unset!') unless @ip
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field traffic_volume is unset!') unless @traffic_volume
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field last_blacklisted_at is unset!') unless @last_blacklisted_at
        end

        ::Thrift::Struct.generate_accessors self
      end

    end
  end
end
