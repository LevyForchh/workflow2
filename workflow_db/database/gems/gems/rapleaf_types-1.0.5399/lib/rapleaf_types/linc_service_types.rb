#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'
require File.join File.dirname(__FILE__), 'parc_service_types'
require File.join File.dirname(__FILE__), 'user_agent_types'
require File.join File.dirname(__FILE__), 'abilitec_types'
require File.join File.dirname(__FILE__), 'anonymous_identifier_mapping_types'


module Liveramp
  module Types
    module LincService
      module LincStep
        PARC = 1
        POST_PROCESSING = 2
        EDGE_AND_METADATA_BUILDER = 3
        EDGE_AND_METADATA_DELETER = 4
        VALUE_MAP = {1 => "PARC", 2 => "POST_PROCESSING", 3 => "EDGE_AND_METADATA_BUILDER", 4 => "EDGE_AND_METADATA_DELETER"}
        VALID_VALUES = Set.new([PARC, POST_PROCESSING, EDGE_AND_METADATA_BUILDER, EDGE_AND_METADATA_DELETER]).freeze
      end

      module LincStatus
        NEW = 1
        IN_PROGRESS = 2
        COMPLETE = 3
        FAILED = 4
        CANCELLED = 5
        QA_FAILED = 6
        DELETED = 8
        READY_TO_PERSIST = 9
        PERSISTOR_IN_PROGRESS = 10
        PERSISTOR_FAILED = 11
        DELETE_IN_PROGRESS = 12
        DELETE_FAILED = 13
        BAD_CONFIGURATION = 14
        VALUE_MAP = {1 => "NEW", 2 => "IN_PROGRESS", 3 => "COMPLETE", 4 => "FAILED", 5 => "CANCELLED", 6 => "QA_FAILED", 8 => "DELETED", 9 => "READY_TO_PERSIST", 10 => "PERSISTOR_IN_PROGRESS", 11 => "PERSISTOR_FAILED", 12 => "DELETE_IN_PROGRESS", 13 => "DELETE_FAILED", 14 => "BAD_CONFIGURATION"}
        VALID_VALUES = Set.new([NEW, IN_PROGRESS, COMPLETE, FAILED, CANCELLED, QA_FAILED, DELETED, READY_TO_PERSIST, PERSISTOR_IN_PROGRESS, PERSISTOR_FAILED, DELETE_IN_PROGRESS, DELETE_FAILED, BAD_CONFIGURATION]).freeze
      end

      module LincPersistorBatchStatus
        RUNNING = 1
        COMPLETED = 2
        TO_BE_RETRIED = 3
        FAILED = 4
        CANCELLED = 5
        VALUE_MAP = {1 => "RUNNING", 2 => "COMPLETED", 3 => "TO_BE_RETRIED", 4 => "FAILED", 5 => "CANCELLED"}
        VALID_VALUES = Set.new([RUNNING, COMPLETED, TO_BE_RETRIED, FAILED, CANCELLED]).freeze
      end

      module BangBadDataNodeFilterStatus
        NEW = 1
        IN_PROGRESS = 2
        COMPLETED = 3
        TO_BE_RETRIED = 4
        CANCELLED = 5
        VALUE_MAP = {1 => "NEW", 2 => "IN_PROGRESS", 3 => "COMPLETED", 4 => "TO_BE_RETRIED", 5 => "CANCELLED"}
        VALID_VALUES = Set.new([NEW, IN_PROGRESS, COMPLETED, TO_BE_RETRIED, CANCELLED]).freeze
      end

      module LincImportStats
        TOTAL_RECORDS = 1
        MAINTAINED_PELS = 2
        TOTAL_PELS = 3
        DERIVED_PELS = 4
        TARGETS_AGREEMENT = 5
        VALUE_MAP = {1 => "TOTAL_RECORDS", 2 => "MAINTAINED_PELS", 3 => "TOTAL_PELS", 4 => "DERIVED_PELS", 5 => "TARGETS_AGREEMENT"}
        VALID_VALUES = Set.new([TOTAL_RECORDS, MAINTAINED_PELS, TOTAL_PELS, DERIVED_PELS, TARGETS_AGREEMENT]).freeze
      end

      module MatchDataProviderType
        COOKIE_PUBLISHER = 0
        MOBILE_PUBLISHER = 1
        CUSTOM_ID_PUBLISHER = 2
        PEL_TO_PEL = 3
        VALUE_MAP = {0 => "COOKIE_PUBLISHER", 1 => "MOBILE_PUBLISHER", 2 => "CUSTOM_ID_PUBLISHER", 3 => "PEL_TO_PEL"}
        VALID_VALUES = Set.new([COOKIE_PUBLISHER, MOBILE_PUBLISHER, CUSTOM_ID_PUBLISHER, PEL_TO_PEL]).freeze
      end

      class InvalidConfigurationException < ::Thrift::Exception; end

      class EdgeImportConfiguration; end

      class IdentifierMetadataImportConfiguration; end

      class ImportConfiguration; end

      class CookieSyncConfig; end

      class CookiePelConfig; end

      class FeedAutomationConfig < ::Thrift::Union; end

      class FeedInfo; end

      class FeedOptions; end

      class UseCaseInfo; end

      class ImportInfo; end

      class LincSummary; end

      class LincCreatorId; end

      class PelIngestionRequest; end

      class InvalidConfigurationException < ::Thrift::Exception
        include ::Thrift::Struct, ::Thrift::Struct_Union
        def initialize(message=nil)
          super()
          self.message = message
        end

        MESSAGE = 1

        FIELDS = {
          MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field message is unset!') unless @message
        end

        ::Thrift::Struct.generate_accessors self
      end

      class EdgeImportConfiguration
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SOURCE_KEY = 1
        SOURCE_TYPE = 2
        SOURCE_POOL_ID = 3
        TARGET_KEY = 4
        TARGET_TYPE = 5
        TARGET_POOL_ID = 6
        EDGE_STORE_ID = 7

        FIELDS = {
          # Predefined name for the header/key corresponding to the edge's source identifier.
# 
          SOURCE_KEY => {:type => ::Thrift::Types::STRING, :name => 'source_key'},
          SOURCE_TYPE => {:type => ::Thrift::Types::I16, :name => 'source_type'},
          SOURCE_POOL_ID => {:type => ::Thrift::Types::I64, :name => 'source_pool_id', :optional => true},
          # Predefined name for the header/key corresponding to the edge's target identifier.
# 
          TARGET_KEY => {:type => ::Thrift::Types::STRING, :name => 'target_key'},
          TARGET_TYPE => {:type => ::Thrift::Types::I16, :name => 'target_type'},
          TARGET_POOL_ID => {:type => ::Thrift::Types::I64, :name => 'target_pool_id', :optional => true},
          EDGE_STORE_ID => {:type => ::Thrift::Types::I32, :name => 'edge_store_id'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field source_key is unset!') unless @source_key
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field source_type is unset!') unless @source_type
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field target_key is unset!') unless @target_key
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field target_type is unset!') unless @target_type
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field edge_store_id is unset!') unless @edge_store_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      class IdentifierMetadataImportConfiguration
        include ::Thrift::Struct, ::Thrift::Struct_Union
        IDENTIFIER_KEY = 1
        IDENTIFIER_POOL_ID = 2
        METADATA_KEYS = 3
        IDENTIFIER_METADATA_STORE_ID = 4

        FIELDS = {
          # Predefined name for the header/key corresponding to the identifier.
# 
          IDENTIFIER_KEY => {:type => ::Thrift::Types::STRING, :name => 'identifier_key'},
          IDENTIFIER_POOL_ID => {:type => ::Thrift::Types::I64, :name => 'identifier_pool_id', :optional => true},
          # These are all the keys (e.g. timestamp, group_id, etc.) associated with
# the identifier. The backend will use the anononymous_identifier_metadata_type
# field to determine how to interpret them.
# 
          METADATA_KEYS => {:type => ::Thrift::Types::SET, :name => 'metadata_keys', :element => {:type => ::Thrift::Types::STRING}},
          IDENTIFIER_METADATA_STORE_ID => {:type => ::Thrift::Types::I32, :name => 'identifier_metadata_store_id'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field identifier_key is unset!') unless @identifier_key
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field metadata_keys is unset!') unless @metadata_keys
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field identifier_metadata_store_id is unset!') unless @identifier_metadata_store_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ImportConfiguration
        include ::Thrift::Struct, ::Thrift::Struct_Union
        EDGE_IMPORT_CONFIGURATION = 1
        IDENTIFIER_METADATA_IMPORT_CONFIGURATION = 2
        KEY_MAPPING = 3

        FIELDS = {
          EDGE_IMPORT_CONFIGURATION => {:type => ::Thrift::Types::STRUCT, :name => 'edge_import_configuration', :class => ::Liveramp::Types::LincService::EdgeImportConfiguration, :optional => true},
          IDENTIFIER_METADATA_IMPORT_CONFIGURATION => {:type => ::Thrift::Types::STRUCT, :name => 'identifier_metadata_import_configuration', :class => ::Liveramp::Types::LincService::IdentifierMetadataImportConfiguration, :optional => true},
          # All match data imports require File.join File.dirname(__FILE__), very specific headers/keys (e.g. source_identifier, group_id, etc.).
# Since a given file might not have headers/keys that exactly match the required ones, a
# mapping is required to establish the correspondence between them (key = required key,
# value = key from file).
# 
# The value is a set for cases where a single line can have more than one identifier that
# fullfill the same role (e.g. email and NAP that both map to the PEL for a cid-PEL edge).
# 
# 
          KEY_MAPPING => {:type => ::Thrift::Types::MAP, :name => 'key_mapping', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::SET, :element => {:type => ::Thrift::Types::STRING}}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field key_mapping is unset!') unless @key_mapping
        end

        ::Thrift::Struct.generate_accessors self
      end

      class CookieSyncConfig
        include ::Thrift::Struct, ::Thrift::Struct_Union
        POOL_ID = 2

        FIELDS = {
          POOL_ID => {:type => ::Thrift::Types::I64, :name => 'pool_id'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field pool_id is unset!') unless @pool_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      class CookiePelConfig
        include ::Thrift::Struct, ::Thrift::Struct_Union
        POOL_ID = 2

        FIELDS = {
          POOL_ID => {:type => ::Thrift::Types::I64, :name => 'pool_id'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field pool_id is unset!') unless @pool_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      class FeedAutomationConfig < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def nfs_dir(val)
            FeedAutomationConfig.new(:nfs_dir, val)
          end

          def cookie_sync_config(val)
            FeedAutomationConfig.new(:cookie_sync_config, val)
          end

          def cookie_pel_config(val)
            FeedAutomationConfig.new(:cookie_pel_config, val)
          end
        end

        NFS_DIR = 1
        COOKIE_SYNC_CONFIG = 2
        COOKIE_PEL_CONFIG = 3

        FIELDS = {
          NFS_DIR => {:type => ::Thrift::Types::STRING, :name => 'nfs_dir', :optional => true},
          COOKIE_SYNC_CONFIG => {:type => ::Thrift::Types::STRUCT, :name => 'cookie_sync_config', :class => ::Liveramp::Types::LincService::CookieSyncConfig, :optional => true},
          COOKIE_PEL_CONFIG => {:type => ::Thrift::Types::STRUCT, :name => 'cookie_pel_config', :class => ::Liveramp::Types::LincService::CookiePelConfig, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class FeedInfo
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ID = 1
        NAME = 2
        MATCH_DATA_PROVIDER_ID = 3
        ACTIVE = 4
        TEMPLATE_FILE_CONFIGURATION = 5
        TEMPLATE_IMPORT_CONFIGURATION = 6
        FEED_AUTOMATION_CONFIG = 7

        FIELDS = {
          ID => {:type => ::Thrift::Types::I64, :name => 'id'},
          NAME => {:type => ::Thrift::Types::STRING, :name => 'name'},
          MATCH_DATA_PROVIDER_ID => {:type => ::Thrift::Types::I64, :name => 'match_data_provider_id'},
          ACTIVE => {:type => ::Thrift::Types::BOOL, :name => 'active'},
          TEMPLATE_FILE_CONFIGURATION => {:type => ::Thrift::Types::STRUCT, :name => 'template_file_configuration', :class => ::Liveramp::Types::ParcService::FileConfiguration, :optional => true},
          TEMPLATE_IMPORT_CONFIGURATION => {:type => ::Thrift::Types::STRUCT, :name => 'template_import_configuration', :class => ::Liveramp::Types::LincService::ImportConfiguration, :optional => true},
          FEED_AUTOMATION_CONFIG => {:type => ::Thrift::Types::STRUCT, :name => 'feed_automation_config', :class => ::Liveramp::Types::LincService::FeedAutomationConfig, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field id is unset!') unless @id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field name is unset!') unless @name
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field match_data_provider_id is unset!') unless @match_data_provider_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field active is unset!') if @active.nil?
        end

        ::Thrift::Struct.generate_accessors self
      end

      class FeedOptions
        include ::Thrift::Struct, ::Thrift::Struct_Union
        NAME = 1
        TEMPLATE_FILE_CONFIGURATION = 2
        TEMPLATE_IMPORT_CONFIGURATION = 3
        FEED_AUTOMATION_CONFIG = 4
        AUDIENCE_ID = 5

        FIELDS = {
          NAME => {:type => ::Thrift::Types::STRING, :name => 'name', :optional => true},
          TEMPLATE_FILE_CONFIGURATION => {:type => ::Thrift::Types::STRUCT, :name => 'template_file_configuration', :class => ::Liveramp::Types::ParcService::FileConfiguration, :optional => true},
          TEMPLATE_IMPORT_CONFIGURATION => {:type => ::Thrift::Types::STRUCT, :name => 'template_import_configuration', :class => ::Liveramp::Types::LincService::ImportConfiguration, :optional => true},
          FEED_AUTOMATION_CONFIG => {:type => ::Thrift::Types::STRUCT, :name => 'feed_automation_config', :class => ::Liveramp::Types::LincService::FeedAutomationConfig, :optional => true},
          AUDIENCE_ID => {:type => ::Thrift::Types::I64, :name => 'audience_id', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class UseCaseInfo
        include ::Thrift::Struct, ::Thrift::Struct_Union
        NAME = 1
        DESCRIPTION = 2
        EDGE_STORE_ID = 3
        IDENTIFIER_METADATA_STORE_ID = 4

        FIELDS = {
          NAME => {:type => ::Thrift::Types::STRING, :name => 'name'},
          DESCRIPTION => {:type => ::Thrift::Types::STRING, :name => 'description'},
          EDGE_STORE_ID => {:type => ::Thrift::Types::I32, :name => 'edge_store_id', :optional => true},
          IDENTIFIER_METADATA_STORE_ID => {:type => ::Thrift::Types::I32, :name => 'identifier_metadata_store_id', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field name is unset!') unless @name
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field description is unset!') unless @description
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ImportInfo
        include ::Thrift::Struct, ::Thrift::Struct_Union
        LINC_ID = 1
        MATCH_DATA_PROVIDER_ID = 2
        SUBNETWORK_ID = 3
        NFS_PATH = 4

        FIELDS = {
          LINC_ID => {:type => ::Thrift::Types::I64, :name => 'linc_id'},
          MATCH_DATA_PROVIDER_ID => {:type => ::Thrift::Types::I64, :name => 'match_data_provider_id'},
          SUBNETWORK_ID => {:type => ::Thrift::Types::I64, :name => 'subnetwork_id'},
          NFS_PATH => {:type => ::Thrift::Types::STRING, :name => 'nfs_path'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field linc_id is unset!') unless @linc_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field match_data_provider_id is unset!') unless @match_data_provider_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field subnetwork_id is unset!') unless @subnetwork_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field nfs_path is unset!') unless @nfs_path
        end

        ::Thrift::Struct.generate_accessors self
      end

      class LincSummary
        include ::Thrift::Struct, ::Thrift::Struct_Union
        LINC_ID = 1

        FIELDS = {
          LINC_ID => {:type => ::Thrift::Types::I64, :name => 'linc_id'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field linc_id is unset!') unless @linc_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Thrift doesn't allow for optional arguments in a parameter. This is a way to get around it.
# 
      class LincCreatorId
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CREATOR_ID = 1

        FIELDS = {
          CREATOR_ID => {:type => ::Thrift::Types::I32, :name => 'creator_id', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class PelIngestionRequest
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PEL_INGESTION_CONFIG_ID = 10
        USER_ID = 20
        FILE_PATH = 30

        FIELDS = {
          PEL_INGESTION_CONFIG_ID => {:type => ::Thrift::Types::I64, :name => 'pel_ingestion_config_id'},
          USER_ID => {:type => ::Thrift::Types::I64, :name => 'user_id'},
          FILE_PATH => {:type => ::Thrift::Types::STRING, :name => 'file_path'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field pel_ingestion_config_id is unset!') unless @pel_ingestion_config_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field user_id is unset!') unless @user_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field file_path is unset!') unless @file_path
        end

        ::Thrift::Struct.generate_accessors self
      end

    end
  end
end
