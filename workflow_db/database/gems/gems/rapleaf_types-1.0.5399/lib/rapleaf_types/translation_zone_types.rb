#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'
require File.join File.dirname(__FILE__), 'om_lib_types'
require File.join File.dirname(__FILE__), 'new_person_data_types'
require File.join File.dirname(__FILE__), 'abilitec_types'
require File.join File.dirname(__FILE__), 'pii_integration_types'
require File.join File.dirname(__FILE__), 'parc_types'
require File.join File.dirname(__FILE__), 'identifier_only_importer_types'
require File.join File.dirname(__FILE__), 'bang_types'
require File.join File.dirname(__FILE__), 'util_types'
require File.join File.dirname(__FILE__), 'servile_types'
require File.join File.dirname(__FILE__), 'doc_ids_types'
require File.join File.dirname(__FILE__), 'translator_enums_types'


module Liveramp
  module OfflineMatching
    module TranslationZone
      module TranslatorOutputType
        DDOC = 1
        MDOC = 2
        HOUSEHOLD_DOC = 3
        ZIP4_DOC = 4
        EH_PII = 5
        DPEL = 6
        MPEL = 7
        HOUSEHOLD_PEL = 8
        ZIP4_DPEL = 9
        ARL = 10
        VALUE_MAP = {1 => "DDOC", 2 => "MDOC", 3 => "HOUSEHOLD_DOC", 4 => "ZIP4_DOC", 5 => "EH_PII", 6 => "DPEL", 7 => "MPEL", 8 => "HOUSEHOLD_PEL", 9 => "ZIP4_DPEL", 10 => "ARL"}
        VALID_VALUES = Set.new([DDOC, MDOC, HOUSEHOLD_DOC, ZIP4_DOC, EH_PII, DPEL, MPEL, HOUSEHOLD_PEL, ZIP4_DPEL, ARL]).freeze
      end

      module TranslatorFunction
        PLAINTEXT_EMAIL_TO_MDOC = 1
        CLIENT_PII_MDOC_TO_MDOC = 2
        MD5_EMAIL_TO_MDOC = 3
        SHA1_EMAIL_TO_MDOC = 4
        SHA256_EMAIL_TO_MDOC = 5
        NAP_TO_MDOC = 6
        PHONE_TO_MDOC = 7
        ERL_TO_MDOC = 8
        PLAINTEXT_EMAIL_TO_ISOTOPES_AND_HASHES_TO_DDOC = 9
        MD5_EMAIL_TO_DDOC = 10
        SHA1_EMAIL_TO_DDOC = 11
        SHA256_EMAIL_TO_DDOC = 12
        PHONE_TO_DDOC = 13
        ERL_TO_DDOC = 14
        CLIENT_PII_DDOC_TO_DDOC = 15
        ZIP4_TO_ZIP4_DDOC = 16
        NAP_TO_NORMALIZED_DDOC = 17
        PLAINTEXT_EMAIL_TO_ISOTOPES_TO_ENCRYPTED_HASHED_PII = 18
        SHA256_EMAIL_TO_ENCRYPTED_HASHED_PII = 19
        NAP_TO_ENCRYPTED_HASHED_PII = 20
        PHONE_TO_ENCRYPTED_HASHED_PII = 21
        PLAINTEXT_EMAIL_TO_MPEL = 22
        CLIENT_MCLINK_TO_MPEL = 23
        LR_MCLINK_TO_MPEL = 24
        MD5_EMAIL_TO_MPEL = 25
        SHA1_EMAIL_TO_MPEL = 26
        SHA256_EMAIL_TO_MPEL = 27
        NAP_TO_MPEL = 28
        PHONE_TO_MPEL = 29
        ERL_TO_MPEL = 30
        PLAINTEXT_EMAIL_TO_ISOTOPES_AND_HASHES_TO_DPEL = 31
        MD5_EMAIL_TO_DPEL = 32
        SHA1_EMAIL_TO_DPEL = 33
        SHA256_EMAIL_TO_DPEL = 34
        NAP_TO_DPEL = 35
        PHONE_TO_DPEL = 36
        ERL_TO_DPEL = 37
        CLIENT_DCLINK_TO_DPEL = 38
        LR_DCLINK_TO_DPEL = 39
        LR_MCLINK_TO_HOUSEHOLD_PEL = 40
        ZIP4_TO_ZIP4_PEARL = 41
        PLAINTEXT_EMAIL_TO_ISOTOPES_AND_HASHES_TO_ARL = 42
        MD5_EMAIL_TO_ARL = 43
        SHA1_EMAIL_TO_ARL = 44
        SHA256_EMAIL_TO_ARL = 45
        NAP_TO_ARL = 46
        PHONE_TO_ARL = 47
        ERL_TO_ARL = 48
        CLIENT_DCLINK_TO_ARL = 49
        LR_DCLINK_TO_ARL = 50
        VALUE_MAP = {1 => "PLAINTEXT_EMAIL_TO_MDOC", 2 => "CLIENT_PII_MDOC_TO_MDOC", 3 => "MD5_EMAIL_TO_MDOC", 4 => "SHA1_EMAIL_TO_MDOC", 5 => "SHA256_EMAIL_TO_MDOC", 6 => "NAP_TO_MDOC", 7 => "PHONE_TO_MDOC", 8 => "ERL_TO_MDOC", 9 => "PLAINTEXT_EMAIL_TO_ISOTOPES_AND_HASHES_TO_DDOC", 10 => "MD5_EMAIL_TO_DDOC", 11 => "SHA1_EMAIL_TO_DDOC", 12 => "SHA256_EMAIL_TO_DDOC", 13 => "PHONE_TO_DDOC", 14 => "ERL_TO_DDOC", 15 => "CLIENT_PII_DDOC_TO_DDOC", 16 => "ZIP4_TO_ZIP4_DDOC", 17 => "NAP_TO_NORMALIZED_DDOC", 18 => "PLAINTEXT_EMAIL_TO_ISOTOPES_TO_ENCRYPTED_HASHED_PII", 19 => "SHA256_EMAIL_TO_ENCRYPTED_HASHED_PII", 20 => "NAP_TO_ENCRYPTED_HASHED_PII", 21 => "PHONE_TO_ENCRYPTED_HASHED_PII", 22 => "PLAINTEXT_EMAIL_TO_MPEL", 23 => "CLIENT_MCLINK_TO_MPEL", 24 => "LR_MCLINK_TO_MPEL", 25 => "MD5_EMAIL_TO_MPEL", 26 => "SHA1_EMAIL_TO_MPEL", 27 => "SHA256_EMAIL_TO_MPEL", 28 => "NAP_TO_MPEL", 29 => "PHONE_TO_MPEL", 30 => "ERL_TO_MPEL", 31 => "PLAINTEXT_EMAIL_TO_ISOTOPES_AND_HASHES_TO_DPEL", 32 => "MD5_EMAIL_TO_DPEL", 33 => "SHA1_EMAIL_TO_DPEL", 34 => "SHA256_EMAIL_TO_DPEL", 35 => "NAP_TO_DPEL", 36 => "PHONE_TO_DPEL", 37 => "ERL_TO_DPEL", 38 => "CLIENT_DCLINK_TO_DPEL", 39 => "LR_DCLINK_TO_DPEL", 40 => "LR_MCLINK_TO_HOUSEHOLD_PEL", 41 => "ZIP4_TO_ZIP4_PEARL", 42 => "PLAINTEXT_EMAIL_TO_ISOTOPES_AND_HASHES_TO_ARL", 43 => "MD5_EMAIL_TO_ARL", 44 => "SHA1_EMAIL_TO_ARL", 45 => "SHA256_EMAIL_TO_ARL", 46 => "NAP_TO_ARL", 47 => "PHONE_TO_ARL", 48 => "ERL_TO_ARL", 49 => "CLIENT_DCLINK_TO_ARL", 50 => "LR_DCLINK_TO_ARL"}
        VALID_VALUES = Set.new([PLAINTEXT_EMAIL_TO_MDOC, CLIENT_PII_MDOC_TO_MDOC, MD5_EMAIL_TO_MDOC, SHA1_EMAIL_TO_MDOC, SHA256_EMAIL_TO_MDOC, NAP_TO_MDOC, PHONE_TO_MDOC, ERL_TO_MDOC, PLAINTEXT_EMAIL_TO_ISOTOPES_AND_HASHES_TO_DDOC, MD5_EMAIL_TO_DDOC, SHA1_EMAIL_TO_DDOC, SHA256_EMAIL_TO_DDOC, PHONE_TO_DDOC, ERL_TO_DDOC, CLIENT_PII_DDOC_TO_DDOC, ZIP4_TO_ZIP4_DDOC, NAP_TO_NORMALIZED_DDOC, PLAINTEXT_EMAIL_TO_ISOTOPES_TO_ENCRYPTED_HASHED_PII, SHA256_EMAIL_TO_ENCRYPTED_HASHED_PII, NAP_TO_ENCRYPTED_HASHED_PII, PHONE_TO_ENCRYPTED_HASHED_PII, PLAINTEXT_EMAIL_TO_MPEL, CLIENT_MCLINK_TO_MPEL, LR_MCLINK_TO_MPEL, MD5_EMAIL_TO_MPEL, SHA1_EMAIL_TO_MPEL, SHA256_EMAIL_TO_MPEL, NAP_TO_MPEL, PHONE_TO_MPEL, ERL_TO_MPEL, PLAINTEXT_EMAIL_TO_ISOTOPES_AND_HASHES_TO_DPEL, MD5_EMAIL_TO_DPEL, SHA1_EMAIL_TO_DPEL, SHA256_EMAIL_TO_DPEL, NAP_TO_DPEL, PHONE_TO_DPEL, ERL_TO_DPEL, CLIENT_DCLINK_TO_DPEL, LR_DCLINK_TO_DPEL, LR_MCLINK_TO_HOUSEHOLD_PEL, ZIP4_TO_ZIP4_PEARL, PLAINTEXT_EMAIL_TO_ISOTOPES_AND_HASHES_TO_ARL, MD5_EMAIL_TO_ARL, SHA1_EMAIL_TO_ARL, SHA256_EMAIL_TO_ARL, NAP_TO_ARL, PHONE_TO_ARL, ERL_TO_ARL, CLIENT_DCLINK_TO_ARL, LR_DCLINK_TO_ARL]).freeze
      end

      module TranslatorUseCase
        STANDARD = 1
        QUICK_ONBOARD = 2
        CUSTOM = 3
        STANDARD_PLUS_DOC_IDS = 4
        VALUE_MAP = {1 => "STANDARD", 2 => "QUICK_ONBOARD", 3 => "CUSTOM", 4 => "STANDARD_PLUS_DOC_IDS"}
        VALID_VALUES = Set.new([STANDARD, QUICK_ONBOARD, CUSTOM, STANDARD_PLUS_DOC_IDS]).freeze
      end

      module TranslatorOutputCount
        ZERO = 1
        ONE = 2
        MANY = 3
        VALUE_MAP = {1 => "ZERO", 2 => "ONE", 3 => "MANY"}
        VALID_VALUES = Set.new([ZERO, ONE, MANY]).freeze
      end

      module InputTranslatorMetricType
        DROPPED_UNCONFIGURED = 1
        DROPPED_UNSUPPORTED = 2
        CACHE_MISS = 3
        QUERY_MISS = 4
        VALUE_MAP = {1 => "DROPPED_UNCONFIGURED", 2 => "DROPPED_UNSUPPORTED", 3 => "CACHE_MISS", 4 => "QUERY_MISS"}
        VALID_VALUES = Set.new([DROPPED_UNCONFIGURED, DROPPED_UNSUPPORTED, CACHE_MISS, QUERY_MISS]).freeze
      end

      module OutputTranslatorMetricType
        OUTPUT = 1
        CACHE_HIT = 2
        QUERY_HIT = 3
        VALUE_MAP = {1 => "OUTPUT", 2 => "CACHE_HIT", 3 => "QUERY_HIT"}
        VALID_VALUES = Set.new([OUTPUT, CACHE_HIT, QUERY_HIT]).freeze
      end

      module RealTimeTranslatorMatching
        NONE = 1
        EMAIL_BASED_PEL_MERGING = 2
        VALUE_MAP = {1 => "NONE", 2 => "EMAIL_BASED_PEL_MERGING"}
        VALID_VALUES = Set.new([NONE, EMAIL_BASED_PEL_MERGING]).freeze
      end

      class OnboardingAnonymizationConfig; end

      class OnboardingPretranslationId < ::Thrift::Union; end

      class EmailPinToArlPelConfig; end

      class EmailPinToDpelMpelConfig; end

      class OnboardingAnonymizationOutput; end

      class OnlineMatchingAnonymizationConfig; end

      class OnlineMatchingAnonymizationOutput; end

      class AcxiomHhMappingAnonymizationOutput; end

      class CidPinAnonymizationConfig; end

      class ClinkToClinkAnonymizationConfig; end

      class MuidPinAnonymizationConfig; end

      class CidPinAnonymizationOutput; end

      class ClinkToClinkAnonymizationOutput; end

      class EmailPinToArlPelOutput; end

      class EmailPinToDpelMpelOutput; end

      class MuidPinAnonymizationOutput; end

      class PinToClinkAnonymizationConfig; end

      class PinToClinkAnonymizationOutput; end

      class IdOnlyImportAnonymizationConfig; end

      class IdOnlyImportAnonymizationOutput; end

      class AkArlToAkPelMappingConfig; end

      class AkArlToAkPelMappingOutput; end

      class OptOutAnonymizationConfig; end

      class OptOutAnonymizationOutput; end

      class FlexibleAnonymizationConfig; end

      class FlexibleAnonymizationOutput; end

      class TranslationConfig < ::Thrift::Union; end

      class TranslationRequestSuccess < ::Thrift::Union; end

      class TranslationRequestAccepted; end

      class TranslationRequestRejected; end

      class TranslationRequestResponse < ::Thrift::Union; end

      class TranslationRequestStatus < ::Thrift::Union; end

      class TranslationRequestPending; end

      class TranslationRequestInvalidRequest; end

      class TranslationRequestFailure < ::Thrift::Union; end

      class TranslationRequestStatusResponse < ::Thrift::Union; end

      class ParcMetadata; end

      class TranslatorSourceMetadata < ::Thrift::Union; end

      class BatchTranslatorOutput; end

      class BatchTranslatorConfig; end

      class TranslatorMetadata; end

      class TranslatorPiiRecord; end

      class TranslatorPiiRecordWithPiiType; end

      class TranslatorAnonRecord; end

      class BatchTranslatorAnonRecord; end

      class ClinkResolverConfig; end

      class DocResolverConfig; end

      class TranslatorContract; end

      class InputTranslatorMetric; end

      class OutputTranslatorMetric; end

      class TranslatorMetric < ::Thrift::Union; end

      class NewTranslatorStats; end

      class TranslatorStats; end

      class ClinkResolverOutput; end

      class DocResolverOutput; end

      class UnknownError; end

      class TooFewInputPins; end

      class TooFewInputRecords; end

      class UnsupportedTranslatorUseCase; end

      class NonEmptyInputGroup; end

      class UnsupportedPiiType; end

      class RealTimeTranslatorOutput; end

      class RealTimeTranslatorError < ::Thrift::Union; end

      class RealTimeTranslatorResponse < ::Thrift::Union; end

      class AnonymousIdentifierSet; end

      class IdlGraphUpdaterInput; end

      class IdlGraphUpdaterOutput; end

      class OnboardingAnonymizationConfig
        include ::Thrift::Struct, ::Thrift::Struct_Union
        IMPORT_RECORD_ID = 1
        AUDIENCE_ID = 2
        EOIRC_BDS_PATHS = 3

        FIELDS = {
          IMPORT_RECORD_ID => {:type => ::Thrift::Types::I64, :name => 'import_record_id'},
          AUDIENCE_ID => {:type => ::Thrift::Types::I64, :name => 'audience_id'},
          EOIRC_BDS_PATHS => {:type => ::Thrift::Types::SET, :name => 'eoirc_bds_paths', :element => {:type => ::Thrift::Types::STRING}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class OnboardingPretranslationId < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def arl(val)
            OnboardingPretranslationId.new(:arl, val)
          end

          def abilitec_id(val)
            OnboardingPretranslationId.new(:abilitec_id, val)
          end

          def sha256_pii(val)
            OnboardingPretranslationId.new(:sha256_pii, val)
          end
        end

        ARL = 1
        ABILITEC_ID = 2
        SHA256_PII = 3

        FIELDS = {
          ARL => {:type => ::Thrift::Types::STRUCT, :name => 'arl', :class => ::Liveramp::Abilitec::Arl, :optional => true},
          ABILITEC_ID => {:type => ::Thrift::Types::STRUCT, :name => 'abilitec_id', :class => ::Rapleaf::Types::NewPersonData::AbiliTecId, :optional => true},
          SHA256_PII => {:type => ::Thrift::Types::STRUCT, :name => 'sha256_pii', :class => ::Liveramp::Types::PiiIntegration::HPii, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class EmailPinToArlPelConfig
        include ::Thrift::Struct, ::Thrift::Struct_Union
        INPUT_BUCKET_PATH = 1
        CREATION_TIMESTAMP = 2
        OUTPUT_BUCKET_PATH = 3

        FIELDS = {
          INPUT_BUCKET_PATH => {:type => ::Thrift::Types::STRING, :name => 'input_bucket_path'},
          CREATION_TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'creation_timestamp'},
          OUTPUT_BUCKET_PATH => {:type => ::Thrift::Types::STRING, :name => 'output_bucket_path'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class EmailPinToDpelMpelConfig
        include ::Thrift::Struct, ::Thrift::Struct_Union
        INPUT_BUCKET_PATH = 1
        CREATION_TIMESTAMP = 2
        OUTPUT_BUCKET_PATH = 3

        FIELDS = {
          INPUT_BUCKET_PATH => {:type => ::Thrift::Types::STRING, :name => 'input_bucket_path'},
          CREATION_TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'creation_timestamp'},
          OUTPUT_BUCKET_PATH => {:type => ::Thrift::Types::STRING, :name => 'output_bucket_path'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class OnboardingAnonymizationOutput
        include ::Thrift::Struct, ::Thrift::Struct_Union
        BUCKET_PATH = 1

        FIELDS = {
          BUCKET_PATH => {:type => ::Thrift::Types::STRING, :name => 'bucket_path'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class OnlineMatchingAnonymizationConfig
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CACHE_DELTA_ID = 1

        FIELDS = {
          CACHE_DELTA_ID => {:type => ::Thrift::Types::I64, :name => 'cache_delta_id'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class OnlineMatchingAnonymizationOutput
        include ::Thrift::Struct, ::Thrift::Struct_Union
        BUCKET_PATH = 1

        FIELDS = {
          BUCKET_PATH => {:type => ::Thrift::Types::STRING, :name => 'bucket_path'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class AcxiomHhMappingAnonymizationOutput
        include ::Thrift::Struct, ::Thrift::Struct_Union
        BUCKET_PATH = 1

        FIELDS = {
          BUCKET_PATH => {:type => ::Thrift::Types::STRING, :name => 'bucket_path'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class CidPinAnonymizationConfig
        include ::Thrift::Struct, ::Thrift::Struct_Union
        IMPORT_RECORD_ID = 1
        AUDIENCE_ID = 2
        CID_PIN_IRC_PATHS = 3

        FIELDS = {
          IMPORT_RECORD_ID => {:type => ::Thrift::Types::I64, :name => 'import_record_id'},
          AUDIENCE_ID => {:type => ::Thrift::Types::I64, :name => 'audience_id'},
          CID_PIN_IRC_PATHS => {:type => ::Thrift::Types::SET, :name => 'cid_pin_irc_paths', :element => {:type => ::Thrift::Types::STRING}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ClinkToClinkAnonymizationConfig
        include ::Thrift::Struct, ::Thrift::Struct_Union
        INPUT_BUCKET_PATH = 1
        CREATION_TIMESTAMP = 2
        OUTPUT_BUCKET_PATH = 3

        FIELDS = {
          INPUT_BUCKET_PATH => {:type => ::Thrift::Types::STRING, :name => 'input_bucket_path'},
          CREATION_TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'creation_timestamp'},
          OUTPUT_BUCKET_PATH => {:type => ::Thrift::Types::STRING, :name => 'output_bucket_path'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class MuidPinAnonymizationConfig
        include ::Thrift::Struct, ::Thrift::Struct_Union
        IMPORT_RECORD_ID = 1
        AUDIENCE_ID = 2
        MUID_PIN_APPENDED_PATH = 3
        MUID_PIN_ORIGINAL_PATH = 4

        FIELDS = {
          IMPORT_RECORD_ID => {:type => ::Thrift::Types::I64, :name => 'import_record_id'},
          AUDIENCE_ID => {:type => ::Thrift::Types::I64, :name => 'audience_id'},
          MUID_PIN_APPENDED_PATH => {:type => ::Thrift::Types::STRING, :name => 'muid_pin_appended_path'},
          MUID_PIN_ORIGINAL_PATH => {:type => ::Thrift::Types::STRING, :name => 'muid_pin_original_path'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class CidPinAnonymizationOutput
        include ::Thrift::Struct, ::Thrift::Struct_Union
        BUCKET_PATH = 1

        FIELDS = {
          BUCKET_PATH => {:type => ::Thrift::Types::STRING, :name => 'bucket_path'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ClinkToClinkAnonymizationOutput
        include ::Thrift::Struct, ::Thrift::Struct_Union
        BUCKET_PATH = 1

        FIELDS = {
          BUCKET_PATH => {:type => ::Thrift::Types::STRING, :name => 'bucket_path'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class EmailPinToArlPelOutput
        include ::Thrift::Struct, ::Thrift::Struct_Union

        FIELDS = {

        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class EmailPinToDpelMpelOutput
        include ::Thrift::Struct, ::Thrift::Struct_Union

        FIELDS = {

        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class MuidPinAnonymizationOutput
        include ::Thrift::Struct, ::Thrift::Struct_Union
        BUCKET_PATH = 1

        FIELDS = {
          BUCKET_PATH => {:type => ::Thrift::Types::STRING, :name => 'bucket_path'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class PinToClinkAnonymizationConfig
        include ::Thrift::Struct, ::Thrift::Struct_Union
        BUCKET_PATHS = 1
        CREATION_TIMESTAMP = 2

        FIELDS = {
          BUCKET_PATHS => {:type => ::Thrift::Types::SET, :name => 'bucket_paths', :element => {:type => ::Thrift::Types::STRING}},
          CREATION_TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'creation_timestamp'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class PinToClinkAnonymizationOutput
        include ::Thrift::Struct, ::Thrift::Struct_Union
        BUCKET_PATH = 1

        FIELDS = {
          BUCKET_PATH => {:type => ::Thrift::Types::STRING, :name => 'bucket_path'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class IdOnlyImportAnonymizationConfig
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PARC_ID = 1
        APPENDED_RECORDS = 2
        ORIGINAL_RECORDS = 3

        FIELDS = {
          PARC_ID => {:type => ::Thrift::Types::I64, :name => 'parc_id'},
          APPENDED_RECORDS => {:type => ::Thrift::Types::STRING, :name => 'appended_records'},
          ORIGINAL_RECORDS => {:type => ::Thrift::Types::STRING, :name => 'original_records'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class IdOnlyImportAnonymizationOutput
        include ::Thrift::Struct, ::Thrift::Struct_Union
        BUCKET_PATH = 1

        FIELDS = {
          BUCKET_PATH => {:type => ::Thrift::Types::STRING, :name => 'bucket_path'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class AkArlToAkPelMappingConfig
        include ::Thrift::Struct, ::Thrift::Struct_Union
        IMPORT_PATHS = 1

        FIELDS = {
          IMPORT_PATHS => {:type => ::Thrift::Types::SET, :name => 'import_paths', :element => {:type => ::Thrift::Types::STRING}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class AkArlToAkPelMappingOutput
        include ::Thrift::Struct, ::Thrift::Struct_Union
        OUTPUT_PATH = 1

        FIELDS = {
          OUTPUT_PATH => {:type => ::Thrift::Types::STRING, :name => 'output_path'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class OptOutAnonymizationConfig
        include ::Thrift::Struct, ::Thrift::Struct_Union

        FIELDS = {

        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class OptOutAnonymizationOutput
        include ::Thrift::Struct, ::Thrift::Struct_Union

        FIELDS = {

        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class FlexibleAnonymizationConfig
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SERVILE_REQUEST_ID = 1

        FIELDS = {
          SERVILE_REQUEST_ID => {:type => ::Thrift::Types::I64, :name => 'servile_request_id'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class FlexibleAnonymizationOutput
        include ::Thrift::Struct, ::Thrift::Struct_Union

        FIELDS = {

        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class TranslationConfig < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def onboarding_anonymization_config(val)
            TranslationConfig.new(:onboarding_anonymization_config, val)
          end

          def online_matching_anonymization_config(val)
            TranslationConfig.new(:online_matching_anonymization_config, val)
          end

          def cid_pin_anonymization_config(val)
            TranslationConfig.new(:cid_pin_anonymization_config, val)
          end

          def pin_to_clink_anonymization_config(val)
            TranslationConfig.new(:pin_to_clink_anonymization_config, val)
          end

          def id_only_import_anonymization_config(val)
            TranslationConfig.new(:id_only_import_anonymization_config, val)
          end

          def opt_out_anonymization_config(val)
            TranslationConfig.new(:opt_out_anonymization_config, val)
          end

          def muid_pin_anonymization_config(val)
            TranslationConfig.new(:muid_pin_anonymization_config, val)
          end

          def clink_to_clink_anonymization_config(val)
            TranslationConfig.new(:clink_to_clink_anonymization_config, val)
          end

          def ak_arl_to_ak_pel_mapping_config(val)
            TranslationConfig.new(:ak_arl_to_ak_pel_mapping_config, val)
          end

          def email_pin_to_arl_pel_config(val)
            TranslationConfig.new(:email_pin_to_arl_pel_config, val)
          end

          def email_pin_to_dpel_mpel_config(val)
            TranslationConfig.new(:email_pin_to_dpel_mpel_config, val)
          end

          def flexible_anonymization_config(val)
            TranslationConfig.new(:flexible_anonymization_config, val)
          end
        end

        ONBOARDING_ANONYMIZATION_CONFIG = 1
        ONLINE_MATCHING_ANONYMIZATION_CONFIG = 2
        CID_PIN_ANONYMIZATION_CONFIG = 4
        PIN_TO_CLINK_ANONYMIZATION_CONFIG = 5
        ID_ONLY_IMPORT_ANONYMIZATION_CONFIG = 6
        OPT_OUT_ANONYMIZATION_CONFIG = 7
        MUID_PIN_ANONYMIZATION_CONFIG = 8
        CLINK_TO_CLINK_ANONYMIZATION_CONFIG = 9
        AK_ARL_TO_AK_PEL_MAPPING_CONFIG = 10
        EMAIL_PIN_TO_ARL_PEL_CONFIG = 11
        EMAIL_PIN_TO_DPEL_MPEL_CONFIG = 12
        FLEXIBLE_ANONYMIZATION_CONFIG = 13

        FIELDS = {
          ONBOARDING_ANONYMIZATION_CONFIG => {:type => ::Thrift::Types::STRUCT, :name => 'onboarding_anonymization_config', :class => ::Liveramp::OfflineMatching::TranslationZone::OnboardingAnonymizationConfig, :optional => true},
          ONLINE_MATCHING_ANONYMIZATION_CONFIG => {:type => ::Thrift::Types::STRUCT, :name => 'online_matching_anonymization_config', :class => ::Liveramp::OfflineMatching::TranslationZone::OnlineMatchingAnonymizationConfig, :optional => true},
          CID_PIN_ANONYMIZATION_CONFIG => {:type => ::Thrift::Types::STRUCT, :name => 'cid_pin_anonymization_config', :class => ::Liveramp::OfflineMatching::TranslationZone::CidPinAnonymizationConfig, :optional => true},
          PIN_TO_CLINK_ANONYMIZATION_CONFIG => {:type => ::Thrift::Types::STRUCT, :name => 'pin_to_clink_anonymization_config', :class => ::Liveramp::OfflineMatching::TranslationZone::PinToClinkAnonymizationConfig, :optional => true},
          ID_ONLY_IMPORT_ANONYMIZATION_CONFIG => {:type => ::Thrift::Types::STRUCT, :name => 'id_only_import_anonymization_config', :class => ::Liveramp::OfflineMatching::TranslationZone::IdOnlyImportAnonymizationConfig, :optional => true},
          OPT_OUT_ANONYMIZATION_CONFIG => {:type => ::Thrift::Types::STRUCT, :name => 'opt_out_anonymization_config', :class => ::Liveramp::OfflineMatching::TranslationZone::OptOutAnonymizationConfig, :optional => true},
          MUID_PIN_ANONYMIZATION_CONFIG => {:type => ::Thrift::Types::STRUCT, :name => 'muid_pin_anonymization_config', :class => ::Liveramp::OfflineMatching::TranslationZone::MuidPinAnonymizationConfig, :optional => true},
          CLINK_TO_CLINK_ANONYMIZATION_CONFIG => {:type => ::Thrift::Types::STRUCT, :name => 'clink_to_clink_anonymization_config', :class => ::Liveramp::OfflineMatching::TranslationZone::ClinkToClinkAnonymizationConfig, :optional => true},
          AK_ARL_TO_AK_PEL_MAPPING_CONFIG => {:type => ::Thrift::Types::STRUCT, :name => 'ak_arl_to_ak_pel_mapping_config', :class => ::Liveramp::OfflineMatching::TranslationZone::AkArlToAkPelMappingConfig, :optional => true},
          EMAIL_PIN_TO_ARL_PEL_CONFIG => {:type => ::Thrift::Types::STRUCT, :name => 'email_pin_to_arl_pel_config', :class => ::Liveramp::OfflineMatching::TranslationZone::EmailPinToArlPelConfig, :optional => true},
          EMAIL_PIN_TO_DPEL_MPEL_CONFIG => {:type => ::Thrift::Types::STRUCT, :name => 'email_pin_to_dpel_mpel_config', :class => ::Liveramp::OfflineMatching::TranslationZone::EmailPinToDpelMpelConfig, :optional => true},
          FLEXIBLE_ANONYMIZATION_CONFIG => {:type => ::Thrift::Types::STRUCT, :name => 'flexible_anonymization_config', :class => ::Liveramp::OfflineMatching::TranslationZone::FlexibleAnonymizationConfig, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class TranslationRequestSuccess < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def onboarding_anonymization_output(val)
            TranslationRequestSuccess.new(:onboarding_anonymization_output, val)
          end

          def online_matching_anonymization_output(val)
            TranslationRequestSuccess.new(:online_matching_anonymization_output, val)
          end

          def acxiom_hh_mapping_anonymization_output(val)
            TranslationRequestSuccess.new(:acxiom_hh_mapping_anonymization_output, val)
          end

          def cid_pin_anonymization_output(val)
            TranslationRequestSuccess.new(:cid_pin_anonymization_output, val)
          end

          def pin_to_clink_anonymization_output(val)
            TranslationRequestSuccess.new(:pin_to_clink_anonymization_output, val)
          end

          def id_only_import_anonymization_output(val)
            TranslationRequestSuccess.new(:id_only_import_anonymization_output, val)
          end

          def opt_out_anonymization_output(val)
            TranslationRequestSuccess.new(:opt_out_anonymization_output, val)
          end

          def muid_pin_anonymization_output(val)
            TranslationRequestSuccess.new(:muid_pin_anonymization_output, val)
          end

          def clink_to_clink_anonymization_output(val)
            TranslationRequestSuccess.new(:clink_to_clink_anonymization_output, val)
          end

          def ak_arl_to_ak_pel_mapping_output(val)
            TranslationRequestSuccess.new(:ak_arl_to_ak_pel_mapping_output, val)
          end

          def email_pin_to_arl_pel_output(val)
            TranslationRequestSuccess.new(:email_pin_to_arl_pel_output, val)
          end

          def email_pin_to_dpel_mpel_output(val)
            TranslationRequestSuccess.new(:email_pin_to_dpel_mpel_output, val)
          end

          def flexible_anonymization_output(val)
            TranslationRequestSuccess.new(:flexible_anonymization_output, val)
          end
        end

        ONBOARDING_ANONYMIZATION_OUTPUT = 1
        ONLINE_MATCHING_ANONYMIZATION_OUTPUT = 2
        ACXIOM_HH_MAPPING_ANONYMIZATION_OUTPUT = 3
        CID_PIN_ANONYMIZATION_OUTPUT = 4
        PIN_TO_CLINK_ANONYMIZATION_OUTPUT = 5
        ID_ONLY_IMPORT_ANONYMIZATION_OUTPUT = 6
        OPT_OUT_ANONYMIZATION_OUTPUT = 7
        MUID_PIN_ANONYMIZATION_OUTPUT = 8
        CLINK_TO_CLINK_ANONYMIZATION_OUTPUT = 9
        AK_ARL_TO_AK_PEL_MAPPING_OUTPUT = 10
        EMAIL_PIN_TO_ARL_PEL_OUTPUT = 11
        EMAIL_PIN_TO_DPEL_MPEL_OUTPUT = 12
        FLEXIBLE_ANONYMIZATION_OUTPUT = 13

        FIELDS = {
          ONBOARDING_ANONYMIZATION_OUTPUT => {:type => ::Thrift::Types::STRUCT, :name => 'onboarding_anonymization_output', :class => ::Liveramp::OfflineMatching::TranslationZone::OnboardingAnonymizationOutput, :optional => true},
          ONLINE_MATCHING_ANONYMIZATION_OUTPUT => {:type => ::Thrift::Types::STRUCT, :name => 'online_matching_anonymization_output', :class => ::Liveramp::OfflineMatching::TranslationZone::OnlineMatchingAnonymizationOutput, :optional => true},
          ACXIOM_HH_MAPPING_ANONYMIZATION_OUTPUT => {:type => ::Thrift::Types::STRUCT, :name => 'acxiom_hh_mapping_anonymization_output', :class => ::Liveramp::OfflineMatching::TranslationZone::AcxiomHhMappingAnonymizationOutput, :optional => true},
          CID_PIN_ANONYMIZATION_OUTPUT => {:type => ::Thrift::Types::STRUCT, :name => 'cid_pin_anonymization_output', :class => ::Liveramp::OfflineMatching::TranslationZone::CidPinAnonymizationOutput, :optional => true},
          PIN_TO_CLINK_ANONYMIZATION_OUTPUT => {:type => ::Thrift::Types::STRUCT, :name => 'pin_to_clink_anonymization_output', :class => ::Liveramp::OfflineMatching::TranslationZone::PinToClinkAnonymizationOutput, :optional => true},
          ID_ONLY_IMPORT_ANONYMIZATION_OUTPUT => {:type => ::Thrift::Types::STRUCT, :name => 'id_only_import_anonymization_output', :class => ::Liveramp::OfflineMatching::TranslationZone::IdOnlyImportAnonymizationOutput, :optional => true},
          OPT_OUT_ANONYMIZATION_OUTPUT => {:type => ::Thrift::Types::STRUCT, :name => 'opt_out_anonymization_output', :class => ::Liveramp::OfflineMatching::TranslationZone::OptOutAnonymizationOutput, :optional => true},
          MUID_PIN_ANONYMIZATION_OUTPUT => {:type => ::Thrift::Types::STRUCT, :name => 'muid_pin_anonymization_output', :class => ::Liveramp::OfflineMatching::TranslationZone::MuidPinAnonymizationOutput, :optional => true},
          CLINK_TO_CLINK_ANONYMIZATION_OUTPUT => {:type => ::Thrift::Types::STRUCT, :name => 'clink_to_clink_anonymization_output', :class => ::Liveramp::OfflineMatching::TranslationZone::ClinkToClinkAnonymizationOutput, :optional => true},
          AK_ARL_TO_AK_PEL_MAPPING_OUTPUT => {:type => ::Thrift::Types::STRUCT, :name => 'ak_arl_to_ak_pel_mapping_output', :class => ::Liveramp::OfflineMatching::TranslationZone::AkArlToAkPelMappingOutput, :optional => true},
          EMAIL_PIN_TO_ARL_PEL_OUTPUT => {:type => ::Thrift::Types::STRUCT, :name => 'email_pin_to_arl_pel_output', :class => ::Liveramp::OfflineMatching::TranslationZone::EmailPinToArlPelOutput, :optional => true},
          EMAIL_PIN_TO_DPEL_MPEL_OUTPUT => {:type => ::Thrift::Types::STRUCT, :name => 'email_pin_to_dpel_mpel_output', :class => ::Liveramp::OfflineMatching::TranslationZone::EmailPinToDpelMpelOutput, :optional => true},
          FLEXIBLE_ANONYMIZATION_OUTPUT => {:type => ::Thrift::Types::STRUCT, :name => 'flexible_anonymization_output', :class => ::Liveramp::OfflineMatching::TranslationZone::FlexibleAnonymizationOutput, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class TranslationRequestAccepted
        include ::Thrift::Struct, ::Thrift::Struct_Union
        REQUEST_ID = 1

        FIELDS = {
          REQUEST_ID => {:type => ::Thrift::Types::I64, :name => 'request_id'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class TranslationRequestRejected
        include ::Thrift::Struct, ::Thrift::Struct_Union
        REASON = 1

        FIELDS = {
          REASON => {:type => ::Thrift::Types::STRING, :name => 'reason'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class TranslationRequestResponse < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def accepted(val)
            TranslationRequestResponse.new(:accepted, val)
          end

          def rejected(val)
            TranslationRequestResponse.new(:rejected, val)
          end
        end

        ACCEPTED = 1
        REJECTED = 2

        FIELDS = {
          ACCEPTED => {:type => ::Thrift::Types::STRUCT, :name => 'accepted', :class => ::Liveramp::OfflineMatching::TranslationZone::TranslationRequestAccepted, :optional => true},
          REJECTED => {:type => ::Thrift::Types::STRUCT, :name => 'rejected', :class => ::Liveramp::OfflineMatching::TranslationZone::TranslationRequestRejected, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class TranslationRequestStatus < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
        end


        FIELDS = {

        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class TranslationRequestPending
        include ::Thrift::Struct, ::Thrift::Struct_Union

        FIELDS = {

        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class TranslationRequestInvalidRequest
        include ::Thrift::Struct, ::Thrift::Struct_Union

        FIELDS = {

        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class TranslationRequestFailure < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def failure_message(val)
            TranslationRequestFailure.new(:failure_message, val)
          end
        end

        FAILURE_MESSAGE = 1

        FIELDS = {
          FAILURE_MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'failure_message', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class TranslationRequestStatusResponse < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def success(val)
            TranslationRequestStatusResponse.new(:success, val)
          end

          def pending(val)
            TranslationRequestStatusResponse.new(:pending, val)
          end

          def invalid(val)
            TranslationRequestStatusResponse.new(:invalid, val)
          end

          def failure(val)
            TranslationRequestStatusResponse.new(:failure, val)
          end
        end

        SUCCESS = 1
        PENDING = 2
        INVALID = 3
        FAILURE = 4

        FIELDS = {
          SUCCESS => {:type => ::Thrift::Types::STRUCT, :name => 'success', :class => ::Liveramp::OfflineMatching::TranslationZone::TranslationRequestSuccess, :optional => true},
          PENDING => {:type => ::Thrift::Types::STRUCT, :name => 'pending', :class => ::Liveramp::OfflineMatching::TranslationZone::TranslationRequestPending, :optional => true},
          INVALID => {:type => ::Thrift::Types::STRUCT, :name => 'invalid', :class => ::Liveramp::OfflineMatching::TranslationZone::TranslationRequestInvalidRequest, :optional => true},
          FAILURE => {:type => ::Thrift::Types::STRUCT, :name => 'failure', :class => ::Liveramp::OfflineMatching::TranslationZone::TranslationRequestFailure, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class ParcMetadata
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ROW = 1
        COLUMN_NAME = 2

        FIELDS = {
          ROW => {:type => ::Thrift::Types::I64, :name => 'row'},
          COLUMN_NAME => {:type => ::Thrift::Types::STRING, :name => 'column_name'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class TranslatorSourceMetadata < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def no_metadata(val)
            TranslatorSourceMetadata.new(:no_metadata, val)
          end

          def parc_metadata(val)
            TranslatorSourceMetadata.new(:parc_metadata, val)
          end
        end

        NO_METADATA = 1
        PARC_METADATA = 2

        FIELDS = {
          NO_METADATA => {:type => ::Thrift::Types::STRUCT, :name => 'no_metadata', :class => ::Liveramp::Util::NoValue, :optional => true},
          PARC_METADATA => {:type => ::Thrift::Types::STRUCT, :name => 'parc_metadata', :class => ::Liveramp::OfflineMatching::TranslationZone::ParcMetadata, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class BatchTranslatorOutput
        include ::Thrift::Struct, ::Thrift::Struct_Union
        OUTPUT_PATH = 1

        FIELDS = {
          OUTPUT_PATH => {:type => ::Thrift::Types::STRING, :name => 'output_path'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class BatchTranslatorConfig
        include ::Thrift::Struct, ::Thrift::Struct_Union
        USE_CASE = 1
        CUSTOM_FUNCTIONS = 2
        PII_PATHS = 3

        FIELDS = {
          USE_CASE => {:type => ::Thrift::Types::I32, :name => 'use_case', :enum_class => ::Liveramp::OfflineMatching::TranslationZone::TranslatorUseCase},
          CUSTOM_FUNCTIONS => {:type => ::Thrift::Types::SET, :name => 'custom_functions', :element => {:type => ::Thrift::Types::I32, :enum_class => ::Liveramp::OfflineMatching::TranslationZone::TranslatorFunction}, :optional => true},
          PII_PATHS => {:type => ::Thrift::Types::SET, :name => 'pii_paths', :element => {:type => ::Thrift::Types::STRING}}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @use_case.nil? || ::Liveramp::OfflineMatching::TranslationZone::TranslatorUseCase::VALID_VALUES.include?(@use_case)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field use_case!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class TranslatorMetadata
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SOURCE_PII_TYPE = 1
        METADATA = 2

        FIELDS = {
          SOURCE_PII_TYPE => {:type => ::Thrift::Types::I32, :name => 'source_pii_type', :enum_class => ::Liveramp::Identity::TranslatorEnums::TranslatorPiiType},
          METADATA => {:type => ::Thrift::Types::STRUCT, :name => 'metadata', :class => ::Liveramp::DocIds::DocMetadata, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @source_pii_type.nil? || ::Liveramp::Identity::TranslatorEnums::TranslatorPiiType::VALID_VALUES.include?(@source_pii_type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field source_pii_type!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class TranslatorPiiRecord
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SOURCE_METADATA = 1
        ID = 2

        FIELDS = {
          SOURCE_METADATA => {:type => ::Thrift::Types::STRUCT, :name => 'source_metadata', :class => ::Liveramp::OfflineMatching::TranslationZone::TranslatorSourceMetadata},
          ID => {:type => ::Thrift::Types::STRUCT, :name => 'id', :class => ::Rapleaf::Types::NewPersonData::PIN}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class TranslatorPiiRecordWithPiiType
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SOURCE_METADATA = 1
        ID = 2
        PII_TYPE = 3

        FIELDS = {
          SOURCE_METADATA => {:type => ::Thrift::Types::STRUCT, :name => 'source_metadata', :class => ::Liveramp::OfflineMatching::TranslationZone::TranslatorSourceMetadata},
          ID => {:type => ::Thrift::Types::STRUCT, :name => 'id', :class => ::Rapleaf::Types::NewPersonData::PIN},
          PII_TYPE => {:type => ::Thrift::Types::I32, :name => 'pii_type', :enum_class => ::Liveramp::Identity::TranslatorEnums::TranslatorPiiType}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @pii_type.nil? || ::Liveramp::Identity::TranslatorEnums::TranslatorPiiType::VALID_VALUES.include?(@pii_type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field pii_type!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class TranslatorAnonRecord
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SOURCE_METADATA = 1
        ID = 2
        ID_METADATA = 3

        FIELDS = {
          SOURCE_METADATA => {:type => ::Thrift::Types::STRUCT, :name => 'source_metadata', :class => ::Liveramp::OfflineMatching::TranslationZone::TranslatorSourceMetadata},
          ID => {:type => ::Thrift::Types::STRUCT, :name => 'id', :class => ::Liveramp::Types::Bang::AnonymousIdentifier},
          ID_METADATA => {:type => ::Thrift::Types::STRUCT, :name => 'id_metadata', :class => ::Liveramp::OfflineMatching::TranslationZone::TranslatorMetadata}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class BatchTranslatorAnonRecord
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SOURCE_METADATA = 1
        ID_AND_METADATA = 2

        FIELDS = {
          SOURCE_METADATA => {:type => ::Thrift::Types::STRUCT, :name => 'source_metadata', :class => ::Liveramp::OfflineMatching::TranslationZone::TranslatorSourceMetadata},
          ID_AND_METADATA => {:type => ::Thrift::Types::STRUCT, :name => 'id_and_metadata', :class => ::Liveramp::Types::Bang::IdAndMetadata}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ClinkResolverConfig
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PII_PATHS = 1

        FIELDS = {
          PII_PATHS => {:type => ::Thrift::Types::SET, :name => 'pii_paths', :element => {:type => ::Thrift::Types::STRING}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class DocResolverConfig
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PII_PATHS = 1

        FIELDS = {
          PII_PATHS => {:type => ::Thrift::Types::SET, :name => 'pii_paths', :element => {:type => ::Thrift::Types::STRING}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class TranslatorContract
        include ::Thrift::Struct, ::Thrift::Struct_Union
        TRANSLATOR_FUNCTION = 1
        INPUT_PII_TYPE_TYPE = 2
        OUTPUT_ANON_TYPE = 3
        ALLOWED_NUMBER_OF_OUTPUTS = 4

        FIELDS = {
          TRANSLATOR_FUNCTION => {:type => ::Thrift::Types::I32, :name => 'translator_function', :enum_class => ::Liveramp::OfflineMatching::TranslationZone::TranslatorFunction},
          INPUT_PII_TYPE_TYPE => {:type => ::Thrift::Types::I32, :name => 'input_pii_type_type', :enum_class => ::Liveramp::Identity::TranslatorEnums::TranslatorPiiType},
          OUTPUT_ANON_TYPE => {:type => ::Thrift::Types::I32, :name => 'output_anon_type', :enum_class => ::Liveramp::OfflineMatching::TranslationZone::TranslatorOutputType},
          ALLOWED_NUMBER_OF_OUTPUTS => {:type => ::Thrift::Types::SET, :name => 'allowed_number_of_outputs', :element => {:type => ::Thrift::Types::I32, :enum_class => ::Liveramp::OfflineMatching::TranslationZone::TranslatorOutputCount}}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @translator_function.nil? || ::Liveramp::OfflineMatching::TranslationZone::TranslatorFunction::VALID_VALUES.include?(@translator_function)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field translator_function!')
          end
          unless @input_pii_type_type.nil? || ::Liveramp::Identity::TranslatorEnums::TranslatorPiiType::VALID_VALUES.include?(@input_pii_type_type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field input_pii_type_type!')
          end
          unless @output_anon_type.nil? || ::Liveramp::OfflineMatching::TranslationZone::TranslatorOutputType::VALID_VALUES.include?(@output_anon_type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field output_anon_type!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class InputTranslatorMetric
        include ::Thrift::Struct, ::Thrift::Struct_Union
        INPUT_METRIC_TYPE = 1
        INPUT_PII_TYPE = 2

        FIELDS = {
          INPUT_METRIC_TYPE => {:type => ::Thrift::Types::I32, :name => 'input_metric_type', :enum_class => ::Liveramp::OfflineMatching::TranslationZone::InputTranslatorMetricType},
          INPUT_PII_TYPE => {:type => ::Thrift::Types::I32, :name => 'input_pii_type', :enum_class => ::Liveramp::Identity::TranslatorEnums::TranslatorPiiType}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @input_metric_type.nil? || ::Liveramp::OfflineMatching::TranslationZone::InputTranslatorMetricType::VALID_VALUES.include?(@input_metric_type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field input_metric_type!')
          end
          unless @input_pii_type.nil? || ::Liveramp::Identity::TranslatorEnums::TranslatorPiiType::VALID_VALUES.include?(@input_pii_type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field input_pii_type!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class OutputTranslatorMetric
        include ::Thrift::Struct, ::Thrift::Struct_Union
        OUTPUT_METRIC_TYPE = 1
        INPUT_PII_TYPE = 2
        OUTPUT_TYPE = 3

        FIELDS = {
          OUTPUT_METRIC_TYPE => {:type => ::Thrift::Types::I32, :name => 'output_metric_type', :enum_class => ::Liveramp::OfflineMatching::TranslationZone::OutputTranslatorMetricType},
          INPUT_PII_TYPE => {:type => ::Thrift::Types::I32, :name => 'input_pii_type', :enum_class => ::Liveramp::Identity::TranslatorEnums::TranslatorPiiType},
          OUTPUT_TYPE => {:type => ::Thrift::Types::I32, :name => 'output_type', :enum_class => ::Liveramp::OfflineMatching::TranslationZone::TranslatorOutputType}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @output_metric_type.nil? || ::Liveramp::OfflineMatching::TranslationZone::OutputTranslatorMetricType::VALID_VALUES.include?(@output_metric_type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field output_metric_type!')
          end
          unless @input_pii_type.nil? || ::Liveramp::Identity::TranslatorEnums::TranslatorPiiType::VALID_VALUES.include?(@input_pii_type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field input_pii_type!')
          end
          unless @output_type.nil? || ::Liveramp::OfflineMatching::TranslationZone::TranslatorOutputType::VALID_VALUES.include?(@output_type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field output_type!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class TranslatorMetric < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def input_metric(val)
            TranslatorMetric.new(:input_metric, val)
          end

          def output_metric(val)
            TranslatorMetric.new(:output_metric, val)
          end
        end

        INPUT_METRIC = 1
        OUTPUT_METRIC = 2

        FIELDS = {
          INPUT_METRIC => {:type => ::Thrift::Types::STRUCT, :name => 'input_metric', :class => ::Liveramp::OfflineMatching::TranslationZone::InputTranslatorMetric, :optional => true},
          OUTPUT_METRIC => {:type => ::Thrift::Types::STRUCT, :name => 'output_metric', :class => ::Liveramp::OfflineMatching::TranslationZone::OutputTranslatorMetric, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class NewTranslatorStats
        include ::Thrift::Struct, ::Thrift::Struct_Union
        METRICS = 1

        FIELDS = {
          METRICS => {:type => ::Thrift::Types::MAP, :name => 'metrics', :key => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::OfflineMatching::TranslationZone::TranslatorMetric}, :value => {:type => ::Thrift::Types::I64}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class TranslatorStats
        include ::Thrift::Struct, ::Thrift::Struct_Union
        INPUT_TOTAL_COUNTS = 1
        INPUT_UNCONFIGURED_COUNTS = 2
        INPUT_UNSUPPORTED_COUNTS = 3
        FUNCTION_INPUT_COUNTS = 4
        FUNCTION_OUTPUT_COUNTS = 5
        CUSTOM_COUNTS = 6

        FIELDS = {
          INPUT_TOTAL_COUNTS => {:type => ::Thrift::Types::MAP, :name => 'input_total_counts', :key => {:type => ::Thrift::Types::I32, :enum_class => ::Liveramp::Identity::TranslatorEnums::TranslatorPiiType}, :value => {:type => ::Thrift::Types::I64}},
          INPUT_UNCONFIGURED_COUNTS => {:type => ::Thrift::Types::MAP, :name => 'input_unconfigured_counts', :key => {:type => ::Thrift::Types::I32, :enum_class => ::Liveramp::Identity::TranslatorEnums::TranslatorPiiType}, :value => {:type => ::Thrift::Types::I64}},
          INPUT_UNSUPPORTED_COUNTS => {:type => ::Thrift::Types::MAP, :name => 'input_unsupported_counts', :key => {:type => ::Thrift::Types::I32, :enum_class => ::Liveramp::Identity::TranslatorEnums::TranslatorPiiType}, :value => {:type => ::Thrift::Types::I64}},
          FUNCTION_INPUT_COUNTS => {:type => ::Thrift::Types::MAP, :name => 'function_input_counts', :key => {:type => ::Thrift::Types::I32, :enum_class => ::Liveramp::OfflineMatching::TranslationZone::TranslatorFunction}, :value => {:type => ::Thrift::Types::MAP, :key => {:type => ::Thrift::Types::I32, :enum_class => ::Liveramp::Identity::TranslatorEnums::TranslatorPiiType}, :value => {:type => ::Thrift::Types::I64}}},
          FUNCTION_OUTPUT_COUNTS => {:type => ::Thrift::Types::MAP, :name => 'function_output_counts', :key => {:type => ::Thrift::Types::I32, :enum_class => ::Liveramp::OfflineMatching::TranslationZone::TranslatorFunction}, :value => {:type => ::Thrift::Types::MAP, :key => {:type => ::Thrift::Types::I32, :enum_class => ::Liveramp::OfflineMatching::TranslationZone::TranslatorOutputType}, :value => {:type => ::Thrift::Types::I64}}},
          CUSTOM_COUNTS => {:type => ::Thrift::Types::MAP, :name => 'custom_counts', :key => {:type => ::Thrift::Types::I32, :enum_class => ::Liveramp::OfflineMatching::TranslationZone::TranslatorFunction}, :value => {:type => ::Thrift::Types::MAP, :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::I64}}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ClinkResolverOutput
        include ::Thrift::Struct, ::Thrift::Struct_Union
        OUTPUT_PATH = 1
        STATS = 2

        FIELDS = {
          OUTPUT_PATH => {:type => ::Thrift::Types::STRING, :name => 'output_path'},
          STATS => {:type => ::Thrift::Types::STRUCT, :name => 'stats', :class => ::Liveramp::OfflineMatching::TranslationZone::TranslatorStats}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class DocResolverOutput
        include ::Thrift::Struct, ::Thrift::Struct_Union
        OUTPUT_PATH = 1
        STATS = 2

        FIELDS = {
          OUTPUT_PATH => {:type => ::Thrift::Types::STRING, :name => 'output_path'},
          STATS => {:type => ::Thrift::Types::STRUCT, :name => 'stats', :class => ::Liveramp::OfflineMatching::TranslationZone::TranslatorStats}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class UnknownError
        include ::Thrift::Struct, ::Thrift::Struct_Union
        EXCEPTION_INFO = 1

        FIELDS = {
          EXCEPTION_INFO => {:type => ::Thrift::Types::STRING, :name => 'exception_info'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class TooFewInputPins
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PIN_COUNT = 1

        FIELDS = {
          PIN_COUNT => {:type => ::Thrift::Types::I64, :name => 'pin_count'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class TooFewInputRecords
        include ::Thrift::Struct, ::Thrift::Struct_Union
        RECORD_COUNT = 1

        FIELDS = {
          RECORD_COUNT => {:type => ::Thrift::Types::I64, :name => 'record_count'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class UnsupportedTranslatorUseCase
        include ::Thrift::Struct, ::Thrift::Struct_Union
        TRANSLATOR_USE_CASE = 1

        FIELDS = {
          TRANSLATOR_USE_CASE => {:type => ::Thrift::Types::I32, :name => 'translator_use_case', :enum_class => ::Liveramp::OfflineMatching::TranslationZone::TranslatorUseCase}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @translator_use_case.nil? || ::Liveramp::OfflineMatching::TranslationZone::TranslatorUseCase::VALID_VALUES.include?(@translator_use_case)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field translator_use_case!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class NonEmptyInputGroup
        include ::Thrift::Struct, ::Thrift::Struct_Union
        EXAMPLE_INPUT_GROUP = 1

        FIELDS = {
          EXAMPLE_INPUT_GROUP => {:type => ::Thrift::Types::STRUCT, :name => 'example_input_group', :class => ::Liveramp::OfflineMatching::TranslationZone::TranslatorSourceMetadata}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class UnsupportedPiiType
        include ::Thrift::Struct, ::Thrift::Struct_Union
        EXAMPLE_UNSUPPORTED_PII_TYPE = 1

        FIELDS = {
          EXAMPLE_UNSUPPORTED_PII_TYPE => {:type => ::Thrift::Types::I32, :name => 'example_unsupported_pii_type', :enum_class => ::Liveramp::Identity::TranslatorEnums::TranslatorPiiType}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @example_unsupported_pii_type.nil? || ::Liveramp::Identity::TranslatorEnums::TranslatorPiiType::VALID_VALUES.include?(@example_unsupported_pii_type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field example_unsupported_pii_type!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class RealTimeTranslatorOutput
        include ::Thrift::Struct, ::Thrift::Struct_Union
        OUTPUT_RECORDS = 1
        STATS = 2

        FIELDS = {
          OUTPUT_RECORDS => {:type => ::Thrift::Types::LIST, :name => 'output_records', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::OfflineMatching::TranslationZone::TranslatorAnonRecord}},
          STATS => {:type => ::Thrift::Types::STRUCT, :name => 'stats', :class => ::Liveramp::OfflineMatching::TranslationZone::TranslatorStats}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class RealTimeTranslatorError < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def unknown_error(val)
            RealTimeTranslatorError.new(:unknown_error, val)
          end

          def too_few_input_pins(val)
            RealTimeTranslatorError.new(:too_few_input_pins, val)
          end

          def unsupported_translator_use_case(val)
            RealTimeTranslatorError.new(:unsupported_translator_use_case, val)
          end

          def non_empty_input_group(val)
            RealTimeTranslatorError.new(:non_empty_input_group, val)
          end

          def unsupported_pii_type(val)
            RealTimeTranslatorError.new(:unsupported_pii_type, val)
          end
        end

        UNKNOWN_ERROR = 1
        TOO_FEW_INPUT_PINS = 2
        UNSUPPORTED_TRANSLATOR_USE_CASE = 3
        NON_EMPTY_INPUT_GROUP = 4
        UNSUPPORTED_PII_TYPE = 5

        FIELDS = {
          UNKNOWN_ERROR => {:type => ::Thrift::Types::STRUCT, :name => 'unknown_error', :class => ::Liveramp::OfflineMatching::TranslationZone::UnknownError, :optional => true},
          TOO_FEW_INPUT_PINS => {:type => ::Thrift::Types::STRUCT, :name => 'too_few_input_pins', :class => ::Liveramp::OfflineMatching::TranslationZone::TooFewInputPins, :optional => true},
          UNSUPPORTED_TRANSLATOR_USE_CASE => {:type => ::Thrift::Types::STRUCT, :name => 'unsupported_translator_use_case', :class => ::Liveramp::OfflineMatching::TranslationZone::UnsupportedTranslatorUseCase, :optional => true},
          NON_EMPTY_INPUT_GROUP => {:type => ::Thrift::Types::STRUCT, :name => 'non_empty_input_group', :class => ::Liveramp::OfflineMatching::TranslationZone::NonEmptyInputGroup, :optional => true},
          UNSUPPORTED_PII_TYPE => {:type => ::Thrift::Types::STRUCT, :name => 'unsupported_pii_type', :class => ::Liveramp::OfflineMatching::TranslationZone::UnsupportedPiiType, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class RealTimeTranslatorResponse < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def success(val)
            RealTimeTranslatorResponse.new(:success, val)
          end

          def error(val)
            RealTimeTranslatorResponse.new(:error, val)
          end
        end

        SUCCESS = 1
        ERROR = 2

        FIELDS = {
          SUCCESS => {:type => ::Thrift::Types::STRUCT, :name => 'success', :class => ::Liveramp::OfflineMatching::TranslationZone::RealTimeTranslatorOutput, :optional => true},
          ERROR => {:type => ::Thrift::Types::STRUCT, :name => 'error', :class => ::Liveramp::OfflineMatching::TranslationZone::RealTimeTranslatorError, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class AnonymousIdentifierSet
        include ::Thrift::Struct, ::Thrift::Struct_Union
        IDS = 1

        FIELDS = {
          IDS => {:type => ::Thrift::Types::SET, :name => 'ids', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::Bang::AnonymousIdentifier}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class IdlGraphUpdaterInput
        include ::Thrift::Struct, ::Thrift::Struct_Union
        EMAIL_PATH = 1
        PHONE_PATH = 2
        WATERFALL_PATH = 3

        FIELDS = {
          EMAIL_PATH => {:type => ::Thrift::Types::STRING, :name => 'email_path'},
          PHONE_PATH => {:type => ::Thrift::Types::STRING, :name => 'phone_path'},
          WATERFALL_PATH => {:type => ::Thrift::Types::STRING, :name => 'waterfall_path'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class IdlGraphUpdaterOutput
        include ::Thrift::Struct, ::Thrift::Struct_Union
        MESSAGE = 1

        FIELDS = {
          MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

    end
  end
end
