#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'
require File.join File.dirname(__FILE__), 'parc_types'
require File.join File.dirname(__FILE__), 'importer_service_types'
require File.join File.dirname(__FILE__), 'audience_types'
require File.join File.dirname(__FILE__), 'ui_common_types'
require File.join File.dirname(__FILE__), 'mobile_types'
require File.join File.dirname(__FILE__), 's2s_integrations_types'
require File.join File.dirname(__FILE__), 'input_file_formats_types'
require File.join File.dirname(__FILE__), 'util_types'
require File.join File.dirname(__FILE__), 'ingestion_identifier_configuration_types'


module Liveramp
  module Types
    module ParcService
      module ParcAttributeDataType
        STRING = 1
        NUMERIC = 2
        VALUE_MAP = {1 => "STRING", 2 => "NUMERIC"}
        VALID_VALUES = Set.new([STRING, NUMERIC]).freeze
      end

      module ParcStatus
        NEW = 1
        IN_PROGRESS = 2
        COMPLETE = 3
        DELETED = 4
        FAILED = 5
        REQUIRES_RECONFIGURATION = 7
        VALIDATION_FAILED = 8
        VALUE_MAP = {1 => "NEW", 2 => "IN_PROGRESS", 3 => "COMPLETE", 4 => "DELETED", 5 => "FAILED", 7 => "REQUIRES_RECONFIGURATION", 8 => "VALIDATION_FAILED"}
        VALID_VALUES = Set.new([NEW, IN_PROGRESS, COMPLETE, DELETED, FAILED, REQUIRES_RECONFIGURATION, VALIDATION_FAILED]).freeze
      end

      module InputDataFeedStatus
        ACTIVE = 1
        INACTIVE = 2
        DEFUNCT = 3
        VALUE_MAP = {1 => "ACTIVE", 2 => "INACTIVE", 3 => "DEFUNCT"}
        VALID_VALUES = Set.new([ACTIVE, INACTIVE, DEFUNCT]).freeze
      end

      module ValidationBehavior
        HALTING = 1
        WARNING_ONLY = 2
        DISABLED = 3
        VALUE_MAP = {1 => "HALTING", 2 => "WARNING_ONLY", 3 => "DISABLED"}
        VALID_VALUES = Set.new([HALTING, WARNING_ONLY, DISABLED]).freeze
      end

      module ColumnClassificationReason
        OTHER = 0
        MANUAL_INPUT = 1
        LABEL_MATCH_REGEX = 2
        VALUES_MATCH_REGEX = 3
        HIGH_MATCH_WITH_CORPUS_OF_VALUES = 4
        VALUE_MAP = {0 => "OTHER", 1 => "MANUAL_INPUT", 2 => "LABEL_MATCH_REGEX", 3 => "VALUES_MATCH_REGEX", 4 => "HIGH_MATCH_WITH_CORPUS_OF_VALUES"}
        VALID_VALUES = Set.new([OTHER, MANUAL_INPUT, LABEL_MATCH_REGEX, VALUES_MATCH_REGEX, HIGH_MATCH_WITH_CORPUS_OF_VALUES]).freeze
      end

      module SortKey
        CREATED_AT = 1
        UPDATED_AT = 2
        NAME = 3
        VALUE_MAP = {1 => "CREATED_AT", 2 => "UPDATED_AT", 3 => "NAME"}
        VALID_VALUES = Set.new([CREATED_AT, UPDATED_AT, NAME]).freeze
      end

      module FileInfoSortType
        UPLOADED_AT = 1
        FILENAME = 2
        VALUE_MAP = {1 => "UPLOADED_AT", 2 => "FILENAME"}
        VALID_VALUES = Set.new([UPLOADED_AT, FILENAME]).freeze
      end

      module SourceDataType
        CRM_DATA = 1
        TRANSACTIONS = 2
        IMPRESSIONS = 3
        OTHER = 4
        GOOGLE_DDS_ADD = 5
        GOOGLE_DDS_DELETE = 6
        LINC = 7
        VALUE_MAP = {1 => "CRM_DATA", 2 => "TRANSACTIONS", 3 => "IMPRESSIONS", 4 => "OTHER", 5 => "GOOGLE_DDS_ADD", 6 => "GOOGLE_DDS_DELETE", 7 => "LINC"}
        VALID_VALUES = Set.new([CRM_DATA, TRANSACTIONS, IMPRESSIONS, OTHER, GOOGLE_DDS_ADD, GOOGLE_DDS_DELETE, LINC]).freeze
      end

      module KeyConfigUpdateErrorCode
        FORBIDDEN_ID_TYPE = 1
        VALUE_MAP = {1 => "FORBIDDEN_ID_TYPE"}
        VALID_VALUES = Set.new([FORBIDDEN_ID_TYPE]).freeze
      end

      class DataAvailabilitySummary; end

      class SourceFileFormat < ::Thrift::Union; end

      class FileSummary; end

      class OnlineIdentifierDescription; end

      class OfflineIdentifierDescription; end

      class IdentifierDescription < ::Thrift::Union; end

      class SourceSummary < ::Thrift::Union; end

      class ContentMetadata; end

      class ParcSummary; end

      class IdentifierExtractionSpec < ::Thrift::Union; end

      class ToStrip; end

      class KeyVisibility < ::Thrift::Union; end

      class KeyConfiguration; end

      class HeaderSpec; end

      class LegacyAudienceKeySpec; end

      class KeyUniquenessValidationConfig; end

      class NewEnumValueValidationConfig; end

      class UnmappedKeyValidationConfig; end

      class ValidationConfiguration; end

      class FileConfiguration; end

      class FilePreprocessingOutput; end

      class ParcKeyOutput; end

      class ParcJobletOutput; end

      class ParcNotReadyException < ::Thrift::Exception; end

      class AnaDescription; end

      class FeedInfo; end

      class FeedOptions; end

      class AttributeCreationOptions; end

      class ParcOptions; end

      class LegacyConfiguredDataKeys; end

      class FileInfo; end

      class FileInfoResponse; end

      class InvalidConfigurationException < ::Thrift::Exception; end

      class AttributeValue; end

      class RawAttribute; end

      class EnumAttribute; end

      class RawOrEnumAttribute < ::Thrift::Union; end

      class Attribute; end

      class CreateAttribute; end

      class LinkAttribute; end

      class AttributeCreationFromKeysParams; end

      class AttributeDescription; end

      class ParcConfigurationInfo; end

      class ParcNotFoundException < ::Thrift::Exception; end

      class UnsupportedIdentifierConfigException < ::Thrift::Exception; end

      class FeedNotFoundException < ::Thrift::Exception; end

      class ParcException < ::Thrift::Exception; end

      class KeyConfigUpdateException < ::Thrift::Exception; end

      class DataAvailabilitySummary
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COMPLETE_PARC_IDS = 1
        IN_PROGRESS_PARC_IDS = 2

        FIELDS = {
          COMPLETE_PARC_IDS => {:type => ::Thrift::Types::SET, :name => 'complete_parc_ids', :element => {:type => ::Thrift::Types::I64}},
          IN_PROGRESS_PARC_IDS => {:type => ::Thrift::Types::SET, :name => 'in_progress_parc_ids', :element => {:type => ::Thrift::Types::I64}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field complete_parc_ids is unset!') unless @complete_parc_ids
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field in_progress_parc_ids is unset!') unless @in_progress_parc_ids
        end

        ::Thrift::Struct.generate_accessors self
      end

      class SourceFileFormat < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def key_value_file_format(val)
            SourceFileFormat.new(:key_value_file_format, val)
          end

          def column_delimited_file_format(val)
            SourceFileFormat.new(:column_delimited_file_format, val)
          end

          def google_dds_file_format(val)
            SourceFileFormat.new(:google_dds_file_format, val)
          end

          def segment_file_format(val)
            SourceFileFormat.new(:segment_file_format, val)
          end
        end

        KEY_VALUE_FILE_FORMAT = 1
        COLUMN_DELIMITED_FILE_FORMAT = 2
        GOOGLE_DDS_FILE_FORMAT = 3
        SEGMENT_FILE_FORMAT = 5

        FIELDS = {
          KEY_VALUE_FILE_FORMAT => {:type => ::Thrift::Types::STRUCT, :name => 'key_value_file_format', :class => ::Liveramp::Types::ParcService::KeyValueFileFormat, :optional => true},
          COLUMN_DELIMITED_FILE_FORMAT => {:type => ::Thrift::Types::STRUCT, :name => 'column_delimited_file_format', :class => ::Liveramp::Types::ParcService::ColumnDelimitedFileFormat, :optional => true},
          GOOGLE_DDS_FILE_FORMAT => {:type => ::Thrift::Types::STRUCT, :name => 'google_dds_file_format', :class => ::Liveramp::Types::ParcService::GoogleDdsFileFormat, :optional => true},
          SEGMENT_FILE_FORMAT => {:type => ::Thrift::Types::STRUCT, :name => 'segment_file_format', :class => ::Liveramp::Types::ParcService::SegmentFileFormat, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class FileSummary
        include ::Thrift::Struct, ::Thrift::Struct_Union
        FILE_ID = 1
        FILE_NAME = 2
        FILE_FORMAT = 3
        UTC_FILE_REGISTRATION_TIME = 4

        FIELDS = {
          FILE_ID => {:type => ::Thrift::Types::I64, :name => 'file_id'},
          FILE_NAME => {:type => ::Thrift::Types::STRING, :name => 'file_name'},
          FILE_FORMAT => {:type => ::Thrift::Types::STRUCT, :name => 'file_format', :class => ::Liveramp::Types::ParcService::SourceFileFormat},
          UTC_FILE_REGISTRATION_TIME => {:type => ::Thrift::Types::I64, :name => 'utc_file_registration_time'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field file_id is unset!') unless @file_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field file_name is unset!') unless @file_name
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field file_format is unset!') unless @file_format
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field utc_file_registration_time is unset!') unless @utc_file_registration_time
        end

        ::Thrift::Struct.generate_accessors self
      end

      class OnlineIdentifierDescription
        include ::Thrift::Struct, ::Thrift::Struct_Union
        AD_NETWORK_ACCOUNT_ID = 1

        FIELDS = {
          AD_NETWORK_ACCOUNT_ID => {:type => ::Thrift::Types::I32, :name => 'ad_network_account_id'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field ad_network_account_id is unset!') unless @ad_network_account_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      class OfflineIdentifierDescription
        include ::Thrift::Struct, ::Thrift::Struct_Union

        FIELDS = {

        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class IdentifierDescription < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def online_identifier_description(val)
            IdentifierDescription.new(:online_identifier_description, val)
          end

          def offline_identifier_description(val)
            IdentifierDescription.new(:offline_identifier_description, val)
          end
        end

        ONLINE_IDENTIFIER_DESCRIPTION = 1
        OFFLINE_IDENTIFIER_DESCRIPTION = 2

        FIELDS = {
          ONLINE_IDENTIFIER_DESCRIPTION => {:type => ::Thrift::Types::STRUCT, :name => 'online_identifier_description', :class => ::Liveramp::Types::ParcService::OnlineIdentifierDescription, :optional => true},
          OFFLINE_IDENTIFIER_DESCRIPTION => {:type => ::Thrift::Types::STRUCT, :name => 'offline_identifier_description', :class => ::Liveramp::Types::ParcService::OfflineIdentifierDescription, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class SourceSummary < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def file_summary(val)
            SourceSummary.new(:file_summary, val)
          end
        end

        FILE_SUMMARY = 1

        FIELDS = {
          FILE_SUMMARY => {:type => ::Thrift::Types::STRUCT, :name => 'file_summary', :class => ::Liveramp::Types::ParcService::FileSummary, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class ContentMetadata
        include ::Thrift::Struct, ::Thrift::Struct_Union
        BEHAVIORAL = 1

        FIELDS = {
          BEHAVIORAL => {:type => ::Thrift::Types::BOOL, :name => 'behavioral', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ParcSummary
        include ::Thrift::Struct, ::Thrift::Struct_Union
        NUM_RECORDS = 1
        AVAILABLE_KEYS_TO_EXAMPLES = 2
        SOURCE_SUMMARY = 3
        CONTENT_METADATA = 4
        IDENTIFIER_DESCRIPTIONS = 5
        PARC_ID = 6
        DATA_KEYS = 7
        SOURCE_ID = 8
        PARCWIDE_ATTRIBUTE_IDS = 9

        FIELDS = {
          NUM_RECORDS => {:type => ::Thrift::Types::I64, :name => 'num_records', :optional => true},
          AVAILABLE_KEYS_TO_EXAMPLES => {:type => ::Thrift::Types::MAP, :name => 'available_keys_to_examples', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::LIST, :element => {:type => ::Thrift::Types::STRING}}},
          SOURCE_SUMMARY => {:type => ::Thrift::Types::STRUCT, :name => 'source_summary', :class => ::Liveramp::Types::ParcService::SourceSummary},
          CONTENT_METADATA => {:type => ::Thrift::Types::STRUCT, :name => 'content_metadata', :class => ::Liveramp::Types::ParcService::ContentMetadata, :optional => true},
          IDENTIFIER_DESCRIPTIONS => {:type => ::Thrift::Types::MAP, :name => 'identifier_descriptions', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::ParcService::IdentifierDescription}},
          PARC_ID => {:type => ::Thrift::Types::I64, :name => 'parc_id'},
          DATA_KEYS => {:type => ::Thrift::Types::SET, :name => 'data_keys', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
          SOURCE_ID => {:type => ::Thrift::Types::I64, :name => 'source_id', :optional => true},
          PARCWIDE_ATTRIBUTE_IDS => {:type => ::Thrift::Types::SET, :name => 'parcwide_attribute_ids', :element => {:type => ::Thrift::Types::I64}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field available_keys_to_examples is unset!') unless @available_keys_to_examples
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field source_summary is unset!') unless @source_summary
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field identifier_descriptions is unset!') unless @identifier_descriptions
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field parc_id is unset!') unless @parc_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      class IdentifierExtractionSpec < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def offline_identifier_extraction_spec(val)
            IdentifierExtractionSpec.new(:offline_identifier_extraction_spec, val)
          end

          def online_identifier_extraction_spec(val)
            IdentifierExtractionSpec.new(:online_identifier_extraction_spec, val)
          end
        end

        OFFLINE_IDENTIFIER_EXTRACTION_SPEC = 1
        ONLINE_IDENTIFIER_EXTRACTION_SPEC = 2

        FIELDS = {
          OFFLINE_IDENTIFIER_EXTRACTION_SPEC => {:type => ::Thrift::Types::STRUCT, :name => 'offline_identifier_extraction_spec', :class => ::Rapleaf::ImporterService::IdentifierFieldExtractionSpec, :optional => true},
          ONLINE_IDENTIFIER_EXTRACTION_SPEC => {:type => ::Thrift::Types::STRUCT, :name => 'online_identifier_extraction_spec', :class => ::Rapleaf::ImporterService::OnlineIdentifierFieldExtractionSpec, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class ToStrip
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CLASSIFICATION_REASON = 1
        ADDITIONAL_INFO = 2

        FIELDS = {
          CLASSIFICATION_REASON => {:type => ::Thrift::Types::I32, :name => 'classification_reason', :enum_class => ::Liveramp::Types::ParcService::ColumnClassificationReason},
          ADDITIONAL_INFO => {:type => ::Thrift::Types::STRING, :name => 'additional_info', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field classification_reason is unset!') unless @classification_reason
          unless @classification_reason.nil? || ::Liveramp::Types::ParcService::ColumnClassificationReason::VALID_VALUES.include?(@classification_reason)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field classification_reason!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class KeyVisibility < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def plaintext_ok(val)
            KeyVisibility.new(:plaintext_ok, val)
          end

          def to_strip(val)
            KeyVisibility.new(:to_strip, val)
          end
        end

        PLAINTEXT_OK = 1
        TO_STRIP = 2

        FIELDS = {
          PLAINTEXT_OK => {:type => ::Thrift::Types::BOOL, :name => 'plaintext_ok', :optional => true},
          TO_STRIP => {:type => ::Thrift::Types::STRUCT, :name => 'to_strip', :class => ::Liveramp::Types::ParcService::ToStrip, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class KeyConfiguration
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ID_SPECS_PER_NAME = 1
        KEY_VISIBILITIES = 2

        FIELDS = {
          ID_SPECS_PER_NAME => {:type => ::Thrift::Types::MAP, :name => 'id_specs_per_name', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Ingestion::Identifier::Configuration::IdSpec}},
          KEY_VISIBILITIES => {:type => ::Thrift::Types::MAP, :name => 'key_visibilities', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::ParcService::KeyVisibility}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field id_specs_per_name is unset!') unless @id_specs_per_name
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field key_visibilities is unset!') unless @key_visibilities
        end

        ::Thrift::Struct.generate_accessors self
      end

      class HeaderSpec
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COLUMN_INDEX_TO_HEADER = 1

        FIELDS = {
          COLUMN_INDEX_TO_HEADER => {:type => ::Thrift::Types::MAP, :name => 'column_index_to_header', :key => {:type => ::Thrift::Types::I32}, :value => {:type => ::Thrift::Types::STRING}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field column_index_to_header is unset!') unless @column_index_to_header
        end

        ::Thrift::Struct.generate_accessors self
      end

      class LegacyAudienceKeySpec
        include ::Thrift::Struct, ::Thrift::Struct_Union
        AUDIENCE_KEY_TO_COLUMN_INDEX = 1
        AUDIENCE_KEY_INDICES = 2

        FIELDS = {
          AUDIENCE_KEY_TO_COLUMN_INDEX => {:type => ::Thrift::Types::MAP, :name => 'audience_key_to_column_index', :key => {:type => ::Thrift::Types::I32}, :value => {:type => ::Thrift::Types::I32}},
          AUDIENCE_KEY_INDICES => {:type => ::Thrift::Types::SET, :name => 'audience_key_indices', :element => {:type => ::Thrift::Types::I32}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field audience_key_to_column_index is unset!') unless @audience_key_to_column_index
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field audience_key_indices is unset!') unless @audience_key_indices
        end

        ::Thrift::Struct.generate_accessors self
      end

      class KeyUniquenessValidationConfig
        include ::Thrift::Struct, ::Thrift::Struct_Union
        VALIDATION_STATUS = 1
        RATIO_UNIQUENESS_THRESHOLD = 2

        FIELDS = {
          VALIDATION_STATUS => {:type => ::Thrift::Types::I32, :name => 'validation_status', :enum_class => ::Liveramp::Types::ParcService::ValidationBehavior},
          RATIO_UNIQUENESS_THRESHOLD => {:type => ::Thrift::Types::DOUBLE, :name => 'ratio_uniqueness_threshold'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field validation_status is unset!') unless @validation_status
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field ratio_uniqueness_threshold is unset!') unless @ratio_uniqueness_threshold
          unless @validation_status.nil? || ::Liveramp::Types::ParcService::ValidationBehavior::VALID_VALUES.include?(@validation_status)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field validation_status!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class NewEnumValueValidationConfig
        include ::Thrift::Struct, ::Thrift::Struct_Union
        VALIDATION_STATUS = 1

        FIELDS = {
          VALIDATION_STATUS => {:type => ::Thrift::Types::I32, :name => 'validation_status', :enum_class => ::Liveramp::Types::ParcService::ValidationBehavior}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field validation_status is unset!') unless @validation_status
          unless @validation_status.nil? || ::Liveramp::Types::ParcService::ValidationBehavior::VALID_VALUES.include?(@validation_status)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field validation_status!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class UnmappedKeyValidationConfig
        include ::Thrift::Struct, ::Thrift::Struct_Union
        VALIDATION_STATUS = 1

        FIELDS = {
          VALIDATION_STATUS => {:type => ::Thrift::Types::I32, :name => 'validation_status', :enum_class => ::Liveramp::Types::ParcService::ValidationBehavior}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field validation_status is unset!') unless @validation_status
          unless @validation_status.nil? || ::Liveramp::Types::ParcService::ValidationBehavior::VALID_VALUES.include?(@validation_status)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field validation_status!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ValidationConfiguration
        include ::Thrift::Struct, ::Thrift::Struct_Union
        KEY_UNIQUENESS_VALIDATION_CONFIG = 1
        NEW_ENUM_VALUE_VALIDATION_CONFIG = 2
        UNMAPPED_KEY_VALIDATION_CONFIG = 3

        FIELDS = {
          KEY_UNIQUENESS_VALIDATION_CONFIG => {:type => ::Thrift::Types::STRUCT, :name => 'key_uniqueness_validation_config', :class => ::Liveramp::Types::ParcService::KeyUniquenessValidationConfig, :optional => true},
          NEW_ENUM_VALUE_VALIDATION_CONFIG => {:type => ::Thrift::Types::STRUCT, :name => 'new_enum_value_validation_config', :class => ::Liveramp::Types::ParcService::NewEnumValueValidationConfig, :optional => true},
          UNMAPPED_KEY_VALIDATION_CONFIG => {:type => ::Thrift::Types::STRUCT, :name => 'unmapped_key_validation_config', :class => ::Liveramp::Types::ParcService::UnmappedKeyValidationConfig, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class FileConfiguration
        include ::Thrift::Struct, ::Thrift::Struct_Union
        KEYS_TO_IDENTIFIER_EXTRACTION_SPECS = 1
        KEYS_TO_STRIP = 2
        CHARACTER_ENCODING = 4
        SOURCE_FILE_FORMAT = 6
        LEGACY_AUDIENCE_KEY_SPEC = 7
        LIVERAMP_IMPORT_REQUEST_ID = 8
        PARCWIDE_ATTRIBUTE_IDS = 9
        PLAINTEXT_KEYS = 10

        FIELDS = {
          # The header to all the identifiers that it could be a part of
# 
          KEYS_TO_IDENTIFIER_EXTRACTION_SPECS => {:type => ::Thrift::Types::MAP, :name => 'keys_to_identifier_extraction_specs', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::SET, :element => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::ParcService::IdentifierExtractionSpec}}},
          # Keys that are deemed privacy sensitive and need to be hashed
          KEYS_TO_STRIP => {:type => ::Thrift::Types::SET, :name => 'keys_to_strip', :element => {:type => ::Thrift::Types::STRING}},
          CHARACTER_ENCODING => {:type => ::Thrift::Types::I32, :name => 'character_encoding', :enum_class => ::Rapleaf::ImporterService::CharacterEncoding},
          SOURCE_FILE_FORMAT => {:type => ::Thrift::Types::STRUCT, :name => 'source_file_format', :class => ::Liveramp::Types::ParcService::SourceFileFormat},
          # Map from an audience's unique key index to the corresponding column.
# AudienceKeys are generated from PII right now, but if Onboarding is changed to be downstream
# of the PARC service, PII will not be available. There is no danger in new audiences receiving
# audience keys that are based off the anonymized result, but old audiences must continue to
# obtain their original audience keys.
          LEGACY_AUDIENCE_KEY_SPEC => {:type => ::Thrift::Types::STRUCT, :name => 'legacy_audience_key_spec', :class => ::Liveramp::Types::ParcService::LegacyAudienceKeySpec, :optional => true},
          # The LiverampImportRequestId that this PARC is to be made for. Only for legacy tracking.
# 
          LIVERAMP_IMPORT_REQUEST_ID => {:type => ::Thrift::Types::I64, :name => 'liveramp_import_request_id', :optional => true},
          # CustomerAttribute IDs that are assigned to every row of this file.
# 
          PARCWIDE_ATTRIBUTE_IDS => {:type => ::Thrift::Types::SET, :name => 'parcwide_attribute_ids', :element => {:type => ::Thrift::Types::I64}, :optional => true},
          # Keys to pass through plaintext
# 
          PLAINTEXT_KEYS => {:type => ::Thrift::Types::SET, :name => 'plaintext_keys', :element => {:type => ::Thrift::Types::STRING}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field keys_to_identifier_extraction_specs is unset!') unless @keys_to_identifier_extraction_specs
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field keys_to_strip is unset!') unless @keys_to_strip
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field character_encoding is unset!') unless @character_encoding
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field source_file_format is unset!') unless @source_file_format
          unless @character_encoding.nil? || ::Rapleaf::ImporterService::CharacterEncoding::VALID_VALUES.include?(@character_encoding)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field character_encoding!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class FilePreprocessingOutput
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PATH_TO_PFR = 1
        FILE_SPEC = 2

        FIELDS = {
          PATH_TO_PFR => {:type => ::Thrift::Types::STRING, :name => 'path_to_pfr'},
          FILE_SPEC => {:type => ::Thrift::Types::STRUCT, :name => 'file_spec', :class => ::Rapleaf::ImporterService::FileSpec}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field path_to_pfr is unset!') unless @path_to_pfr
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ParcKeyOutput
        include ::Thrift::Struct, ::Thrift::Struct_Union
        LABEL = 1
        VALUES = 2

        FIELDS = {
          LABEL => {:type => ::Thrift::Types::STRING, :name => 'label'},
          VALUES => {:type => ::Thrift::Types::SET, :name => 'values', :element => {:type => ::Thrift::Types::STRING}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field label is unset!') unless @label
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field values is unset!') unless @values
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ParcJobletOutput
        include ::Thrift::Struct, ::Thrift::Struct_Union
        NUM_PARS = 1
        NUM_RECORDS_AFTER_IDENTIFIER_EXTRACTION = 2
        FILE_SPEC = 4

        FIELDS = {
          NUM_PARS => {:type => ::Thrift::Types::I64, :name => 'num_pars'},
          NUM_RECORDS_AFTER_IDENTIFIER_EXTRACTION => {:type => ::Thrift::Types::I64, :name => 'num_records_after_identifier_extraction'},
          FILE_SPEC => {:type => ::Thrift::Types::STRUCT, :name => 'file_spec', :class => ::Rapleaf::ImporterService::FileSpec, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field num_pars is unset!') unless @num_pars
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field num_records_after_identifier_extraction is unset!') unless @num_records_after_identifier_extraction
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ParcNotReadyException < ::Thrift::Exception
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PARC_IDS = 1

        FIELDS = {
          PARC_IDS => {:type => ::Thrift::Types::SET, :name => 'parc_ids', :element => {:type => ::Thrift::Types::I64}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field parc_ids is unset!') unless @parc_ids
        end

        ::Thrift::Struct.generate_accessors self
      end

      class AnaDescription
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ID = 1
        NAME = 2

        FIELDS = {
          ID => {:type => ::Thrift::Types::I64, :name => 'id'},
          NAME => {:type => ::Thrift::Types::STRING, :name => 'name'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field id is unset!') unless @id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field name is unset!') unless @name
        end

        ::Thrift::Struct.generate_accessors self
      end

      class FeedInfo
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ID = 1
        NAME = 2
        CUSTOMER_ID = 3
        STATUS = 4
        TEMPLATE_FILE_CONFIGURATION = 5
        TEMPLATE_VALIDATION_CONFIGURATION = 6
        CREATED_AT_MILLIS = 7
        UPDATED_AT_MILLIS = 8

        FIELDS = {
          ID => {:type => ::Thrift::Types::I64, :name => 'id'},
          NAME => {:type => ::Thrift::Types::STRING, :name => 'name'},
          CUSTOMER_ID => {:type => ::Thrift::Types::I64, :name => 'customer_id'},
          STATUS => {:type => ::Thrift::Types::I32, :name => 'status', :enum_class => ::Liveramp::Types::ParcService::InputDataFeedStatus},
          TEMPLATE_FILE_CONFIGURATION => {:type => ::Thrift::Types::STRUCT, :name => 'template_file_configuration', :class => ::Liveramp::Types::ParcService::FileConfiguration, :optional => true},
          TEMPLATE_VALIDATION_CONFIGURATION => {:type => ::Thrift::Types::STRUCT, :name => 'template_validation_configuration', :class => ::Liveramp::Types::ParcService::ValidationConfiguration, :optional => true},
          CREATED_AT_MILLIS => {:type => ::Thrift::Types::I64, :name => 'created_at_millis'},
          UPDATED_AT_MILLIS => {:type => ::Thrift::Types::I64, :name => 'updated_at_millis'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field id is unset!') unless @id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field name is unset!') unless @name
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field customer_id is unset!') unless @customer_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field created_at_millis is unset!') unless @created_at_millis
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field updated_at_millis is unset!') unless @updated_at_millis
          unless @status.nil? || ::Liveramp::Types::ParcService::InputDataFeedStatus::VALID_VALUES.include?(@status)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field status!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class FeedOptions
        include ::Thrift::Struct, ::Thrift::Struct_Union
        NAME = 1
        TEMPLATE_FILE_CONFIGURATION = 2
        TEMPLATE_VALIDATION_CONFIGURATION = 3

        FIELDS = {
          NAME => {:type => ::Thrift::Types::STRING, :name => 'name', :optional => true},
          TEMPLATE_FILE_CONFIGURATION => {:type => ::Thrift::Types::STRUCT, :name => 'template_file_configuration', :class => ::Liveramp::Types::ParcService::FileConfiguration, :optional => true},
          TEMPLATE_VALIDATION_CONFIGURATION => {:type => ::Thrift::Types::STRUCT, :name => 'template_validation_configuration', :class => ::Liveramp::Types::ParcService::ValidationConfiguration, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class AttributeCreationOptions
        include ::Thrift::Struct, ::Thrift::Struct_Union

        FIELDS = {

        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ParcOptions
        include ::Thrift::Struct, ::Thrift::Struct_Union
        VALIDATION_CONFIGURATION = 1
        ATTRIBUTE_CREATION_OPTION = 2
        PRIORITY = 3
        LIVERAMP_IMPORT_REQUEST_ID = 4

        FIELDS = {
          VALIDATION_CONFIGURATION => {:type => ::Thrift::Types::STRUCT, :name => 'validation_configuration', :class => ::Liveramp::Types::ParcService::ValidationConfiguration, :optional => true},
          ATTRIBUTE_CREATION_OPTION => {:type => ::Thrift::Types::STRUCT, :name => 'attribute_creation_option', :class => ::Liveramp::Types::ParcService::AttributeCreationOptions, :optional => true},
          # The value should correspond to an IngestionPriority
# 
          PRIORITY => {:type => ::Thrift::Types::I32, :name => 'priority', :optional => true},
          LIVERAMP_IMPORT_REQUEST_ID => {:type => ::Thrift::Types::I64, :name => 'liveramp_import_request_id', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class LegacyConfiguredDataKeys
        include ::Thrift::Struct, ::Thrift::Struct_Union
        DATA_KEYS = 1

        FIELDS = {
          DATA_KEYS => {:type => ::Thrift::Types::SET, :name => 'data_keys', :element => {:type => ::Thrift::Types::STRING}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field data_keys is unset!') unless @data_keys
        end

        ::Thrift::Struct.generate_accessors self
      end

      class FileInfo
        include ::Thrift::Struct, ::Thrift::Struct_Union
        FEED_ID = 1
        FILE_ID = 2
        PARC_ID = 3
        FILENAME = 4
        UPLOADED_AT = 5
        INGESTION_COMPLETED_AT = 6
        NUM_ROWS = 7
        NUM_DATA_COLUMNS = 8
        INPUT_NFS_PATH = 9
        PARC_HDFS_PATH = 10

        FIELDS = {
          FEED_ID => {:type => ::Thrift::Types::I64, :name => 'feed_id'},
          FILE_ID => {:type => ::Thrift::Types::I64, :name => 'file_id'},
          PARC_ID => {:type => ::Thrift::Types::I64, :name => 'parc_id'},
          FILENAME => {:type => ::Thrift::Types::STRING, :name => 'filename'},
          UPLOADED_AT => {:type => ::Thrift::Types::I64, :name => 'uploaded_at'},
          INGESTION_COMPLETED_AT => {:type => ::Thrift::Types::I64, :name => 'ingestion_completed_at', :optional => true},
          NUM_ROWS => {:type => ::Thrift::Types::I64, :name => 'num_rows', :optional => true},
          NUM_DATA_COLUMNS => {:type => ::Thrift::Types::I64, :name => 'num_data_columns', :optional => true},
          INPUT_NFS_PATH => {:type => ::Thrift::Types::STRING, :name => 'input_nfs_path'},
          PARC_HDFS_PATH => {:type => ::Thrift::Types::STRING, :name => 'parc_hdfs_path', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field feed_id is unset!') unless @feed_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field file_id is unset!') unless @file_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field parc_id is unset!') unless @parc_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field filename is unset!') unless @filename
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field uploaded_at is unset!') unless @uploaded_at
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field input_nfs_path is unset!') unless @input_nfs_path
        end

        ::Thrift::Struct.generate_accessors self
      end

      class FileInfoResponse
        include ::Thrift::Struct, ::Thrift::Struct_Union
        FILE_INFOS = 1
        PAGINATION_RESPONSE = 2
        SORT_TYPE = 3

        FIELDS = {
          FILE_INFOS => {:type => ::Thrift::Types::SET, :name => 'file_infos', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::ParcService::FileInfo}},
          PAGINATION_RESPONSE => {:type => ::Thrift::Types::STRUCT, :name => 'pagination_response', :class => ::Liveramp::Ui::Common::PaginationResponse},
          SORT_TYPE => {:type => ::Thrift::Types::I32, :name => 'sort_type', :enum_class => ::Liveramp::Types::ParcService::FileInfoSortType}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field file_infos is unset!') unless @file_infos
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field pagination_response is unset!') unless @pagination_response
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sort_type is unset!') unless @sort_type
          unless @sort_type.nil? || ::Liveramp::Types::ParcService::FileInfoSortType::VALID_VALUES.include?(@sort_type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field sort_type!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class InvalidConfigurationException < ::Thrift::Exception
        include ::Thrift::Struct, ::Thrift::Struct_Union
        def initialize(message=nil)
          super()
          self.message = message
        end

        MESSAGE = 1

        FIELDS = {
          MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field message is unset!') unless @message
        end

        ::Thrift::Struct.generate_accessors self
      end

      class AttributeValue
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ID = 1
        VALUE = 2

        FIELDS = {
          ID => {:type => ::Thrift::Types::I64, :name => 'id', :optional => true},
          VALUE => {:type => ::Thrift::Types::STRING, :name => 'value'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field value is unset!') unless @value
        end

        ::Thrift::Struct.generate_accessors self
      end

      class RawAttribute
        include ::Thrift::Struct, ::Thrift::Struct_Union

        FIELDS = {

        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class EnumAttribute
        include ::Thrift::Struct, ::Thrift::Struct_Union
        VALUES = 1

        FIELDS = {
          VALUES => {:type => ::Thrift::Types::SET, :name => 'values', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::ParcService::AttributeValue}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field values is unset!') unless @values
        end

        ::Thrift::Struct.generate_accessors self
      end

      class RawOrEnumAttribute < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def raw_attribute(val)
            RawOrEnumAttribute.new(:raw_attribute, val)
          end

          def enum_attribute(val)
            RawOrEnumAttribute.new(:enum_attribute, val)
          end
        end

        RAW_ATTRIBUTE = 1
        ENUM_ATTRIBUTE = 2

        FIELDS = {
          RAW_ATTRIBUTE => {:type => ::Thrift::Types::STRUCT, :name => 'raw_attribute', :class => ::Liveramp::Types::ParcService::RawAttribute, :optional => true},
          ENUM_ATTRIBUTE => {:type => ::Thrift::Types::STRUCT, :name => 'enum_attribute', :class => ::Liveramp::Types::ParcService::EnumAttribute, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class Attribute
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ID = 1
        LABEL = 2
        KEYS = 3
        TYPE = 4
        RAW_OR_ENUM_ATTRIBUTE = 5

        FIELDS = {
          ID => {:type => ::Thrift::Types::I64, :name => 'id'},
          LABEL => {:type => ::Thrift::Types::STRING, :name => 'label'},
          KEYS => {:type => ::Thrift::Types::SET, :name => 'keys', :element => {:type => ::Thrift::Types::STRING}},
          TYPE => {:type => ::Thrift::Types::I32, :name => 'type', :enum_class => ::Liveramp::Types::ParcService::ParcAttributeDataType},
          RAW_OR_ENUM_ATTRIBUTE => {:type => ::Thrift::Types::STRUCT, :name => 'raw_or_enum_attribute', :class => ::Liveramp::Types::ParcService::RawOrEnumAttribute}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field id is unset!') unless @id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field label is unset!') unless @label
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field keys is unset!') unless @keys
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field type is unset!') unless @type
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field raw_or_enum_attribute is unset!') unless @raw_or_enum_attribute
          unless @type.nil? || ::Liveramp::Types::ParcService::ParcAttributeDataType::VALID_VALUES.include?(@type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field type!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class CreateAttribute
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CUSTOMER_ID = 1
        LABEL = 2
        TYPE = 3
        RAW_OR_ENUM_ATTRIBUTE = 4

        FIELDS = {
          CUSTOMER_ID => {:type => ::Thrift::Types::I64, :name => 'customer_id'},
          LABEL => {:type => ::Thrift::Types::STRING, :name => 'label'},
          TYPE => {:type => ::Thrift::Types::I32, :name => 'type', :enum_class => ::Liveramp::Types::ParcService::ParcAttributeDataType},
          RAW_OR_ENUM_ATTRIBUTE => {:type => ::Thrift::Types::STRUCT, :name => 'raw_or_enum_attribute', :class => ::Liveramp::Types::ParcService::RawOrEnumAttribute}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field customer_id is unset!') unless @customer_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field label is unset!') unless @label
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field type is unset!') unless @type
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field raw_or_enum_attribute is unset!') unless @raw_or_enum_attribute
          unless @type.nil? || ::Liveramp::Types::ParcService::ParcAttributeDataType::VALID_VALUES.include?(@type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field type!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class LinkAttribute
        include ::Thrift::Struct, ::Thrift::Struct_Union
        EXISTING_ATTRIBUTE_ID = 1

        FIELDS = {
          EXISTING_ATTRIBUTE_ID => {:type => ::Thrift::Types::I64, :name => 'existing_attribute_id'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field existing_attribute_id is unset!') unless @existing_attribute_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      class AttributeCreationFromKeysParams
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CUSTOMER_ID = 1
        FEED_ID = 2
        KEY_TO_LINK = 3

        FIELDS = {
          CUSTOMER_ID => {:type => ::Thrift::Types::I64, :name => 'customer_id'},
          FEED_ID => {:type => ::Thrift::Types::I64, :name => 'feed_id'},
          KEY_TO_LINK => {:type => ::Thrift::Types::MAP, :name => 'key_to_link', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::ParcService::LinkAttribute}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field customer_id is unset!') unless @customer_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field feed_id is unset!') unless @feed_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field key_to_link is unset!') unless @key_to_link
        end

        ::Thrift::Struct.generate_accessors self
      end

      class AttributeDescription
        include ::Thrift::Struct, ::Thrift::Struct_Union
        LABEL = 1
        RAW_OR_ENUM_ATTRIBUTE = 2
        PARC_ATTRIBUTE_DATA_TYPE = 3

        FIELDS = {
          LABEL => {:type => ::Thrift::Types::STRING, :name => 'label'},
          RAW_OR_ENUM_ATTRIBUTE => {:type => ::Thrift::Types::STRUCT, :name => 'raw_or_enum_attribute', :class => ::Liveramp::Types::ParcService::RawOrEnumAttribute},
          PARC_ATTRIBUTE_DATA_TYPE => {:type => ::Thrift::Types::I32, :name => 'parc_attribute_data_type', :enum_class => ::Liveramp::Types::ParcService::ParcAttributeDataType}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field label is unset!') unless @label
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field raw_or_enum_attribute is unset!') unless @raw_or_enum_attribute
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field parc_attribute_data_type is unset!') unless @parc_attribute_data_type
          unless @parc_attribute_data_type.nil? || ::Liveramp::Types::ParcService::ParcAttributeDataType::VALID_VALUES.include?(@parc_attribute_data_type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field parc_attribute_data_type!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ParcConfigurationInfo
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PARC_ID = 1
        FEED_ID = 2
        FILE_CONFIGURATION = 3
        VALIDATION_CONFIGURATION = 4
        KEY_CONFIGURATION = 5

        FIELDS = {
          PARC_ID => {:type => ::Thrift::Types::I64, :name => 'parc_id'},
          FEED_ID => {:type => ::Thrift::Types::I64, :name => 'feed_id'},
          FILE_CONFIGURATION => {:type => ::Thrift::Types::STRUCT, :name => 'file_configuration', :class => ::Liveramp::Types::ParcService::FileConfiguration},
          VALIDATION_CONFIGURATION => {:type => ::Thrift::Types::STRUCT, :name => 'validation_configuration', :class => ::Liveramp::Types::ParcService::ValidationConfiguration},
          KEY_CONFIGURATION => {:type => ::Thrift::Types::STRUCT, :name => 'key_configuration', :class => ::Liveramp::Types::ParcService::KeyConfiguration}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field parc_id is unset!') unless @parc_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field feed_id is unset!') unless @feed_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field file_configuration is unset!') unless @file_configuration
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field validation_configuration is unset!') unless @validation_configuration
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field key_configuration is unset!') unless @key_configuration
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ParcNotFoundException < ::Thrift::Exception
        include ::Thrift::Struct, ::Thrift::Struct_Union

        FIELDS = {

        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class UnsupportedIdentifierConfigException < ::Thrift::Exception
        include ::Thrift::Struct, ::Thrift::Struct_Union
        def initialize(message=nil)
          super()
          self.message = message
        end

        MESSAGE = 1

        FIELDS = {
          MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field message is unset!') unless @message
        end

        ::Thrift::Struct.generate_accessors self
      end

      class FeedNotFoundException < ::Thrift::Exception
        include ::Thrift::Struct, ::Thrift::Struct_Union
        FEED_ID = 1

        FIELDS = {
          FEED_ID => {:type => ::Thrift::Types::I64, :name => 'feed_id'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ParcException < ::Thrift::Exception
        include ::Thrift::Struct, ::Thrift::Struct_Union
        def initialize(message=nil)
          super()
          self.message = message
        end

        MESSAGE = 1

        FIELDS = {
          MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field message is unset!') unless @message
        end

        ::Thrift::Struct.generate_accessors self
      end

      class KeyConfigUpdateException < ::Thrift::Exception
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ERROR_CODE = 1
        MESSAGE = 2

        FIELDS = {
          ERROR_CODE => {:type => ::Thrift::Types::I32, :name => 'error_code', :enum_class => ::Liveramp::Types::ParcService::KeyConfigUpdateErrorCode},
          MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field error_code is unset!') unless @error_code
          unless @error_code.nil? || ::Liveramp::Types::ParcService::KeyConfigUpdateErrorCode::VALID_VALUES.include?(@error_code)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field error_code!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

    end
  end
end
