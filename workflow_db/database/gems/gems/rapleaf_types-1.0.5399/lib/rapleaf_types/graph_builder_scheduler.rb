#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'
require File.join File.dirname(__FILE__), 'anonymous_identifier_mapping_types'

module Liveramp
  module Types
    module AnonymousIdentifierMapping
      module GraphBuilderScheduler
        class Client
          include ::Thrift::Client

          def show_all_batches(aim_process)
            send_show_all_batches(aim_process)
            return recv_show_all_batches()
          end

          def send_show_all_batches(aim_process)
            send_message('show_all_batches', Show_all_batches_args, :aim_process => aim_process)
          end

          def recv_show_all_batches()
            result = receive_message(Show_all_batches_result)
            return result.success unless result.success.nil?
            raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'show_all_batches failed: unknown result')
          end

          def pop_next_batch(aim_process)
            send_pop_next_batch(aim_process)
            return recv_pop_next_batch()
          end

          def send_pop_next_batch(aim_process)
            send_message('pop_next_batch', Pop_next_batch_args, :aim_process => aim_process)
          end

          def recv_pop_next_batch()
            result = receive_message(Pop_next_batch_result)
            return result.success unless result.success.nil?
            raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'pop_next_batch failed: unknown result')
          end

        end

        class Processor
          include ::Thrift::Processor

          def process_show_all_batches(seqid, iprot, oprot)
            args = read_args(iprot, Show_all_batches_args)
            result = Show_all_batches_result.new()
            result.success = @handler.show_all_batches(args.aim_process)
            write_result(result, oprot, 'show_all_batches', seqid)
          end

          def process_pop_next_batch(seqid, iprot, oprot)
            args = read_args(iprot, Pop_next_batch_args)
            result = Pop_next_batch_result.new()
            result.success = @handler.pop_next_batch(args.aim_process)
            write_result(result, oprot, 'pop_next_batch', seqid)
          end

        end

        # HELPER FUNCTIONS AND STRUCTURES

        class Show_all_batches_args
          include ::Thrift::Struct, ::Thrift::Struct_Union
          AIM_PROCESS = 1

          FIELDS = {
            AIM_PROCESS => {:type => ::Thrift::Types::I32, :name => 'aim_process', :enum_class => ::Liveramp::Types::AnonymousIdentifierMapping::AimProcess}
          }

          def struct_fields; FIELDS; end

          def validate
            unless @aim_process.nil? || ::Liveramp::Types::AnonymousIdentifierMapping::AimProcess::VALID_VALUES.include?(@aim_process)
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field aim_process!')
            end
          end

          ::Thrift::Struct.generate_accessors self
        end

        class Show_all_batches_result
          include ::Thrift::Struct, ::Thrift::Struct_Union
          SUCCESS = 0

          FIELDS = {
            SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::MAP, :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::AnonymousIdentifierMapping::AimRequestTimestampPair}}}
          }

          def struct_fields; FIELDS; end

          def validate
          end

          ::Thrift::Struct.generate_accessors self
        end

        class Pop_next_batch_args
          include ::Thrift::Struct, ::Thrift::Struct_Union
          AIM_PROCESS = 1

          FIELDS = {
            AIM_PROCESS => {:type => ::Thrift::Types::I32, :name => 'aim_process', :enum_class => ::Liveramp::Types::AnonymousIdentifierMapping::AimProcess}
          }

          def struct_fields; FIELDS; end

          def validate
            unless @aim_process.nil? || ::Liveramp::Types::AnonymousIdentifierMapping::AimProcess::VALID_VALUES.include?(@aim_process)
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field aim_process!')
            end
          end

          ::Thrift::Struct.generate_accessors self
        end

        class Pop_next_batch_result
          include ::Thrift::Struct, ::Thrift::Struct_Union
          SUCCESS = 0

          FIELDS = {
            SUCCESS => {:type => ::Thrift::Types::SET, :name => 'success', :element => {:type => ::Thrift::Types::I64}}
          }

          def struct_fields; FIELDS; end

          def validate
          end

          ::Thrift::Struct.generate_accessors self
        end

      end

    end
  end
end
