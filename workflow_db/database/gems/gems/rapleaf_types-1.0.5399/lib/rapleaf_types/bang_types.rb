#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'
require File.join File.dirname(__FILE__), 'mobile_types'
require File.join File.dirname(__FILE__), 'custom_id_types'
require File.join File.dirname(__FILE__), 'online_data_types'
require File.join File.dirname(__FILE__), 'spruce_types'
require File.join File.dirname(__FILE__), 'abilitec_types'
require File.join File.dirname(__FILE__), 'pii_integration_types'
require File.join File.dirname(__FILE__), 'user_agent_types'
require File.join File.dirname(__FILE__), 'doc_ids_types'
require File.join File.dirname(__FILE__), 'translator_enums_types'


module Liveramp
  module Types
    module Bang
      module BangEdgeType
        COOKIE_SYNCING = 1
        ID_SYNC_IMPORT = 2
        COOKIE_PUBLISHER = 6
        MOBILE_PUBLISHER = 7
        CUSTOM_ID_IMPORT = 8
        NAP_FRINGE_EQUIV = 9
        HOUSEHOLD_FRINGE_EQUIV = 10
        MOBILE_STATISTICAL_IDENTIFICATION = 11
        MOBILE_ID_RESOLUTION = 12
        CUSTOM_ID_RESOLUTION = 13
        PEL_COOKIE_SYNC = 14
        CUSTOM_ID_MATCH_IMPORT = 15
        STATISTICAL_CROSS_DEVICE_A = 16
        STATISTICAL_CROSS_DEVICE_B = 17
        STATISTICAL_CROSS_DEVICE_C = 18
        STATISTICAL_CROSS_DEVICE_D = 19
        ACXIOM_HH_MAPPING = 20
        COOKIE_PEL_PUBLISHER = 21
        COOKIE_STATISTICAL_IDENTIFICATION = 22
        CUSTOM_ID_PEL_MATCH_IMPORT = 23
        ACXIOM_ZIP4_MAPPING = 24
        HEID_PEL_MAPPING = 25
        MOBILE_PEL_PUBLISHER = 26
        MUID_PUBLISHER = 27
        PEL_TO_PEL = 28
        COOKIE_3RD_PARTY_STATISTICAL_IDENTIFICATION = 29
        MOBILE_3RD_PARTY_STATISTICAL_IDENTIFICATION = 30
        ACXIOM_NAME_AND_CITY_MAPPING = 31
        IDENTIFIED_COOKIE_SYNCING = 32
        MOBILE_PEL_PUBLISHER_EU = 33
        HH_WF_COLLAPSING = 34
        HH_COLLAPSE_PEL_TO_COOKIE = 35
        HH_COLLAPSE_PEL_TO_MOBILE = 36
        HH_COLLAPSE_PEL_TO_CID = 37
        ZIP4_WF_COLLAPSING = 38
        ZIP4_COLLAPSE_PEL_TO_COOKIE = 39
        ZIP4_COLLAPSE_PEL_TO_MOBILE = 40
        ZIP4_COLLAPSE_PEL_TO_CID = 41
        HH_COLLAPSE_PEL_TO_PEL = 42
        ZIP4_COLLAPSE_PEL_TO_PEL = 43
        PP_COLLAPSE_COOKIE = 44
        PP_COLLAPSE_MOBILE = 45
        PP_COLLAPSE_CID = 46
        HH_COLLAPSE_PEL_TO_3RD_PARTY_COOKIE = 47
        HH_COLLAPSE_PEL_TO_3RD_PARTY_MOBILE = 48
        ZIP4_COLLAPSE_PEL_TO_3RD_PARTY_COOKIE = 49
        ZIP4_COLLAPSE_PEL_TO_3RD_PARTY_MOBILE = 50
        PP_COLLAPSE_3RD_PARTY_COOKIE = 51
        PP_COLLAPSE_3RD_PARTY_MOBILE = 52
        CROSS_DEVICE_3RD_PARTY = 53
        PP_COLLAPSE_STATISTICAL_MOBILE = 54
        HH_COLLAPSE_STATISTICAL_MOBILE = 55
        ZIP4_COLLAPSE_STATISTICAL_MOBILE = 56
        MOBILE_3RD_PARTY_STATISTICAL_IDENTIFICATION_EU = 57
        DETERMINISTIC_CROSS_DEVICE_PUBLISHER = 58
        STATISTICAL_CROSS_DEVICE_PUBLISHER = 59
        STATISTICAL_MOBILE_PEL_PUBLISHER = 60
        STATISTICAL_COOKIE_PEL_PUBLISHER = 61
        STATISTICAL_CID_PEL_PUBLISHER = 62
        PEL_PEL_3RD_PARTY_STATISTICAL = 63
        UNRESOLVED_COOKIE_DOC_PUBLISHER = 64
        UNRESOLVED_MOBILE_DOC_PUBLISHER = 65
        UNRESOLVED_CUSTOM_ID_DOC_MATCH_IMPORT = 66
        COOKIE_DOC_PUBLISHER = 67
        MOBILE_DOC_PUBLISHER = 68
        CUSTOM_ID_DOC_MATCH_IMPORT = 69
        VALUE_MAP = {1 => "COOKIE_SYNCING", 2 => "ID_SYNC_IMPORT", 6 => "COOKIE_PUBLISHER", 7 => "MOBILE_PUBLISHER", 8 => "CUSTOM_ID_IMPORT", 9 => "NAP_FRINGE_EQUIV", 10 => "HOUSEHOLD_FRINGE_EQUIV", 11 => "MOBILE_STATISTICAL_IDENTIFICATION", 12 => "MOBILE_ID_RESOLUTION", 13 => "CUSTOM_ID_RESOLUTION", 14 => "PEL_COOKIE_SYNC", 15 => "CUSTOM_ID_MATCH_IMPORT", 16 => "STATISTICAL_CROSS_DEVICE_A", 17 => "STATISTICAL_CROSS_DEVICE_B", 18 => "STATISTICAL_CROSS_DEVICE_C", 19 => "STATISTICAL_CROSS_DEVICE_D", 20 => "ACXIOM_HH_MAPPING", 21 => "COOKIE_PEL_PUBLISHER", 22 => "COOKIE_STATISTICAL_IDENTIFICATION", 23 => "CUSTOM_ID_PEL_MATCH_IMPORT", 24 => "ACXIOM_ZIP4_MAPPING", 25 => "HEID_PEL_MAPPING", 26 => "MOBILE_PEL_PUBLISHER", 27 => "MUID_PUBLISHER", 28 => "PEL_TO_PEL", 29 => "COOKIE_3RD_PARTY_STATISTICAL_IDENTIFICATION", 30 => "MOBILE_3RD_PARTY_STATISTICAL_IDENTIFICATION", 31 => "ACXIOM_NAME_AND_CITY_MAPPING", 32 => "IDENTIFIED_COOKIE_SYNCING", 33 => "MOBILE_PEL_PUBLISHER_EU", 34 => "HH_WF_COLLAPSING", 35 => "HH_COLLAPSE_PEL_TO_COOKIE", 36 => "HH_COLLAPSE_PEL_TO_MOBILE", 37 => "HH_COLLAPSE_PEL_TO_CID", 38 => "ZIP4_WF_COLLAPSING", 39 => "ZIP4_COLLAPSE_PEL_TO_COOKIE", 40 => "ZIP4_COLLAPSE_PEL_TO_MOBILE", 41 => "ZIP4_COLLAPSE_PEL_TO_CID", 42 => "HH_COLLAPSE_PEL_TO_PEL", 43 => "ZIP4_COLLAPSE_PEL_TO_PEL", 44 => "PP_COLLAPSE_COOKIE", 45 => "PP_COLLAPSE_MOBILE", 46 => "PP_COLLAPSE_CID", 47 => "HH_COLLAPSE_PEL_TO_3RD_PARTY_COOKIE", 48 => "HH_COLLAPSE_PEL_TO_3RD_PARTY_MOBILE", 49 => "ZIP4_COLLAPSE_PEL_TO_3RD_PARTY_COOKIE", 50 => "ZIP4_COLLAPSE_PEL_TO_3RD_PARTY_MOBILE", 51 => "PP_COLLAPSE_3RD_PARTY_COOKIE", 52 => "PP_COLLAPSE_3RD_PARTY_MOBILE", 53 => "CROSS_DEVICE_3RD_PARTY", 54 => "PP_COLLAPSE_STATISTICAL_MOBILE", 55 => "HH_COLLAPSE_STATISTICAL_MOBILE", 56 => "ZIP4_COLLAPSE_STATISTICAL_MOBILE", 57 => "MOBILE_3RD_PARTY_STATISTICAL_IDENTIFICATION_EU", 58 => "DETERMINISTIC_CROSS_DEVICE_PUBLISHER", 59 => "STATISTICAL_CROSS_DEVICE_PUBLISHER", 60 => "STATISTICAL_MOBILE_PEL_PUBLISHER", 61 => "STATISTICAL_COOKIE_PEL_PUBLISHER", 62 => "STATISTICAL_CID_PEL_PUBLISHER", 63 => "PEL_PEL_3RD_PARTY_STATISTICAL", 64 => "UNRESOLVED_COOKIE_DOC_PUBLISHER", 65 => "UNRESOLVED_MOBILE_DOC_PUBLISHER", 66 => "UNRESOLVED_CUSTOM_ID_DOC_MATCH_IMPORT", 67 => "COOKIE_DOC_PUBLISHER", 68 => "MOBILE_DOC_PUBLISHER", 69 => "CUSTOM_ID_DOC_MATCH_IMPORT"}
        VALID_VALUES = Set.new([COOKIE_SYNCING, ID_SYNC_IMPORT, COOKIE_PUBLISHER, MOBILE_PUBLISHER, CUSTOM_ID_IMPORT, NAP_FRINGE_EQUIV, HOUSEHOLD_FRINGE_EQUIV, MOBILE_STATISTICAL_IDENTIFICATION, MOBILE_ID_RESOLUTION, CUSTOM_ID_RESOLUTION, PEL_COOKIE_SYNC, CUSTOM_ID_MATCH_IMPORT, STATISTICAL_CROSS_DEVICE_A, STATISTICAL_CROSS_DEVICE_B, STATISTICAL_CROSS_DEVICE_C, STATISTICAL_CROSS_DEVICE_D, ACXIOM_HH_MAPPING, COOKIE_PEL_PUBLISHER, COOKIE_STATISTICAL_IDENTIFICATION, CUSTOM_ID_PEL_MATCH_IMPORT, ACXIOM_ZIP4_MAPPING, HEID_PEL_MAPPING, MOBILE_PEL_PUBLISHER, MUID_PUBLISHER, PEL_TO_PEL, COOKIE_3RD_PARTY_STATISTICAL_IDENTIFICATION, MOBILE_3RD_PARTY_STATISTICAL_IDENTIFICATION, ACXIOM_NAME_AND_CITY_MAPPING, IDENTIFIED_COOKIE_SYNCING, MOBILE_PEL_PUBLISHER_EU, HH_WF_COLLAPSING, HH_COLLAPSE_PEL_TO_COOKIE, HH_COLLAPSE_PEL_TO_MOBILE, HH_COLLAPSE_PEL_TO_CID, ZIP4_WF_COLLAPSING, ZIP4_COLLAPSE_PEL_TO_COOKIE, ZIP4_COLLAPSE_PEL_TO_MOBILE, ZIP4_COLLAPSE_PEL_TO_CID, HH_COLLAPSE_PEL_TO_PEL, ZIP4_COLLAPSE_PEL_TO_PEL, PP_COLLAPSE_COOKIE, PP_COLLAPSE_MOBILE, PP_COLLAPSE_CID, HH_COLLAPSE_PEL_TO_3RD_PARTY_COOKIE, HH_COLLAPSE_PEL_TO_3RD_PARTY_MOBILE, ZIP4_COLLAPSE_PEL_TO_3RD_PARTY_COOKIE, ZIP4_COLLAPSE_PEL_TO_3RD_PARTY_MOBILE, PP_COLLAPSE_3RD_PARTY_COOKIE, PP_COLLAPSE_3RD_PARTY_MOBILE, CROSS_DEVICE_3RD_PARTY, PP_COLLAPSE_STATISTICAL_MOBILE, HH_COLLAPSE_STATISTICAL_MOBILE, ZIP4_COLLAPSE_STATISTICAL_MOBILE, MOBILE_3RD_PARTY_STATISTICAL_IDENTIFICATION_EU, DETERMINISTIC_CROSS_DEVICE_PUBLISHER, STATISTICAL_CROSS_DEVICE_PUBLISHER, STATISTICAL_MOBILE_PEL_PUBLISHER, STATISTICAL_COOKIE_PEL_PUBLISHER, STATISTICAL_CID_PEL_PUBLISHER, PEL_PEL_3RD_PARTY_STATISTICAL, UNRESOLVED_COOKIE_DOC_PUBLISHER, UNRESOLVED_MOBILE_DOC_PUBLISHER, UNRESOLVED_CUSTOM_ID_DOC_MATCH_IMPORT, COOKIE_DOC_PUBLISHER, MOBILE_DOC_PUBLISHER, CUSTOM_ID_DOC_MATCH_IMPORT]).freeze
      end

      module PartialPathType
        SOURCE = 1
        TARGET = 2
        VALUE_MAP = {1 => "SOURCE", 2 => "TARGET"}
        VALID_VALUES = Set.new([SOURCE, TARGET]).freeze
      end

      class EdgeImportInfo; end

      class BangEdgeSource; end

      class UnmatchedIdentifier; end

      class OptoutPEL; end

      class AnonymousIdentifier < ::Thrift::Union; end

      class OptoutIdentifier; end

      class BangEdge; end

      class BangEdgeWithDeletionFlag; end

      class LiverampCookieMetadata; end

      class LiverampMobileMetadata; end

      class ThirdPartyGraphMetadata; end

      class PelMetadata; end

      class ArlMetadata; end

      class AnonymousIdentifierMetadata < ::Thrift::Union; end

      class IdAndMetadata; end

      class KeyedAnonymousIdentifierMetadata; end

      class PregelEdgeValue; end

      class BangPathElem; end

      class PregelMessage; end

      class PregelOutputPath; end

      class PregelVertexValue; end

      class CidMappingsAndRelatedEdges; end

      class RawMuidMapping; end

      class PartitionedMobileMetadataEntry; end

      class MobileEdgeEntry < ::Thrift::Union; end

      class BadDataNode; end

      class EdgeImportInfo
        include ::Thrift::Struct, ::Thrift::Struct_Union
        IMPORT_IDS = 1
        IMPORT_COUNT = 2

        FIELDS = {
          # This is a capped list of imports that contributed the edge. If the size limit is exceeded,
# the oldest imports are removed to make space for newer ones as they are added.
# 
          IMPORT_IDS => {:type => ::Thrift::Types::SET, :name => 'import_ids', :element => {:type => ::Thrift::Types::I64}},
          # We need to keep track of how many imports were added separately from the imports_ids list above.
# If this list becomes emtpy, we will know whether there are any old imports absent from the list
# but still contributing to the edge or not.
# 
          IMPORT_COUNT => {:type => ::Thrift::Types::I32, :name => 'import_count'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field import_ids is unset!') unless @import_ids
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field import_count is unset!') unless @import_count
        end

        ::Thrift::Struct.generate_accessors self
      end

      class BangEdgeSource
        include ::Thrift::Struct, ::Thrift::Struct_Union
        TYPE = 1
        OWNER = 2
        MATCH_DATA_PROVIDER_TO_IMPORT_INFO = 3
        COLLAPSED_EDGE_OWNERS = 4
        SILO_TO_IMPORT_INFO = 5

        FIELDS = {
          TYPE => {:type => ::Thrift::Types::I32, :name => 'type', :enum_class => ::Liveramp::Types::Bang::BangEdgeType},
          OWNER => {:type => ::Thrift::Types::I64, :name => 'owner', :optional => true},
          # Deprecated. This will be replaced by silo_to_import_info below.
# 
          MATCH_DATA_PROVIDER_TO_IMPORT_INFO => {:type => ::Thrift::Types::MAP, :name => 'match_data_provider_to_import_info', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::Bang::EdgeImportInfo}, :optional => true},
          COLLAPSED_EDGE_OWNERS => {:type => ::Thrift::Types::SET, :name => 'collapsed_edge_owners', :element => {:type => ::Thrift::Types::I64}, :optional => true},
          # This map is used to keep track of which silos and imports contributed
# this edge, so that we have the ability to delete imports without recomputing the store
# from all original imports.
# 
          SILO_TO_IMPORT_INFO => {:type => ::Thrift::Types::MAP, :name => 'silo_to_import_info', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::Bang::EdgeImportInfo}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field type is unset!') unless @type
          unless @type.nil? || ::Liveramp::Types::Bang::BangEdgeType::VALID_VALUES.include?(@type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field type!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class UnmatchedIdentifier
        include ::Thrift::Struct, ::Thrift::Struct_Union
        RANDOM_BYTES = 1

        FIELDS = {
          RANDOM_BYTES => {:type => ::Thrift::Types::STRING, :name => 'random_bytes', :binary => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field random_bytes is unset!') unless @random_bytes
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Special type to denote optouts in Partner Link mappings. By using a different type from
# regular PELs, it forces the consumer to explicitly have to deal with it.
      class OptoutPEL
        include ::Thrift::Struct, ::Thrift::Struct_Union
        RANDOM_BYTES = 1

        FIELDS = {
          RANDOM_BYTES => {:type => ::Thrift::Types::STRING, :name => 'random_bytes', :binary => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class AnonymousIdentifier < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def liveramp_cookie_id(val)
            AnonymousIdentifier.new(:liveramp_cookie_id, val)
          end

          def liveramp_mobile_id(val)
            AnonymousIdentifier.new(:liveramp_mobile_id, val)
          end

          def liveramp_custom_id(val)
            AnonymousIdentifier.new(:liveramp_custom_id, val)
          end

          def synced_cookie(val)
            AnonymousIdentifier.new(:synced_cookie, val)
          end

          def muid(val)
            AnonymousIdentifier.new(:muid, val)
          end

          def custom_id(val)
            AnonymousIdentifier.new(:custom_id, val)
          end

          def heid(val)
            AnonymousIdentifier.new(:heid, val)
          end

          def unmatched_id(val)
            AnonymousIdentifier.new(:unmatched_id, val)
          end

          def anonymous_pin(val)
            AnonymousIdentifier.new(:anonymous_pin, val)
          end

          def ash_id(val)
            AnonymousIdentifier.new(:ash_id, val)
          end

          def household_pel(val)
            AnonymousIdentifier.new(:household_pel, val)
          end

          def zip4_pearl(val)
            AnonymousIdentifier.new(:zip4_pearl, val)
          end

          def eh_pii(val)
            AnonymousIdentifier.new(:eh_pii, val)
          end

          def optout_pel(val)
            AnonymousIdentifier.new(:optout_pel, val)
          end

          def pel(val)
            AnonymousIdentifier.new(:pel, val)
          end

          def name_and_city_pearl(val)
            AnonymousIdentifier.new(:name_and_city_pearl, val)
          end

          def individual_anon_doc(val)
            AnonymousIdentifier.new(:individual_anon_doc, val)
          end

          def household_anon_doc(val)
            AnonymousIdentifier.new(:household_anon_doc, val)
          end

          def zip4_anon_doc(val)
            AnonymousIdentifier.new(:zip4_anon_doc, val)
          end

          def arl(val)
            AnonymousIdentifier.new(:arl, val)
          end

          def encrypted_hashed_pii(val)
            AnonymousIdentifier.new(:encrypted_hashed_pii, val)
          end
        end

        LIVERAMP_COOKIE_ID = 1
        LIVERAMP_MOBILE_ID = 2
        LIVERAMP_CUSTOM_ID = 3
        SYNCED_COOKIE = 4
        MUID = 5
        CUSTOM_ID = 6
        HEID = 7
        UNMATCHED_ID = 8
        ANONYMOUS_PIN = 9
        ASH_ID = 10
        HOUSEHOLD_PEL = 11
        ZIP4_PEARL = 12
        EH_PII = 13
        OPTOUT_PEL = 14
        PEL = 15
        NAME_AND_CITY_PEARL = 16
        INDIVIDUAL_ANON_DOC = 17
        HOUSEHOLD_ANON_DOC = 18
        ZIP4_ANON_DOC = 19
        ARL = 20
        ENCRYPTED_HASHED_PII = 21

        FIELDS = {
          LIVERAMP_COOKIE_ID => {:type => ::Thrift::Types::STRING, :name => 'liveramp_cookie_id', :binary => true, :optional => true},
          LIVERAMP_MOBILE_ID => {:type => ::Thrift::Types::STRING, :name => 'liveramp_mobile_id', :binary => true, :optional => true},
          LIVERAMP_CUSTOM_ID => {:type => ::Thrift::Types::STRING, :name => 'liveramp_custom_id', :binary => true, :optional => true},
          SYNCED_COOKIE => {:type => ::Thrift::Types::STRUCT, :name => 'synced_cookie', :class => ::Liveramp::OnlineData::SyncedCookie, :optional => true},
          MUID => {:type => ::Thrift::Types::STRUCT, :name => 'muid', :class => ::Liveramp::Types::Mobile::MUID, :optional => true},
          CUSTOM_ID => {:type => ::Thrift::Types::STRUCT, :name => 'custom_id', :class => ::Liveramp::Types::CustomId::CustomId, :optional => true},
          HEID => {:type => ::Thrift::Types::STRING, :name => 'heid', :binary => true, :optional => true},
          UNMATCHED_ID => {:type => ::Thrift::Types::STRUCT, :name => 'unmatched_id', :class => ::Liveramp::Types::Bang::UnmatchedIdentifier, :optional => true},
          ANONYMOUS_PIN => {:type => ::Thrift::Types::STRING, :name => 'anonymous_pin', :binary => true, :optional => true},
          ASH_ID => {:type => ::Thrift::Types::STRUCT, :name => 'ash_id', :class => ::Liveramp::Abilitec::AshId, :optional => true},
          HOUSEHOLD_PEL => {:type => ::Thrift::Types::STRUCT, :name => 'household_pel', :class => ::Liveramp::Abilitec::HouseholdPel, :optional => true},
          ZIP4_PEARL => {:type => ::Thrift::Types::STRUCT, :name => 'zip4_pearl', :class => ::Liveramp::Abilitec::Zip4Pearl, :optional => true},
          EH_PII => {:type => ::Thrift::Types::STRUCT, :name => 'eh_pii', :class => ::Liveramp::Types::PiiIntegration::EHPii, :optional => true},
          OPTOUT_PEL => {:type => ::Thrift::Types::STRUCT, :name => 'optout_pel', :class => ::Liveramp::Types::Bang::OptoutPEL, :optional => true},
          # PELs are represented as CustomId almost everywhere. Initially only PARC will
# use this new type internally.
# 
          PEL => {:type => ::Thrift::Types::STRUCT, :name => 'pel', :class => ::Liveramp::Abilitec::PEL, :optional => true},
          NAME_AND_CITY_PEARL => {:type => ::Thrift::Types::STRUCT, :name => 'name_and_city_pearl', :class => ::Liveramp::Abilitec::NameAndCityPearl, :optional => true},
          INDIVIDUAL_ANON_DOC => {:type => ::Thrift::Types::STRUCT, :name => 'individual_anon_doc', :class => ::Liveramp::DocIds::AnonDoc, :optional => true},
          HOUSEHOLD_ANON_DOC => {:type => ::Thrift::Types::STRUCT, :name => 'household_anon_doc', :class => ::Liveramp::DocIds::HouseholdAnonDoc, :optional => true},
          ZIP4_ANON_DOC => {:type => ::Thrift::Types::STRUCT, :name => 'zip4_anon_doc', :class => ::Liveramp::DocIds::Zip4AnonDoc, :optional => true},
          ARL => {:type => ::Thrift::Types::STRUCT, :name => 'arl', :class => ::Liveramp::Abilitec::Arl, :optional => true},
          ENCRYPTED_HASHED_PII => {:type => ::Thrift::Types::STRUCT, :name => 'encrypted_hashed_pii', :class => ::Liveramp::Types::PiiIntegration::EncryptedHashedPii, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      # This generic type replaces the legacy types OptOutCookie, OptOutLrmid and OptOutCustomId.
# 
      class OptoutIdentifier
        include ::Thrift::Struct, ::Thrift::Struct_Union
        IDENTIFIER = 1
        OPTED_OUT_AT = 2
        RELATED_IDENTIFIERS = 3

        FIELDS = {
          IDENTIFIER => {:type => ::Thrift::Types::STRUCT, :name => 'identifier', :class => ::Liveramp::Types::Bang::AnonymousIdentifier},
          OPTED_OUT_AT => {:type => ::Thrift::Types::I64, :name => 'opted_out_at'},
          RELATED_IDENTIFIERS => {:type => ::Thrift::Types::SET, :name => 'related_identifiers', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::Bang::AnonymousIdentifier}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field identifier is unset!') unless @identifier
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field opted_out_at is unset!') unless @opted_out_at
        end

        ::Thrift::Struct.generate_accessors self
      end

      class BangEdge
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SOURCE = 1
        TARGET = 2
        BANG_EDGE_SOURCE = 3
        TIMESTAMP = 4

        FIELDS = {
          SOURCE => {:type => ::Thrift::Types::STRUCT, :name => 'source', :class => ::Liveramp::Types::Bang::AnonymousIdentifier},
          TARGET => {:type => ::Thrift::Types::STRUCT, :name => 'target', :class => ::Liveramp::Types::Bang::AnonymousIdentifier},
          BANG_EDGE_SOURCE => {:type => ::Thrift::Types::STRUCT, :name => 'bang_edge_source', :class => ::Liveramp::Types::Bang::BangEdgeSource},
          TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'timestamp'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field source is unset!') unless @source
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field target is unset!') unless @target
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field bang_edge_source is unset!') unless @bang_edge_source
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field timestamp is unset!') unless @timestamp
        end

        ::Thrift::Struct.generate_accessors self
      end

      class BangEdgeWithDeletionFlag
        include ::Thrift::Struct, ::Thrift::Struct_Union
        EDGE = 1
        SHOULD_DELETE = 2

        FIELDS = {
          EDGE => {:type => ::Thrift::Types::STRUCT, :name => 'edge', :class => ::Liveramp::Types::Bang::BangEdge},
          SHOULD_DELETE => {:type => ::Thrift::Types::BOOL, :name => 'should_delete'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field edge is unset!') unless @edge
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field should_delete is unset!') if @should_delete.nil?
        end

        ::Thrift::Struct.generate_accessors self
      end

      class LiverampCookieMetadata
        include ::Thrift::Struct, ::Thrift::Struct_Union
        LAST_SEEN_AT = 1
        USER_AGENT = 2
        SYNCED_INTERNAL_ANAS = 3
        USER_AGENT_ENUM = 4

        FIELDS = {
          LAST_SEEN_AT => {:type => ::Thrift::Types::I64, :name => 'last_seen_at'},
          USER_AGENT => {:type => ::Thrift::Types::STRING, :name => 'user_agent', :optional => true},
          SYNCED_INTERNAL_ANAS => {:type => ::Thrift::Types::SET, :name => 'synced_internal_anas', :element => {:type => ::Thrift::Types::I64}, :optional => true},
          USER_AGENT_ENUM => {:type => ::Thrift::Types::STRUCT, :name => 'user_agent_enum', :class => ::Liveramp::UserAgent::UserAgent, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field last_seen_at is unset!') unless @last_seen_at
        end

        ::Thrift::Struct.generate_accessors self
      end

      class LiverampMobileMetadata
        include ::Thrift::Struct, ::Thrift::Struct_Union
        LAST_SEEN_AT = 1
        LAST_IMPORTED_AT = 2
        MUID_TO_PUBLISHER_IDS = 3

        FIELDS = {
          # Timestamp in seconds
          LAST_SEEN_AT => {:type => ::Thrift::Types::I64, :name => 'last_seen_at'},
          LAST_IMPORTED_AT => {:type => ::Thrift::Types::I64, :name => 'last_imported_at'},
          MUID_TO_PUBLISHER_IDS => {:type => ::Thrift::Types::MAP, :name => 'muid_to_publisher_ids', :key => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::Mobile::MUID}, :value => {:type => ::Thrift::Types::SET, :element => {:type => ::Thrift::Types::I32}}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field last_seen_at is unset!') unless @last_seen_at
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field last_imported_at is unset!') unless @last_imported_at
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ThirdPartyGraphMetadata
        include ::Thrift::Struct, ::Thrift::Struct_Union
        GROUP_ID = 1

        FIELDS = {
          GROUP_ID => {:type => ::Thrift::Types::STRING, :name => 'group_id'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field group_id is unset!') unless @group_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      class PelMetadata
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PII_TYPE = 1

        FIELDS = {
          PII_TYPE => {:type => ::Thrift::Types::I32, :name => 'pii_type', :optional => true, :enum_class => ::Liveramp::Identity::TranslatorEnums::TranslatorPiiType}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @pii_type.nil? || ::Liveramp::Identity::TranslatorEnums::TranslatorPiiType::VALID_VALUES.include?(@pii_type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field pii_type!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ArlMetadata
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PII_TYPE = 1

        FIELDS = {
          PII_TYPE => {:type => ::Thrift::Types::I32, :name => 'pii_type', :optional => true, :enum_class => ::Liveramp::Identity::TranslatorEnums::TranslatorPiiType}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @pii_type.nil? || ::Liveramp::Identity::TranslatorEnums::TranslatorPiiType::VALID_VALUES.include?(@pii_type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field pii_type!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class AnonymousIdentifierMetadata < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def liveramp_cookie_metadata(val)
            AnonymousIdentifierMetadata.new(:liveramp_cookie_metadata, val)
          end

          def liveramp_mobile_metadata(val)
            AnonymousIdentifierMetadata.new(:liveramp_mobile_metadata, val)
          end

          def third_party_graph_metadata(val)
            AnonymousIdentifierMetadata.new(:third_party_graph_metadata, val)
          end

          def mobile_metadata_eu(val)
            AnonymousIdentifierMetadata.new(:mobile_metadata_eu, val)
          end

          def doc_metadata(val)
            AnonymousIdentifierMetadata.new(:doc_metadata, val)
          end

          def pel_metadata(val)
            AnonymousIdentifierMetadata.new(:pel_metadata, val)
          end

          def arl_metadata(val)
            AnonymousIdentifierMetadata.new(:arl_metadata, val)
          end
        end

        LIVERAMP_COOKIE_METADATA = 1
        LIVERAMP_MOBILE_METADATA = 2
        THIRD_PARTY_GRAPH_METADATA = 3
        MOBILE_METADATA_EU = 4
        DOC_METADATA = 5
        PEL_METADATA = 6
        ARL_METADATA = 7

        FIELDS = {
          LIVERAMP_COOKIE_METADATA => {:type => ::Thrift::Types::STRUCT, :name => 'liveramp_cookie_metadata', :class => ::Liveramp::Types::Bang::LiverampCookieMetadata, :optional => true},
          LIVERAMP_MOBILE_METADATA => {:type => ::Thrift::Types::STRUCT, :name => 'liveramp_mobile_metadata', :class => ::Liveramp::Types::Bang::LiverampMobileMetadata, :optional => true},
          THIRD_PARTY_GRAPH_METADATA => {:type => ::Thrift::Types::STRUCT, :name => 'third_party_graph_metadata', :class => ::Liveramp::Types::Bang::ThirdPartyGraphMetadata, :optional => true},
          MOBILE_METADATA_EU => {:type => ::Thrift::Types::STRUCT, :name => 'mobile_metadata_eu', :class => ::Liveramp::Types::Bang::LiverampMobileMetadata, :optional => true},
          DOC_METADATA => {:type => ::Thrift::Types::STRUCT, :name => 'doc_metadata', :class => ::Liveramp::DocIds::DocMetadata, :optional => true},
          PEL_METADATA => {:type => ::Thrift::Types::STRUCT, :name => 'pel_metadata', :class => ::Liveramp::Types::Bang::PelMetadata, :optional => true},
          ARL_METADATA => {:type => ::Thrift::Types::STRUCT, :name => 'arl_metadata', :class => ::Liveramp::Types::Bang::ArlMetadata, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class IdAndMetadata
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ID = 1
        METADATA = 2

        FIELDS = {
          ID => {:type => ::Thrift::Types::STRUCT, :name => 'id', :class => ::Liveramp::Types::Bang::AnonymousIdentifier},
          METADATA => {:type => ::Thrift::Types::STRUCT, :name => 'metadata', :class => ::Liveramp::Types::Bang::AnonymousIdentifierMetadata, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class KeyedAnonymousIdentifierMetadata
        include ::Thrift::Struct, ::Thrift::Struct_Union
        KEY = 1
        METADATA = 2
        MATCH_DATA_PROVIDER_TO_IMPORT_INFO = 3
        SILO_TO_IMPORT_INFO = 4

        FIELDS = {
          KEY => {:type => ::Thrift::Types::STRUCT, :name => 'key', :class => ::Liveramp::Types::Bang::AnonymousIdentifier},
          METADATA => {:type => ::Thrift::Types::STRUCT, :name => 'metadata', :class => ::Liveramp::Types::Bang::AnonymousIdentifierMetadata},
          # Deprecated. This will be replaced by silo_to_import_info below.
# 
          MATCH_DATA_PROVIDER_TO_IMPORT_INFO => {:type => ::Thrift::Types::MAP, :name => 'match_data_provider_to_import_info', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::Bang::EdgeImportInfo}, :optional => true},
          SILO_TO_IMPORT_INFO => {:type => ::Thrift::Types::MAP, :name => 'silo_to_import_info', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::Bang::EdgeImportInfo}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field key is unset!') unless @key
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field metadata is unset!') unless @metadata
        end

        ::Thrift::Struct.generate_accessors self
      end

      class PregelEdgeValue
        include ::Thrift::Struct, ::Thrift::Struct_Union
        BANG_EDGE_SOURCE = 1
        TIMESTAMP = 2

        FIELDS = {
          BANG_EDGE_SOURCE => {:type => ::Thrift::Types::STRUCT, :name => 'bang_edge_source', :class => ::Liveramp::Types::Bang::BangEdgeSource},
          TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'timestamp'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field bang_edge_source is unset!') unless @bang_edge_source
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field timestamp is unset!') unless @timestamp
        end

        ::Thrift::Struct.generate_accessors self
      end

      # An element in a path. The edge_value implicitly refers to the edge between
# this and the previous/next vertex in the path.
# 
      class BangPathElem
        include ::Thrift::Struct, ::Thrift::Struct_Union
        IDENTIFIER = 1
        EDGE_VALUE = 2
        IDENTIFIER_METADATA = 3

        FIELDS = {
          IDENTIFIER => {:type => ::Thrift::Types::STRUCT, :name => 'identifier', :class => ::Liveramp::Types::Bang::AnonymousIdentifier},
          EDGE_VALUE => {:type => ::Thrift::Types::STRUCT, :name => 'edge_value', :class => ::Liveramp::Types::Bang::PregelEdgeValue},
          IDENTIFIER_METADATA => {:type => ::Thrift::Types::STRUCT, :name => 'identifier_metadata', :class => ::Liveramp::Types::Bang::AnonymousIdentifierMetadata, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field identifier is unset!') unless @identifier
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field edge_value is unset!') unless @edge_value
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A Pregel message represents a partial path. The destination vertex the message
# is sent to is implicitly the last element of the path.
# 
      class PregelMessage
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PATH_ELEMS = 1

        FIELDS = {
          PATH_ELEMS => {:type => ::Thrift::Types::LIST, :name => 'path_elems', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::Bang::BangPathElem}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field path_elems is unset!') unless @path_elems
        end

        ::Thrift::Struct.generate_accessors self
      end

      class PregelOutputPath
        include ::Thrift::Struct, ::Thrift::Struct_Union
        KEY = 1
        PATH_ELEMS = 2
        KEY_METADATA = 3
        CONFIG_DIGESTS = 4

        FIELDS = {
          KEY => {:type => ::Thrift::Types::STRUCT, :name => 'key', :class => ::Liveramp::Types::Bang::AnonymousIdentifier},
          PATH_ELEMS => {:type => ::Thrift::Types::LIST, :name => 'path_elems', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::Bang::BangPathElem}},
          KEY_METADATA => {:type => ::Thrift::Types::STRUCT, :name => 'key_metadata', :class => ::Liveramp::Types::Bang::AnonymousIdentifierMetadata, :optional => true},
          CONFIG_DIGESTS => {:type => ::Thrift::Types::SET, :name => 'config_digests', :element => {:type => ::Thrift::Types::I32}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field key is unset!') unless @key
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field path_elems is unset!') unless @path_elems
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field config_digests is unset!') unless @config_digests
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Initially, the vertex value is just metadata for the identifier.
# After the Pregel computation, certain vertices hold the output paths
# in their values as well.
# 
      class PregelVertexValue
        include ::Thrift::Struct, ::Thrift::Struct_Union
        METADATA = 1
        OUTPUT_PATHS = 2
        PARTIAL_PATHS = 4

        FIELDS = {
          METADATA => {:type => ::Thrift::Types::STRUCT, :name => 'metadata', :class => ::Liveramp::Types::Bang::AnonymousIdentifierMetadata, :optional => true},
          OUTPUT_PATHS => {:type => ::Thrift::Types::SET, :name => 'output_paths', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::Bang::PregelOutputPath}, :optional => true},
          # Field to temporarily store the messages from one superstep to have them
# available in the following superstep. This is necessary because when a path's
# length is even, there won't be a vertex in the middle receiving both halves
# of the path in the same superstep. There will be two nodes in the middle, each
# receiving the shorter half of the path in one superstep and the longer one in
# the following superstep.
# 
          PARTIAL_PATHS => {:type => ::Thrift::Types::SET, :name => 'partial_paths', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::Bang::PregelMessage}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Deprecated.
# Temporary struct used to compare UIS against edges
      class CidMappingsAndRelatedEdges
        include ::Thrift::Struct, ::Thrift::Struct_Union
        MAPPINGS = 1
        IMPORT_EDGES = 2
        RESOLVE_EDGES = 3

        FIELDS = {
          MAPPINGS => {:type => ::Thrift::Types::SET, :name => 'mappings', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::CustomId::CustomIdMapping}},
          IMPORT_EDGES => {:type => ::Thrift::Types::SET, :name => 'import_edges', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::Bang::BangEdge}},
          RESOLVE_EDGES => {:type => ::Thrift::Types::SET, :name => 'resolve_edges', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::Bang::BangEdge}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field mappings is unset!') unless @mappings
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field import_edges is unset!') unless @import_edges
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field resolve_edges is unset!') unless @resolve_edges
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Deprecated.
# temporary struct used in mobile edge partitioning.
      class RawMuidMapping
        include ::Thrift::Struct, ::Thrift::Struct_Union
        LIVERAMP_MOBILE_ID = 1
        TARGET = 2
        LAST_IMPORTED_AT = 4
        LAST_SEEN_AT = 5
        OWNER = 6
        HEID = 7

        FIELDS = {
          LIVERAMP_MOBILE_ID => {:type => ::Thrift::Types::STRING, :name => 'liveramp_mobile_id', :binary => true},
          TARGET => {:type => ::Thrift::Types::STRUCT, :name => 'target', :class => ::Liveramp::Types::Bang::AnonymousIdentifier},
          LAST_IMPORTED_AT => {:type => ::Thrift::Types::I32, :name => 'last_imported_at'},
          LAST_SEEN_AT => {:type => ::Thrift::Types::I32, :name => 'last_seen_at', :optional => true},
          OWNER => {:type => ::Thrift::Types::I64, :name => 'owner', :optional => true},
          HEID => {:type => ::Thrift::Types::STRUCT, :name => 'heid', :class => ::Liveramp::Types::Bang::AnonymousIdentifier, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field liveramp_mobile_id is unset!') unless @liveramp_mobile_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field target is unset!') unless @target
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field last_imported_at is unset!') unless @last_imported_at
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Deprecated.
# pool id for knowing which partition to go to.
      class PartitionedMobileMetadataEntry
        include ::Thrift::Struct, ::Thrift::Struct_Union
        POOLID = 1
        METADATA = 2

        FIELDS = {
          POOLID => {:type => ::Thrift::Types::I32, :name => 'poolId'},
          METADATA => {:type => ::Thrift::Types::STRUCT, :name => 'metadata', :class => ::Liveramp::Types::Bang::KeyedAnonymousIdentifierMetadata}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field poolId is unset!') unless @poolId
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field metadata is unset!') unless @metadata
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Deprecated.
# temporary struct used in mobile edge partitioning. not stored anywhere.
      class MobileEdgeEntry < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def edge(val)
            MobileEdgeEntry.new(:edge, val)
          end

          def metadata(val)
            MobileEdgeEntry.new(:metadata, val)
          end
        end

        EDGE = 1
        METADATA = 2

        FIELDS = {
          EDGE => {:type => ::Thrift::Types::STRUCT, :name => 'edge', :class => ::Liveramp::Types::Bang::BangEdge, :optional => true},
          METADATA => {:type => ::Thrift::Types::STRUCT, :name => 'metadata', :class => ::Liveramp::Types::Bang::PartitionedMobileMetadataEntry, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class BadDataNode
        include ::Thrift::Struct, ::Thrift::Struct_Union
        DATA_NODE = 1
        IDENTIFIER_COUNT = 2
        LAST_FLAGGED_AS_BAD = 3

        FIELDS = {
          DATA_NODE => {:type => ::Thrift::Types::STRUCT, :name => 'data_node', :class => ::Liveramp::Types::Bang::AnonymousIdentifier},
          IDENTIFIER_COUNT => {:type => ::Thrift::Types::I32, :name => 'identifier_count'},
          LAST_FLAGGED_AS_BAD => {:type => ::Thrift::Types::I32, :name => 'last_flagged_as_bad'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field data_node is unset!') unless @data_node
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field identifier_count is unset!') unless @identifier_count
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field last_flagged_as_bad is unset!') unless @last_flagged_as_bad
        end

        ::Thrift::Struct.generate_accessors self
      end

    end
  end
end
