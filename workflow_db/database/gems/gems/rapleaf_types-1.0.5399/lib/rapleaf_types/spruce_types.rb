#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'
require File.join File.dirname(__FILE__), 'enums_types'
require File.join File.dirname(__FILE__), 'new_person_data_types'
require File.join File.dirname(__FILE__), 'audience_types'
require File.join File.dirname(__FILE__), 'mobile_types'
require File.join File.dirname(__FILE__), 'abilitec_types'
require File.join File.dirname(__FILE__), 'custom_id_types'
require File.join File.dirname(__FILE__), 'pii_integration_types'


module Rapleaf
  module Types
    module Spruce
      module Status
        ACTIVE = 1
        INACTIVE = 2
        DEFUNCT = 3
        VALUE_MAP = {1 => "ACTIVE", 2 => "INACTIVE", 3 => "DEFUNCT"}
        VALID_VALUES = Set.new([ACTIVE, INACTIVE, DEFUNCT]).freeze
      end

      module ElmoRequestType
        GIF = 1
        JS = 2
        HTML = 3
        VALUE_MAP = {1 => "GIF", 2 => "JS", 3 => "HTML"}
        VALID_VALUES = Set.new([GIF, JS, HTML]).freeze
      end

      module SupportedDataType
        RAW = 1
        SEGMENT = 2
        BOTH = 3
        NONE = 4
        HEID = 5
        VALUE_MAP = {1 => "RAW", 2 => "SEGMENT", 3 => "BOTH", 4 => "NONE", 5 => "HEID"}
        VALID_VALUES = Set.new([RAW, SEGMENT, BOTH, NONE, HEID]).freeze
      end

      module DataSourceType
        RAPLEAF = 1
        DATA_PARTNER = 2
        REQUEST_DATA = 3
        VALUE_MAP = {1 => "RAPLEAF", 2 => "DATA_PARTNER", 3 => "REQUEST_DATA"}
        VALID_VALUES = Set.new([RAPLEAF, DATA_PARTNER, REQUEST_DATA]).freeze
      end

      module SegmentType
        STANDARD = 1
        CUSTOM = 2
        CUSTOMER_LIST = 3
        VALUE_MAP = {1 => "STANDARD", 2 => "CUSTOM", 3 => "CUSTOMER_LIST"}
        VALID_VALUES = Set.new([STANDARD, CUSTOM, CUSTOMER_LIST]).freeze
      end

      module RotationStatus
        NEW = 1
        NEW_DATA = 2
        NEW_THIS_MONTH = 3
        REPEAT_THIS_MONTH = 4
        OVER_USAGE_LIMIT = 5
        REPEAT_THIS_DAY = 6
        VALUE_MAP = {1 => "NEW", 2 => "NEW_DATA", 3 => "NEW_THIS_MONTH", 4 => "REPEAT_THIS_MONTH", 5 => "OVER_USAGE_LIMIT", 6 => "REPEAT_THIS_DAY"}
        VALID_VALUES = Set.new([NEW, NEW_DATA, NEW_THIS_MONTH, REPEAT_THIS_MONTH, OVER_USAGE_LIMIT, REPEAT_THIS_DAY]).freeze
      end

      module LiveRampDeviceIdSource
        NAME_AND_DMA_MATCHING = 1
        ZIP_PLUS_4_MATCHING = 2
        IDENTIFIER_MATCHING = 3
        LIVERAMP_COOKIE_MATCHING = 4
        INFERRED_NAC_MATCHING = 5
        IP_MATCHING = 6
        ZIP_INFERENCE = 7
        VALUE_MAP = {1 => "NAME_AND_DMA_MATCHING", 2 => "ZIP_PLUS_4_MATCHING", 3 => "IDENTIFIER_MATCHING", 4 => "LIVERAMP_COOKIE_MATCHING", 5 => "INFERRED_NAC_MATCHING", 6 => "IP_MATCHING", 7 => "ZIP_INFERENCE"}
        VALID_VALUES = Set.new([NAME_AND_DMA_MATCHING, ZIP_PLUS_4_MATCHING, IDENTIFIER_MATCHING, LIVERAMP_COOKIE_MATCHING, INFERRED_NAC_MATCHING, IP_MATCHING, ZIP_INFERENCE]).freeze
      end

      module HeidChangeState
        NEW_HEID = 0
        UPDATE_HEID = 1
        SAME_HEID = 2
        VALUE_MAP = {0 => "NEW_HEID", 1 => "UPDATE_HEID", 2 => "SAME_HEID"}
        VALID_VALUES = Set.new([NEW_HEID, UPDATE_HEID, SAME_HEID]).freeze
      end

      module IdentifierChangeState
        NEW = 0
        UPDATE = 1
        SAME = 2
        VALUE_MAP = {0 => "NEW", 1 => "UPDATE", 2 => "SAME"}
        VALID_VALUES = Set.new([NEW, UPDATE, SAME]).freeze
      end

      module CookieMonsterResult
        DATA = 1
        NO_DATA = 2
        VALUE_MAP = {1 => "DATA", 2 => "NO_DATA"}
        VALID_VALUES = Set.new([DATA, NO_DATA]).freeze
      end

      module IngestionAction
        ADD = 0
        UPDATE = 1
        REMOVE = 2
        VALUE_MAP = {0 => "ADD", 1 => "UPDATE", 2 => "REMOVE"}
        VALID_VALUES = Set.new([ADD, UPDATE, REMOVE]).freeze
      end

      module IngestionResponseStatus
        SUCCESS = 0
        MALFORMED_PDATA = 1
        REQUIRED_DEVICE_ID = 2
        REQUIRED_DEVICE_POOL_ID = 3
        VALUE_MAP = {0 => "SUCCESS", 1 => "MALFORMED_PDATA", 2 => "REQUIRED_DEVICE_ID", 3 => "REQUIRED_DEVICE_POOL_ID"}
        VALID_VALUES = Set.new([SUCCESS, MALFORMED_PDATA, REQUIRED_DEVICE_ID, REQUIRED_DEVICE_POOL_ID]).freeze
      end

      module QuickOnboardingIdentifierType
        EMAIL = 0
        EMAIL_MD5 = 1
        EMAIL_SHA1 = 2
        EMAIL_SHA256 = 3
        POSTAL = 4
        PHONE = 5
        VALUE_MAP = {0 => "EMAIL", 1 => "EMAIL_MD5", 2 => "EMAIL_SHA1", 3 => "EMAIL_SHA256", 4 => "POSTAL", 5 => "PHONE"}
        VALID_VALUES = Set.new([EMAIL, EMAIL_MD5, EMAIL_SHA1, EMAIL_SHA256, POSTAL, PHONE]).freeze
      end

      module LogApp
        ELMO = 0
        COUNT_VON_COUNT = 1
        COOKIE_MONSTER = 2
        COOKIE_MONSTER_LITE = 3
        S2S_DATA_SYNCER = 4
        ELMO_DISCARDED = 5
        COUNT_VON_COUNT_DISCARDED = 6
        ATTRIBUTION = 7
        ATTRIBUTION_BAD_REQUEST = 8
        BERT = 9
        INGESTION = 10
        EUROPE_ELMO = 11
        QUICK_ONBOARDING_API = 12
        COOKIE_SYNC = 13
        COOKIE_IDL = 14
        VALUE_MAP = {0 => "ELMO", 1 => "COUNT_VON_COUNT", 2 => "COOKIE_MONSTER", 3 => "COOKIE_MONSTER_LITE", 4 => "S2S_DATA_SYNCER", 5 => "ELMO_DISCARDED", 6 => "COUNT_VON_COUNT_DISCARDED", 7 => "ATTRIBUTION", 8 => "ATTRIBUTION_BAD_REQUEST", 9 => "BERT", 10 => "INGESTION", 11 => "EUROPE_ELMO", 12 => "QUICK_ONBOARDING_API", 13 => "COOKIE_SYNC", 14 => "COOKIE_IDL"}
        VALID_VALUES = Set.new([ELMO, COUNT_VON_COUNT, COOKIE_MONSTER, COOKIE_MONSTER_LITE, S2S_DATA_SYNCER, ELMO_DISCARDED, COUNT_VON_COUNT_DISCARDED, ATTRIBUTION, ATTRIBUTION_BAD_REQUEST, BERT, INGESTION, EUROPE_ELMO, QUICK_ONBOARDING_API, COOKIE_SYNC, COOKIE_IDL]).freeze
      end

      module CookieMonsterResponse
        # didn't try to place cookie
        NOT_ATTEMPTED = 0
        # tried to place cookie but there was no entity segment pack
        NO_ESP = 1
        # tried to place cookie but no buckets found
        NO_BUCKETS = 2
        # dropped new rapleaf cookie (AdSummV2/EntitySegmentPack)
# 
        NEW_COOKIE = 3
        # tried to place cookie the string was too large (>4,000 bytes)
        COOKIE_TOO_LARGE = 4
        VALUE_MAP = {0 => "NOT_ATTEMPTED", 1 => "NO_ESP", 2 => "NO_BUCKETS", 3 => "NEW_COOKIE", 4 => "COOKIE_TOO_LARGE"}
        VALID_VALUES = Set.new([NOT_ATTEMPTED, NO_ESP, NO_BUCKETS, NEW_COOKIE, COOKIE_TOO_LARGE]).freeze
      end

      module LiveRampRequestSource
        ELMO = 1
        COOKIE_MONSTER = 2
        S2S_DATA_SYNCER = 3
        VALUE_MAP = {1 => "ELMO", 2 => "COOKIE_MONSTER", 3 => "S2S_DATA_SYNCER"}
        VALID_VALUES = Set.new([ELMO, COOKIE_MONSTER, S2S_DATA_SYNCER]).freeze
      end

      module IPAddrInfoSource
        MAXMIND = 0
        VALUE_MAP = {0 => "MAXMIND"}
        VALID_VALUES = Set.new([MAXMIND]).freeze
      end

      module OptOutCookieSource
        JSPRUCE = 1
        MATCHED_PII_IDENTIFIER = 2
        VALUE_MAP = {1 => "JSPRUCE", 2 => "MATCHED_PII_IDENTIFIER"}
        VALID_VALUES = Set.new([JSPRUCE, MATCHED_PII_IDENTIFIER]).freeze
      end

      module ManagedDevicesDeviceType
        OVERALL = 1
        WEB = 2
        MOBILE = 3
        ANDROID = 4
        IOS = 5
        WEB_DESKTOP = 6
        WEB_MOBILE_IOS = 7
        WEB_MOBILE_ANDROID = 8
        WEB_MOBILE_OTHER = 9
        WEB_TABLET_IOS = 10
        WEB_TABLET_ANDROID = 11
        WEB_TABLET_OTHER = 12
        CUSTOM_ID = 13
        VALUE_MAP = {1 => "OVERALL", 2 => "WEB", 3 => "MOBILE", 4 => "ANDROID", 5 => "IOS", 6 => "WEB_DESKTOP", 7 => "WEB_MOBILE_IOS", 8 => "WEB_MOBILE_ANDROID", 9 => "WEB_MOBILE_OTHER", 10 => "WEB_TABLET_IOS", 11 => "WEB_TABLET_ANDROID", 12 => "WEB_TABLET_OTHER", 13 => "CUSTOM_ID"}
        VALID_VALUES = Set.new([OVERALL, WEB, MOBILE, ANDROID, IOS, WEB_DESKTOP, WEB_MOBILE_IOS, WEB_MOBILE_ANDROID, WEB_MOBILE_OTHER, WEB_TABLET_IOS, WEB_TABLET_ANDROID, WEB_TABLET_OTHER, CUSTOM_ID]).freeze
      end

      class PiiId; end

      class LRCFieldsPrecision; end

      class NullCookieId; end

      class DeviceId < ::Thrift::Union; end

      class EntitySegmentPack; end

      class ExternalDeviceId < ::Thrift::Union; end

      class IdSync; end

      class IdSyncCookie; end

      class DetargetCookie; end

      class MatchedHeid; end

      class MatchedAshId; end

      class LastPublisherMatch; end

      class HashedUserId; end

      class HashedPIN < ::Thrift::Union; end

      class FieldValue; end

      class AudienceFields; end

      class AnaPlacedFields; end

      class PlacedFields; end

      class GeoIPLocation; end

      class InternetServiceProvider; end

      class ElmoLogEntry; end

      class CookieMonsterLogEntry; end

      class IngestionLogEntry; end

      class S2SDataSyncerLogEntry; end

      class AttributionLogEntryMetadata; end

      class AttributionLogEntry; end

      class QuickOnboardingApiLogEntry; end

      class LogEntryUnion < ::Thrift::Union; end

      class LogEntry; end

      class LogEntrySampleWrapper; end

      class IPAddrInfo; end

      class OptOutCookie; end

      class AudienceFieldsByAudienceId; end

      class AnaResponsePackage; end

      class RecookierEvalLogData; end

      class PmeCountLogData; end

      class DatedHeid; end

      class PiiId
        include ::Thrift::Struct, ::Thrift::Struct_Union
        EMAIL = 1
        NAP = 2

        FIELDS = {
          EMAIL => {:type => ::Thrift::Types::STRING, :name => 'email', :optional => true},
          NAP => {:type => ::Thrift::Types::STRUCT, :name => 'nap', :class => ::Liveramp::Types::PiiIntegration::EncSHA256Nap, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Indicates the precision level of a given set of LRC fields.
      class LRCFieldsPrecision
        include ::Thrift::Struct, ::Thrift::Struct_Union
        IMPORT_PRECISION = 1
        WATERFALL_PRECISION = 2

        FIELDS = {
          # The precision level at which the LRFields were imported
          IMPORT_PRECISION => {:type => ::Thrift::Types::BYTE, :name => 'import_precision'},
          # The precision level through which the LRFields were waterfalled in order to reach the corresponding entity
          WATERFALL_PRECISION => {:type => ::Thrift::Types::BYTE, :name => 'waterfall_precision'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field import_precision is unset!') unless @import_precision
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field waterfall_precision is unset!') unless @waterfall_precision
        end

        ::Thrift::Struct.generate_accessors self
      end

      class NullCookieId
        include ::Thrift::Struct, ::Thrift::Struct_Union
        RANDOM_BYTES = 1

        FIELDS = {
          RANDOM_BYTES => {:type => ::Thrift::Types::STRING, :name => 'random_bytes', :binary => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class DeviceId < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def cookie_id(val)
            DeviceId.new(:cookie_id, val)
          end

          def null_cookie_id(val)
            DeviceId.new(:null_cookie_id, val)
          end

          def lrmid(val)
            DeviceId.new(:lrmid, val)
          end

          def lrcid(val)
            DeviceId.new(:lrcid, val)
          end

          def piiid(val)
            DeviceId.new(:piiid, val)
          end
        end

        COOKIE_ID = 1
        NULL_COOKIE_ID = 2
        LRMID = 4
        LRCID = 5
        PIIID = 6

        FIELDS = {
          COOKIE_ID => {:type => ::Thrift::Types::STRING, :name => 'cookie_id', :binary => true, :optional => true},
          NULL_COOKIE_ID => {:type => ::Thrift::Types::STRUCT, :name => 'null_cookie_id', :class => ::Rapleaf::Types::Spruce::NullCookieId, :optional => true},
          # Liveramp mobile user id
          LRMID => {:type => ::Thrift::Types::STRING, :name => 'lrmid', :binary => true, :optional => true},
          # LiveRamp internal id for partners that provide their own external custom id
          LRCID => {:type => ::Thrift::Types::STRING, :name => 'lrcid', :binary => true, :optional => true},
          PIIID => {:type => ::Thrift::Types::STRUCT, :name => 'piiid', :class => ::Rapleaf::Types::Spruce::PiiId, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      # An EntitySegmentPack contains a list of InternalSegmentInstances
# This is used to serve Spruce/API requests and for some other stuff.
# 
# internal_segment_instances = [
#   InternalSegmentInstance.new(:internal_segment_id => 10025, :owner => DataPartner::EQUIFAX),
#   InternalSegmentInstance.new(:internal_segment_id => 11852, :owner => DataPartner::INFOUSA),
#   InternalSegmentInstance.new(:internal_segment_id => 11852, :owner => DataPartner::EQUIFAX),
#   InternalSegmentInstance.new(:internal_segment_id => 54321, :owner => nil, :raw_data => "Software Engineer")
# ]
      class EntitySegmentPack
        include ::Thrift::Struct, ::Thrift::Struct_Union
        RESTRICTED = 8
        HEID = 9
        AUDIENCE_FIELD_VALUES = 13
        DEVICE_ID = 14
        FILTERED_AUDIENCES_WATERFALL_LEVEL = 15

        FIELDS = {
          # If this user is opted out, this will be set.
          RESTRICTED => {:type => ::Thrift::Types::BOOL, :name => 'restricted', :optional => true},
          # The md5 hash of the eid. The eid is taken as
# the byte array and directly hashed.
          HEID => {:type => ::Thrift::Types::STRING, :name => 'heid', :binary => true, :optional => true},
          # A Mapping from Audience ID to the Data (and metadata) for that audience
          AUDIENCE_FIELD_VALUES => {:type => ::Thrift::Types::MAP, :name => 'audience_field_values', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Audience::AnonymousMemberFields}, :optional => true},
          # The DeviceId that the data is associated with.
          DEVICE_ID => {:type => ::Thrift::Types::STRUCT, :name => 'device_id', :class => ::Rapleaf::Types::Spruce::DeviceId, :optional => true},
          # Map of audiences whose data has been filtered out of the ESP to max waterfall level
          FILTERED_AUDIENCES_WATERFALL_LEVEL => {:type => ::Thrift::Types::MAP, :name => 'filtered_audiences_waterfall_level', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::I32, :enum_class => ::Liveramp::Audience::PrecisionLevel}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ExternalDeviceId < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def external_cookie_id(val)
            ExternalDeviceId.new(:external_cookie_id, val)
          end

          def muid(val)
            ExternalDeviceId.new(:muid, val)
          end

          def pp_external_id(val)
            ExternalDeviceId.new(:pp_external_id, val)
          end
        end

        EXTERNAL_COOKIE_ID = 1
        MUID = 2
        PP_EXTERNAL_ID = 3

        FIELDS = {
          EXTERNAL_COOKIE_ID => {:type => ::Thrift::Types::STRING, :name => 'external_cookie_id', :optional => true},
          MUID => {:type => ::Thrift::Types::STRUCT, :name => 'muid', :class => ::Liveramp::Types::Mobile::MUID, :optional => true},
          PP_EXTERNAL_ID => {:type => ::Thrift::Types::STRING, :name => 'pp_external_id', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class IdSync
        include ::Thrift::Struct, ::Thrift::Struct_Union
        TIMESTAMP = 1
        PARTNER_UID = 2

        FIELDS = {
          TIMESTAMP => {:type => ::Thrift::Types::I32, :name => 'timestamp'},
          PARTNER_UID => {:type => ::Thrift::Types::STRING, :name => 'partner_uid', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field timestamp is unset!') unless @timestamp
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Id sync cookie is used to store all the adnetwork accounts with which
# a cookie id has been synced client (browser) side.
      class IdSyncCookie
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SYNCED_ANAS = 1

        FIELDS = {
          SYNCED_ANAS => {:type => ::Thrift::Types::MAP, :name => 'synced_anas', :key => {:type => ::Thrift::Types::I32}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::Spruce::IdSync}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field synced_anas is unset!') unless @synced_anas
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Detarget cookie is so that an ad network can signal to stop receiving a user for a month.
      class DetargetCookie
        include ::Thrift::Struct, ::Thrift::Struct_Union
        AD_NETWORK_ACCOUNT_ID_TO_TIMESTAMP = 3

        FIELDS = {
          AD_NETWORK_ACCOUNT_ID_TO_TIMESTAMP => {:type => ::Thrift::Types::MAP, :name => 'ad_network_account_id_to_timestamp', :key => {:type => ::Thrift::Types::I32}, :value => {:type => ::Thrift::Types::I64}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field ad_network_account_id_to_timestamp is unset!') unless @ad_network_account_id_to_timestamp
        end

        ::Thrift::Struct.generate_accessors self
      end

      class MatchedHeid
        include ::Thrift::Struct, ::Thrift::Struct_Union
        HEID = 1
        LIVERAMP_SOURCE = 2

        FIELDS = {
          HEID => {:type => ::Thrift::Types::STRING, :name => 'heid', :binary => true},
          LIVERAMP_SOURCE => {:type => ::Thrift::Types::I32, :name => 'liveramp_source', :optional => true, :enum_class => ::Rapleaf::Types::Spruce::LiveRampDeviceIdSource}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field heid is unset!') unless @heid
          unless @liveramp_source.nil? || ::Rapleaf::Types::Spruce::LiveRampDeviceIdSource::VALID_VALUES.include?(@liveramp_source)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field liveramp_source!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class MatchedAshId
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ASH_ID = 1
        LIVERAMP_SOURCE = 2

        FIELDS = {
          ASH_ID => {:type => ::Thrift::Types::STRING, :name => 'ash_id', :binary => true},
          LIVERAMP_SOURCE => {:type => ::Thrift::Types::I32, :name => 'liveramp_source', :optional => true, :enum_class => ::Rapleaf::Types::Spruce::LiveRampDeviceIdSource}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field ash_id is unset!') unless @ash_id
          unless @liveramp_source.nil? || ::Rapleaf::Types::Spruce::LiveRampDeviceIdSource::VALID_VALUES.include?(@liveramp_source)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field liveramp_source!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class LastPublisherMatch
        include ::Thrift::Struct, ::Thrift::Struct_Union
        TIMESTAMP = 1
        PUBLISHER_ID = 2

        FIELDS = {
          TIMESTAMP => {:type => ::Thrift::Types::I32, :name => 'timestamp'},
          PUBLISHER_ID => {:type => ::Thrift::Types::I64, :name => 'publisher_id'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field timestamp is unset!') unless @timestamp
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field publisher_id is unset!') unless @publisher_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      class HashedUserId
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SITE = 1
        HUSERID = 2

        FIELDS = {
          SITE => {:type => ::Thrift::Types::I32, :name => 'site', :enum_class => ::Rapleaf::Types::PersonData::EsSite},
          HUSERID => {:type => ::Thrift::Types::STRING, :name => 'huserid', :binary => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field site is unset!') unless @site
          unless @site.nil? || ::Rapleaf::Types::PersonData::EsSite::VALID_VALUES.include?(@site)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field site!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A union for hashed pin types.
      class HashedPIN < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def hhemail(val)
            HashedPIN.new(:hhemail, val)
          end

          def hmd5(val)
            HashedPIN.new(:hmd5, val)
          end

          def hsha1(val)
            HashedPIN.new(:hsha1, val)
          end

          def huserid(val)
            HashedPIN.new(:huserid, val)
          end

          def hxnap(val)
            HashedPIN.new(:hxnap, val)
          end

          def hx(val)
            HashedPIN.new(:hx, val)
          end

          def hsha256(val)
            HashedPIN.new(:hsha256, val)
          end

          def hspn(val)
            HashedPIN.new(:hspn, val)
          end
        end

        HHEMAIL = 1
        HMD5 = 2
        HSHA1 = 3
        HUSERID = 4
        HXNAP = 5
        HX = 6
        HSHA256 = 7
        HSPN = 8

        FIELDS = {
          HHEMAIL => {:type => ::Thrift::Types::STRING, :name => 'hhemail', :binary => true, :optional => true},
          HMD5 => {:type => ::Thrift::Types::STRING, :name => 'hmd5', :binary => true, :optional => true},
          HSHA1 => {:type => ::Thrift::Types::STRING, :name => 'hsha1', :binary => true, :optional => true},
          HUSERID => {:type => ::Thrift::Types::STRUCT, :name => 'huserid', :class => ::Rapleaf::Types::Spruce::HashedUserId, :optional => true},
          HXNAP => {:type => ::Thrift::Types::STRING, :name => 'hxnap', :binary => true, :optional => true},
          HX => {:type => ::Thrift::Types::STRING, :name => 'hx', :binary => true, :optional => true},
          HSHA256 => {:type => ::Thrift::Types::STRING, :name => 'hsha256', :binary => true, :optional => true},
          HSPN => {:type => ::Thrift::Types::STRING, :name => 'hspn', :binary => true, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class FieldValue
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ID = 1
        VALUE = 2
        ONLINE_MATCH_PARTNER = 4

        FIELDS = {
          ID => {:type => ::Thrift::Types::I32, :name => 'id'},
          VALUE => {:type => ::Thrift::Types::I32, :name => 'value', :optional => true},
          ONLINE_MATCH_PARTNER => {:type => ::Thrift::Types::I32, :name => 'online_match_partner', :optional => true, :enum_class => ::Rapleaf::Types::PersonData::OnlineMatchPartner}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field id is unset!') unless @id
          unless @online_match_partner.nil? || ::Rapleaf::Types::PersonData::OnlineMatchPartner::VALID_VALUES.include?(@online_match_partner)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field online_match_partner!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class AudienceFields
        include ::Thrift::Struct, ::Thrift::Struct_Union
        HASHED_AUDIENCE_KEY = 1
        VERSION_NUMBER = 2
        PLACED_FIELDS = 3

        FIELDS = {
          HASHED_AUDIENCE_KEY => {:type => ::Thrift::Types::STRING, :name => 'hashed_audience_key', :binary => true},
          VERSION_NUMBER => {:type => ::Thrift::Types::I32, :name => 'version_number'},
          PLACED_FIELDS => {:type => ::Thrift::Types::SET, :name => 'placed_fields', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::Spruce::FieldValue}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field hashed_audience_key is unset!') unless @hashed_audience_key
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field version_number is unset!') unless @version_number
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field placed_fields is unset!') unless @placed_fields
        end

        ::Thrift::Struct.generate_accessors self
      end

      class AnaPlacedFields
        include ::Thrift::Struct, ::Thrift::Struct_Union
        AUDIENCE_FIELDS_BY_AUDIENCE_ID = 2

        FIELDS = {
          AUDIENCE_FIELDS_BY_AUDIENCE_ID => {:type => ::Thrift::Types::MAP, :name => 'audience_fields_by_audience_id', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::Spruce::AudienceFields}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class PlacedFields
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PLACED_FIELDS_BY_ANA = 1

        FIELDS = {
          PLACED_FIELDS_BY_ANA => {:type => ::Thrift::Types::MAP, :name => 'placed_fields_by_ana', :key => {:type => ::Thrift::Types::I32}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::Spruce::AnaPlacedFields}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field placed_fields_by_ana is unset!') unless @placed_fields_by_ana
        end

        ::Thrift::Struct.generate_accessors self
      end

      class GeoIPLocation
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CITY = 1
        REGION = 2
        COUNTRY_CODE = 3
        POSTAL_CODE = 4
        DMA_CODE = 5

        FIELDS = {
          CITY => {:type => ::Thrift::Types::STRING, :name => 'city', :optional => true},
          REGION => {:type => ::Thrift::Types::STRING, :name => 'region', :optional => true},
          COUNTRY_CODE => {:type => ::Thrift::Types::STRING, :name => 'country_code', :optional => true},
          POSTAL_CODE => {:type => ::Thrift::Types::STRING, :name => 'postal_code', :optional => true},
          DMA_CODE => {:type => ::Thrift::Types::STRING, :name => 'dma_code', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class InternetServiceProvider
        include ::Thrift::Struct, ::Thrift::Struct_Union
        NAME = 1
        ORGANIZATION = 2

        FIELDS = {
          NAME => {:type => ::Thrift::Types::STRING, :name => 'name', :optional => true},
          ORGANIZATION => {:type => ::Thrift::Types::STRING, :name => 'organization', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Record logged for each Elmo request.
      class ElmoLogEntry
        include ::Thrift::Struct, ::Thrift::Struct_Union
        REQUEST_URI = 1
        USER_AGENT = 2
        REQUEST_TYPE = 3
        PUBLISHER = 4
        N = 5
        SUBDOMAIN = 6
        COOKIE_DOMAIN = 7
        CIPHER = 8
        IV = 9
        ENCRYPTED_EMAIL = 10
        ENCRYPTED_USERID = 11
        ENCRYPTED_NAP = 12
        DEPRECATED_EID = 13
        PINS = 14
        DEPRECATED_MD5_FROM_ADSUMM = 15
        DEPRECATED_EBUREAU_PIXEL = 17
        EMAIL_PRESENT = 18
        ADSUMM_PRESENT = 19
        COOKIE_ADSUMM = 20
        RESTRICTED = 21
        OPTOUT = 22
        BAD_REQUEST = 23
        RATE_LIMITED = 24
        QA = 25
        DEPRECATED_RAPLEAF_COOKIE_STATUS = 26
        ROTATION_COOKIE = 27
        RTN_COOKIE_SIZE = 28
        RAPLEAF_COOKIE_SIZE = 29
        TIMESTAMP = 30
        ELAPSED = 31
        DEBUG_ADN = 32
        DEBUG_ANA = 33
        DEPRECATED_HEID = 34
        HASHED_PINS = 35
        ACCEPTS_COOKIE = 37
        DEPRECATED_COOKIE_MONSTER_RESULT = 38
        DEPRECATED_COUNTRY_CODE = 39
        NEW_ANAS_THIS_MONTH = 40
        NEW_COOKIE = 41
        NEW_COOKIE_THIS_MONTH = 42
        PARTNER_DATA_PRESENT = 43
        POSTAL_PRESENT = 44
        REDIRECT = 45
        REMOTE_ADDR = 46
        DEPRECATED_LIVERAMP_SOURCE = 47
        PARTNER_UID = 48
        DEPRECATED_PARTNER_DATA_AVAILABLE = 49
        DEPRECATED_PLACED_FIELDS = 50
        DEPRECATED_RAMP_RATE = 51
        SYNCED_ANAS = 56
        SECURE = 57
        ROTATION_STATUSES = 58
        DETARGETED_ANA_IDS = 59
        LOCATION = 60
        COOKIE_ID = 61
        SKIPPED_ENCRYPTED_REDIRECT = 62
        HEID_BY_SUBNETWORKS = 63
        PLACED_FIELDS_BY_SUBNETWORKS = 64
        AUDIENCES_AVAILABLE = 65
        PDATA = 66
        SUPER_COOKIE_CLEANED = 67
        SUPER_COOKIE_HEID_BY_SUBNETWORKS = 68
        SUPER_COOKIE_SYNCED_ANAS = 69
        SUPER_COOKIE_NEW_COOKIE_ID = 70
        HEID_CHANGE_BY_SUBNETWORKS = 71
        TRACKING_NUMBER = 72
        BAD_REQUEST_REASON = 73
        REQUEST_ID = 74
        ASH_ID_BY_SUBNETWORKS = 75
        ASH_ID_CHANGE_BY_SUBNETWORKS = 76
        ARL_BY_SUBNETWORKS = 77
        ARL_CHANGE_BY_SUBNETWORKS = 78
        PEL_BY_SUBNETWORK = 79
        ARL_BY_SUBNETWORK = 80
        IDENTIFIER_ARL = 81
        IDENTIFIER_PEL = 82
        PARTNER_SITE_ID = 83
        REAL_TIME_IDENTITY_PEL = 84
        CUSTOM_PARAMETERS = 85
        ISP = 86

        FIELDS = {
          REQUEST_URI => {:type => ::Thrift::Types::STRING, :name => 'request_uri', :optional => true},
          USER_AGENT => {:type => ::Thrift::Types::STRING, :name => 'user_agent', :optional => true},
          REQUEST_TYPE => {:type => ::Thrift::Types::I32, :name => 'request_type', :optional => true, :enum_class => ::Rapleaf::Types::Spruce::ElmoRequestType},
          PUBLISHER => {:type => ::Thrift::Types::I32, :name => 'publisher', :optional => true},
          # Count of requests made by a publisher from the same page.
          N => {:type => ::Thrift::Types::STRING, :name => 'n', :optional => true},
          SUBDOMAIN => {:type => ::Thrift::Types::STRING, :name => 'subdomain', :optional => true},
          COOKIE_DOMAIN => {:type => ::Thrift::Types::STRING, :name => 'cookie_domain', :optional => true},
          # Encryption params.
# 
          CIPHER => {:type => ::Thrift::Types::STRING, :name => 'cipher', :optional => true},
          IV => {:type => ::Thrift::Types::STRING, :name => 'iv', :optional => true},
          ENCRYPTED_EMAIL => {:type => ::Thrift::Types::STRING, :name => 'encrypted_email', :optional => true},
          ENCRYPTED_USERID => {:type => ::Thrift::Types::STRING, :name => 'encrypted_userid', :optional => true},
          ENCRYPTED_NAP => {:type => ::Thrift::Types::STRING, :name => 'encrypted_nap', :optional => true},
          DEPRECATED_EID => {:type => ::Thrift::Types::STRING, :name => 'deprecated_eid', :binary => true, :optional => true},
          PINS => {:type => ::Thrift::Types::STRUCT, :name => 'pins', :class => ::Rapleaf::Types::NewPersonData::PINSet, :optional => true},
          # Used for enqueuing to ebureau.
          DEPRECATED_MD5_FROM_ADSUMM => {:type => ::Thrift::Types::STRING, :name => 'deprecated_md5_from_adsumm', :optional => true},
          DEPRECATED_EBUREAU_PIXEL => {:type => ::Thrift::Types::STRING, :name => 'deprecated_ebureau_pixel', :optional => true},
          # Set to true if email was passed in request or email related segments
# were set in adsumm.
          EMAIL_PRESENT => {:type => ::Thrift::Types::BOOL, :name => 'email_present', :optional => true},
          # Set to true if adsumm was found for the request.
          ADSUMM_PRESENT => {:type => ::Thrift::Types::BOOL, :name => 'adsumm_present', :optional => true},
          # Set to true if adsumm was found from rapleaf cookie.
          COOKIE_ADSUMM => {:type => ::Thrift::Types::BOOL, :name => 'cookie_adsumm', :optional => true},
          # Set to true if entity opted out on rapleaf.com.
          RESTRICTED => {:type => ::Thrift::Types::BOOL, :name => 'restricted', :optional => true},
          # Set to true if entity opted out on rlcdn.com.
          OPTOUT => {:type => ::Thrift::Types::BOOL, :name => 'optout', :optional => true},
          BAD_REQUEST => {:type => ::Thrift::Types::BOOL, :name => 'bad_request', :optional => true},
          # Set to true if publisher is rate limited or n limited.
          RATE_LIMITED => {:type => ::Thrift::Types::BOOL, :name => 'rate_limited', :optional => true},
          # Set to true if request was made by us for qa purposes.
          QA => {:type => ::Thrift::Types::BOOL, :name => 'qa', :optional => true},
          DEPRECATED_RAPLEAF_COOKIE_STATUS => {:type => ::Thrift::Types::I16, :name => 'deprecated_rapleaf_cookie_status', :optional => true},
          # Set of Anas for which segments have been placed so far on the browser.
          ROTATION_COOKIE => {:type => ::Thrift::Types::SET, :name => 'rotation_cookie', :element => {:type => ::Thrift::Types::I32}, :optional => true},
          RTN_COOKIE_SIZE => {:type => ::Thrift::Types::I32, :name => 'rtn_cookie_size', :optional => true},
          RAPLEAF_COOKIE_SIZE => {:type => ::Thrift::Types::I32, :name => 'rapleaf_cookie_size', :optional => true},
          TIMESTAMP => {:type => ::Thrift::Types::I32, :name => 'timestamp', :optional => true},
          # Duration of the request.
          ELAPSED => {:type => ::Thrift::Types::DOUBLE, :name => 'elapsed', :optional => true},
          # Params used for debugging / testing purposes.
          DEBUG_ADN => {:type => ::Thrift::Types::I32, :name => 'debug_adn', :optional => true},
          DEBUG_ANA => {:type => ::Thrift::Types::I32, :name => 'debug_ana', :optional => true},
          DEPRECATED_HEID => {:type => ::Thrift::Types::STRING, :name => 'deprecated_heid', :binary => true, :optional => true},
          HASHED_PINS => {:type => ::Thrift::Types::LIST, :name => 'hashed_pins', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::Spruce::HashedPIN}, :optional => true},
          ACCEPTS_COOKIE => {:type => ::Thrift::Types::BOOL, :name => 'accepts_cookie', :optional => true},
          DEPRECATED_COOKIE_MONSTER_RESULT => {:type => ::Thrift::Types::I16, :name => 'deprecated_cookie_monster_result', :optional => true},
          DEPRECATED_COUNTRY_CODE => {:type => ::Thrift::Types::STRING, :name => 'deprecated_country_code', :optional => true},
          NEW_ANAS_THIS_MONTH => {:type => ::Thrift::Types::SET, :name => 'new_anas_this_month', :element => {:type => ::Thrift::Types::I32}, :optional => true},
          NEW_COOKIE => {:type => ::Thrift::Types::BOOL, :name => 'new_cookie', :optional => true},
          NEW_COOKIE_THIS_MONTH => {:type => ::Thrift::Types::BOOL, :name => 'new_cookie_this_month', :optional => true},
          PARTNER_DATA_PRESENT => {:type => ::Thrift::Types::BOOL, :name => 'partner_data_present', :optional => true},
          POSTAL_PRESENT => {:type => ::Thrift::Types::BOOL, :name => 'postal_present', :optional => true},
          REDIRECT => {:type => ::Thrift::Types::STRING, :name => 'redirect', :optional => true},
          REMOTE_ADDR => {:type => ::Thrift::Types::STRING, :name => 'remote_addr', :optional => true},
          DEPRECATED_LIVERAMP_SOURCE => {:type => ::Thrift::Types::I16, :name => 'deprecated_liveramp_source', :optional => true},
          PARTNER_UID => {:type => ::Thrift::Types::STRING, :name => 'partner_uid', :optional => true},
          DEPRECATED_PARTNER_DATA_AVAILABLE => {:type => ::Thrift::Types::SET, :name => 'deprecated_partner_data_available', :element => {:type => ::Thrift::Types::I32}, :optional => true},
          DEPRECATED_PLACED_FIELDS => {:type => ::Thrift::Types::STRUCT, :name => 'deprecated_placed_fields', :class => ::Rapleaf::Types::Spruce::PlacedFields, :optional => true},
          DEPRECATED_RAMP_RATE => {:type => ::Thrift::Types::BOOL, :name => 'deprecated_ramp_rate', :optional => true},
          SYNCED_ANAS => {:type => ::Thrift::Types::MAP, :name => 'synced_anas', :key => {:type => ::Thrift::Types::I32}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::Spruce::IdSync}, :optional => true},
          SECURE => {:type => ::Thrift::Types::BOOL, :name => 'secure', :optional => true},
          ROTATION_STATUSES => {:type => ::Thrift::Types::MAP, :name => 'rotation_statuses', :key => {:type => ::Thrift::Types::I32}, :value => {:type => ::Thrift::Types::I32}, :optional => true},
          DETARGETED_ANA_IDS => {:type => ::Thrift::Types::SET, :name => 'detargeted_ana_ids', :element => {:type => ::Thrift::Types::I32}, :optional => true},
          LOCATION => {:type => ::Thrift::Types::STRUCT, :name => 'location', :class => ::Rapleaf::Types::Spruce::GeoIPLocation, :optional => true},
          COOKIE_ID => {:type => ::Thrift::Types::STRUCT, :name => 'cookie_id', :class => ::Rapleaf::Types::Spruce::DeviceId, :optional => true},
          SKIPPED_ENCRYPTED_REDIRECT => {:type => ::Thrift::Types::BOOL, :name => 'skipped_encrypted_redirect', :optional => true},
          HEID_BY_SUBNETWORKS => {:type => ::Thrift::Types::MAP, :name => 'heid_by_subnetworks', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::Spruce::MatchedHeid}, :optional => true},
          PLACED_FIELDS_BY_SUBNETWORKS => {:type => ::Thrift::Types::MAP, :name => 'placed_fields_by_subnetworks', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::Spruce::PlacedFields}, :optional => true},
          AUDIENCES_AVAILABLE => {:type => ::Thrift::Types::SET, :name => 'audiences_available', :element => {:type => ::Thrift::Types::I32}, :optional => true},
          PDATA => {:type => ::Thrift::Types::STRING, :name => 'pdata', :optional => true},
          SUPER_COOKIE_CLEANED => {:type => ::Thrift::Types::BOOL, :name => 'super_cookie_cleaned', :optional => true},
          SUPER_COOKIE_HEID_BY_SUBNETWORKS => {:type => ::Thrift::Types::MAP, :name => 'super_cookie_heid_by_subnetworks', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::Spruce::MatchedHeid}, :optional => true},
          SUPER_COOKIE_SYNCED_ANAS => {:type => ::Thrift::Types::MAP, :name => 'super_cookie_synced_anas', :key => {:type => ::Thrift::Types::I32}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::Spruce::IdSync}, :optional => true},
          SUPER_COOKIE_NEW_COOKIE_ID => {:type => ::Thrift::Types::STRUCT, :name => 'super_cookie_new_cookie_id', :class => ::Rapleaf::Types::Spruce::DeviceId, :optional => true},
          HEID_CHANGE_BY_SUBNETWORKS => {:type => ::Thrift::Types::MAP, :name => 'heid_change_by_subnetworks', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::I32, :enum_class => ::Rapleaf::Types::Spruce::HeidChangeState}, :optional => true},
          TRACKING_NUMBER => {:type => ::Thrift::Types::STRING, :name => 'tracking_number', :optional => true},
          BAD_REQUEST_REASON => {:type => ::Thrift::Types::STRING, :name => 'bad_request_reason', :optional => true},
          REQUEST_ID => {:type => ::Thrift::Types::STRING, :name => 'request_id', :optional => true},
          ASH_ID_BY_SUBNETWORKS => {:type => ::Thrift::Types::MAP, :name => 'ash_id_by_subnetworks', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::Spruce::MatchedAshId}, :optional => true},
          ASH_ID_CHANGE_BY_SUBNETWORKS => {:type => ::Thrift::Types::MAP, :name => 'ash_id_change_by_subnetworks', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::I32, :enum_class => ::Rapleaf::Types::Spruce::IdentifierChangeState}, :optional => true},
          # Deprecated! Use arl_by_subnetwork instead.
          ARL_BY_SUBNETWORKS => {:type => ::Thrift::Types::MAP, :name => 'arl_by_subnetworks', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRING, :binary => true}, :optional => true},
          ARL_CHANGE_BY_SUBNETWORKS => {:type => ::Thrift::Types::MAP, :name => 'arl_change_by_subnetworks', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::I32, :enum_class => ::Rapleaf::Types::Spruce::IdentifierChangeState}, :optional => true},
          PEL_BY_SUBNETWORK => {:type => ::Thrift::Types::MAP, :name => 'pel_by_subnetwork', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Types::CustomId::CustomId}, :optional => true},
          ARL_BY_SUBNETWORK => {:type => ::Thrift::Types::MAP, :name => 'arl_by_subnetwork', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Abilitec::Arl}, :optional => true},
          IDENTIFIER_ARL => {:type => ::Thrift::Types::STRUCT, :name => 'identifier_arl', :class => ::Liveramp::Abilitec::Arl, :optional => true},
          IDENTIFIER_PEL => {:type => ::Thrift::Types::STRUCT, :name => 'identifier_pel', :class => ::Liveramp::Types::CustomId::CustomId, :optional => true},
          PARTNER_SITE_ID => {:type => ::Thrift::Types::STRING, :name => 'partner_site_id', :optional => true},
          REAL_TIME_IDENTITY_PEL => {:type => ::Thrift::Types::STRING, :name => 'real_time_identity_pel', :optional => true},
          CUSTOM_PARAMETERS => {:type => ::Thrift::Types::STRING, :name => 'custom_parameters', :optional => true},
          ISP => {:type => ::Thrift::Types::STRUCT, :name => 'isp', :class => ::Rapleaf::Types::Spruce::InternetServiceProvider, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @request_type.nil? || ::Rapleaf::Types::Spruce::ElmoRequestType::VALID_VALUES.include?(@request_type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field request_type!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Struct logged for CookieMonster requests.
      class CookieMonsterLogEntry
        include ::Thrift::Struct, ::Thrift::Struct_Union
        READER = 2
        TIMESTAMP = 6
        NEW_COOKIE_ID = 18

        FIELDS = {
          READER => {:type => ::Thrift::Types::I32, :name => 'reader', :optional => true},
          TIMESTAMP => {:type => ::Thrift::Types::I32, :name => 'timestamp', :optional => true},
          NEW_COOKIE_ID => {:type => ::Thrift::Types::STRUCT, :name => 'new_cookie_id', :class => ::Rapleaf::Types::Spruce::DeviceId, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Struct logged for DDS Ingestion requests.
      class IngestionLogEntry
        include ::Thrift::Struct, ::Thrift::Struct_Union
        DEVICE_ID = 1
        DEVICE_POOL_ID = 2
        REFERRER_ID = 3
        PDATA = 4
        ACTION = 5
        STATUS = 6
        TIMESTAMP = 7
        QA = 8

        FIELDS = {
          DEVICE_ID => {:type => ::Thrift::Types::STRING, :name => 'device_id', :optional => true},
          DEVICE_POOL_ID => {:type => ::Thrift::Types::I64, :name => 'device_pool_id', :optional => true},
          REFERRER_ID => {:type => ::Thrift::Types::I64, :name => 'referrer_id', :optional => true},
          PDATA => {:type => ::Thrift::Types::STRING, :name => 'pdata', :optional => true},
          # What action we should take on the device_id.
          ACTION => {:type => ::Thrift::Types::I32, :name => 'action', :optional => true, :enum_class => ::Rapleaf::Types::Spruce::IngestionAction},
          STATUS => {:type => ::Thrift::Types::I32, :name => 'status', :optional => true, :enum_class => ::Rapleaf::Types::Spruce::IngestionResponseStatus},
          TIMESTAMP => {:type => ::Thrift::Types::I32, :name => 'timestamp', :optional => true},
          QA => {:type => ::Thrift::Types::BOOL, :name => 'qa', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @action.nil? || ::Rapleaf::Types::Spruce::IngestionAction::VALID_VALUES.include?(@action)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field action!')
          end
          unless @status.nil? || ::Rapleaf::Types::Spruce::IngestionResponseStatus::VALID_VALUES.include?(@status)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field status!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Struct logged for S2SDataSyncer requests.
      class S2SDataSyncerLogEntry
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SSA_ID = 1
        DEPRECATED_HEID = 2
        STATUS_CODE = 5
        DEPRECATED_LIVERAMP_SOURCE = 8
        PARTNER_UID = 9
        TIMESTAMP = 10
        PLACED_FIELDS = 11
        DEPRECATED_ZIP = 14
        DEVICE_ID = 15
        ACCEPTS_COOKIE = 16
        HEID_BY_SUBNETWORKS = 17
        PLACED_FIELDS_BY_SUBNETWORKS = 18
        MUID = 19
        JOB_ID = 20

        FIELDS = {
          SSA_ID => {:type => ::Thrift::Types::I32, :name => 'ssa_id', :optional => true},
          DEPRECATED_HEID => {:type => ::Thrift::Types::STRING, :name => 'deprecated_heid', :binary => true, :optional => true},
          STATUS_CODE => {:type => ::Thrift::Types::I32, :name => 'status_code', :optional => true},
          DEPRECATED_LIVERAMP_SOURCE => {:type => ::Thrift::Types::I16, :name => 'deprecated_liveramp_source', :optional => true},
          # Depreciated
          PARTNER_UID => {:type => ::Thrift::Types::STRING, :name => 'partner_uid', :optional => true},
          TIMESTAMP => {:type => ::Thrift::Types::I32, :name => 'timestamp', :optional => true},
          PLACED_FIELDS => {:type => ::Thrift::Types::STRUCT, :name => 'placed_fields', :class => ::Rapleaf::Types::Spruce::PlacedFields, :optional => true},
          DEPRECATED_ZIP => {:type => ::Thrift::Types::STRING, :name => 'deprecated_zip', :optional => true},
          DEVICE_ID => {:type => ::Thrift::Types::STRUCT, :name => 'device_id', :class => ::Rapleaf::Types::Spruce::DeviceId, :optional => true},
          ACCEPTS_COOKIE => {:type => ::Thrift::Types::BOOL, :name => 'accepts_cookie', :optional => true},
          HEID_BY_SUBNETWORKS => {:type => ::Thrift::Types::MAP, :name => 'heid_by_subnetworks', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::Spruce::MatchedHeid}, :optional => true},
          PLACED_FIELDS_BY_SUBNETWORKS => {:type => ::Thrift::Types::MAP, :name => 'placed_fields_by_subnetworks', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::Spruce::PlacedFields}, :optional => true},
          # Depreciated
          MUID => {:type => ::Thrift::Types::STRUCT, :name => 'muid', :class => ::Liveramp::Types::Mobile::MUID, :optional => true},
          JOB_ID => {:type => ::Thrift::Types::I64, :name => 'job_id', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Struct logged for attribution requests.
      class AttributionLogEntryMetadata
        include ::Thrift::Struct, ::Thrift::Struct_Union
        FIELD_ID = 1
        ENUM_ID = 2

        FIELDS = {
          FIELD_ID => {:type => ::Thrift::Types::I32, :name => 'field_id'},
          ENUM_ID => {:type => ::Thrift::Types::I32, :name => 'enum_id', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field field_id is unset!') unless @field_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      class AttributionLogEntry
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CLICK_UID = 1
        VALUE = 2
        TRANSACTION_TIMESTAMP = 3
        UPLOAD_TIMESTAMP = 4
        DEVICE_ID = 5
        HEID_BY_SUBNETWORKS = 6
        CATEGORY_FIELD_ID = 7
        SSA_ID = 8
        JOB_ID = 9
        STATUS = 10
        IRC_ID = 11
        CATEGORY_ENUM_ID = 12
        METADATA = 13

        FIELDS = {
          CLICK_UID => {:type => ::Thrift::Types::STRING, :name => 'click_uid'},
          VALUE => {:type => ::Thrift::Types::DOUBLE, :name => 'value'},
          TRANSACTION_TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'transaction_timestamp'},
          UPLOAD_TIMESTAMP => {:type => ::Thrift::Types::I32, :name => 'upload_timestamp'},
          DEVICE_ID => {:type => ::Thrift::Types::STRUCT, :name => 'device_id', :class => ::Rapleaf::Types::Spruce::DeviceId},
          HEID_BY_SUBNETWORKS => {:type => ::Thrift::Types::MAP, :name => 'heid_by_subnetworks', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::Spruce::MatchedHeid}, :optional => true},
          CATEGORY_FIELD_ID => {:type => ::Thrift::Types::I32, :name => 'category_field_id'},
          # Depreciated
          SSA_ID => {:type => ::Thrift::Types::I32, :name => 'ssa_id', :optional => true},
          JOB_ID => {:type => ::Thrift::Types::I32, :name => 'job_id'},
          STATUS => {:type => ::Thrift::Types::STRING, :name => 'status', :optional => true},
          IRC_ID => {:type => ::Thrift::Types::I64, :name => 'irc_id', :optional => true},
          CATEGORY_ENUM_ID => {:type => ::Thrift::Types::I32, :name => 'category_enum_id', :optional => true},
          METADATA => {:type => ::Thrift::Types::LIST, :name => 'metadata', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::Spruce::AttributionLogEntryMetadata}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field click_uid is unset!') unless @click_uid
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field value is unset!') unless @value
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field transaction_timestamp is unset!') unless @transaction_timestamp
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field upload_timestamp is unset!') unless @upload_timestamp
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field device_id is unset!') unless @device_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field category_field_id is unset!') unless @category_field_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field job_id is unset!') unless @job_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      class QuickOnboardingApiLogEntry
        include ::Thrift::Struct, ::Thrift::Struct_Union
        REMOTE_ADDR = 1
        REQUEST_TIMESTAMP = 2
        RESPONSE_TIMESTAMP = 3
        RESPONSE_CODE = 4
        ERROR_MESSAGE = 5
        ACCOUNT_ID = 6
        TRANSLATOR_EXCEPTION = 7
        TRANSLATOR_CALL_DURATION = 8
        NUM_TOTAL_RECORDS = 9
        NUM_PELS_RETURNED = 10
        NUM_RECORDS_WITH_IDENTIFIER_TYPE = 11
        NUM_INVALID_PINS_FOR_IDENTIFIER_TYPE = 12

        FIELDS = {
          REMOTE_ADDR => {:type => ::Thrift::Types::STRING, :name => 'remote_addr', :optional => true},
          REQUEST_TIMESTAMP => {:type => ::Thrift::Types::I32, :name => 'request_timestamp'},
          RESPONSE_TIMESTAMP => {:type => ::Thrift::Types::I32, :name => 'response_timestamp'},
          RESPONSE_CODE => {:type => ::Thrift::Types::I32, :name => 'response_code'},
          ERROR_MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'error_message', :optional => true},
          ACCOUNT_ID => {:type => ::Thrift::Types::I64, :name => 'account_id', :optional => true},
          TRANSLATOR_EXCEPTION => {:type => ::Thrift::Types::STRING, :name => 'translator_exception', :optional => true},
          TRANSLATOR_CALL_DURATION => {:type => ::Thrift::Types::I64, :name => 'translator_call_duration', :optional => true},
          NUM_TOTAL_RECORDS => {:type => ::Thrift::Types::I32, :name => 'num_total_records', :optional => true},
          NUM_PELS_RETURNED => {:type => ::Thrift::Types::I32, :name => 'num_pels_returned', :optional => true},
          NUM_RECORDS_WITH_IDENTIFIER_TYPE => {:type => ::Thrift::Types::MAP, :name => 'num_records_with_identifier_type', :key => {:type => ::Thrift::Types::I32, :enum_class => ::Rapleaf::Types::Spruce::QuickOnboardingIdentifierType}, :value => {:type => ::Thrift::Types::I32}, :optional => true},
          NUM_INVALID_PINS_FOR_IDENTIFIER_TYPE => {:type => ::Thrift::Types::MAP, :name => 'num_invalid_PINs_for_identifier_type', :key => {:type => ::Thrift::Types::I32, :enum_class => ::Rapleaf::Types::Spruce::QuickOnboardingIdentifierType}, :value => {:type => ::Thrift::Types::I32}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field request_timestamp is unset!') unless @request_timestamp
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field response_timestamp is unset!') unless @response_timestamp
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field response_code is unset!') unless @response_code
        end

        ::Thrift::Struct.generate_accessors self
      end

      class LogEntryUnion < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def elmo_log_entry(val)
            LogEntryUnion.new(:elmo_log_entry, val)
          end

          def cookie_monster_log_entry(val)
            LogEntryUnion.new(:cookie_monster_log_entry, val)
          end

          def s2s_data_syncer_log_entry(val)
            LogEntryUnion.new(:s2s_data_syncer_log_entry, val)
          end

          def attribution_log_entry(val)
            LogEntryUnion.new(:attribution_log_entry, val)
          end

          def ingestion_log_entry(val)
            LogEntryUnion.new(:ingestion_log_entry, val)
          end

          def quick_onboarding_api_log_entry(val)
            LogEntryUnion.new(:quick_onboarding_api_log_entry, val)
          end
        end

        ELMO_LOG_ENTRY = 1
        COOKIE_MONSTER_LOG_ENTRY = 2
        S2S_DATA_SYNCER_LOG_ENTRY = 3
        ATTRIBUTION_LOG_ENTRY = 4
        INGESTION_LOG_ENTRY = 5
        QUICK_ONBOARDING_API_LOG_ENTRY = 6

        FIELDS = {
          ELMO_LOG_ENTRY => {:type => ::Thrift::Types::STRUCT, :name => 'elmo_log_entry', :class => ::Rapleaf::Types::Spruce::ElmoLogEntry, :optional => true},
          COOKIE_MONSTER_LOG_ENTRY => {:type => ::Thrift::Types::STRUCT, :name => 'cookie_monster_log_entry', :class => ::Rapleaf::Types::Spruce::CookieMonsterLogEntry, :optional => true},
          S2S_DATA_SYNCER_LOG_ENTRY => {:type => ::Thrift::Types::STRUCT, :name => 's2s_data_syncer_log_entry', :class => ::Rapleaf::Types::Spruce::S2SDataSyncerLogEntry, :optional => true},
          ATTRIBUTION_LOG_ENTRY => {:type => ::Thrift::Types::STRUCT, :name => 'attribution_log_entry', :class => ::Rapleaf::Types::Spruce::AttributionLogEntry, :optional => true},
          INGESTION_LOG_ENTRY => {:type => ::Thrift::Types::STRUCT, :name => 'ingestion_log_entry', :class => ::Rapleaf::Types::Spruce::IngestionLogEntry, :optional => true},
          QUICK_ONBOARDING_API_LOG_ENTRY => {:type => ::Thrift::Types::STRUCT, :name => 'quick_onboarding_api_log_entry', :class => ::Rapleaf::Types::Spruce::QuickOnboardingApiLogEntry, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class LogEntry
        include ::Thrift::Struct, ::Thrift::Struct_Union
        APP = 1
        TIMESTAMP = 2
        SOURCE_HOST = 3
        APP_LOG_ENTRY = 4

        FIELDS = {
          APP => {:type => ::Thrift::Types::I32, :name => 'app', :enum_class => ::Rapleaf::Types::Spruce::LogApp},
          TIMESTAMP => {:type => ::Thrift::Types::I32, :name => 'timestamp'},
          SOURCE_HOST => {:type => ::Thrift::Types::STRING, :name => 'source_host'},
          APP_LOG_ENTRY => {:type => ::Thrift::Types::STRUCT, :name => 'app_log_entry', :class => ::Rapleaf::Types::Spruce::LogEntryUnion}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @app.nil? || ::Rapleaf::Types::Spruce::LogApp::VALID_VALUES.include?(@app)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field app!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class LogEntrySampleWrapper
        include ::Thrift::Struct, ::Thrift::Struct_Union
        LOG_ENTRY = 1
        SAMPLE_KEY = 2
        YEAR = 3
        MONTH = 4
        DAY = 5

        FIELDS = {
          LOG_ENTRY => {:type => ::Thrift::Types::STRUCT, :name => 'log_entry', :class => ::Rapleaf::Types::Spruce::LogEntry},
          SAMPLE_KEY => {:type => ::Thrift::Types::STRING, :name => 'sample_key'},
          YEAR => {:type => ::Thrift::Types::I16, :name => 'year'},
          MONTH => {:type => ::Thrift::Types::I16, :name => 'month'},
          DAY => {:type => ::Thrift::Types::I16, :name => 'day'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class IPAddrInfo
        include ::Thrift::Struct, ::Thrift::Struct_Union
        IP_ADDR = 1
        SOURCE = 2
        ORG_NAME = 3
        ISP_NAME = 4
        COUNTRY_CODE = 5

        FIELDS = {
          IP_ADDR => {:type => ::Thrift::Types::I64, :name => 'ip_addr'},
          SOURCE => {:type => ::Thrift::Types::I32, :name => 'source', :enum_class => ::Rapleaf::Types::Spruce::IPAddrInfoSource},
          ORG_NAME => {:type => ::Thrift::Types::STRING, :name => 'org_name'},
          ISP_NAME => {:type => ::Thrift::Types::STRING, :name => 'isp_name', :optional => true},
          COUNTRY_CODE => {:type => ::Thrift::Types::STRING, :name => 'country_code', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field ip_addr is unset!') unless @ip_addr
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field source is unset!') unless @source
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field org_name is unset!') unless @org_name
          unless @source.nil? || ::Rapleaf::Types::Spruce::IPAddrInfoSource::VALID_VALUES.include?(@source)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field source!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Struct to keep track of opted out cookie ids
      class OptOutCookie
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COOKIE_ID = 1
        OPTED_OUT_AT = 2
        SOURCE = 3
        ID_SYNC_COOKIE = 4

        FIELDS = {
          # The cookie_id of the opted out browser
          COOKIE_ID => {:type => ::Thrift::Types::STRING, :name => 'cookie_id', :binary => true},
          # Timestamp of the optout
          OPTED_OUT_AT => {:type => ::Thrift::Types::I32, :name => 'opted_out_at'},
          # Source where the optout comes from, can be either jspruce or matched_pii_identifier
          SOURCE => {:type => ::Thrift::Types::I32, :name => 'source', :optional => true, :enum_class => ::Rapleaf::Types::Spruce::OptOutCookieSource},
          # In order to have external_ids available
          ID_SYNC_COOKIE => {:type => ::Thrift::Types::STRUCT, :name => 'id_sync_cookie', :class => ::Rapleaf::Types::Spruce::IdSyncCookie, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field cookie_id is unset!') unless @cookie_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field opted_out_at is unset!') unless @opted_out_at
          unless @source.nil? || ::Rapleaf::Types::Spruce::OptOutCookieSource::VALID_VALUES.include?(@source)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field source!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class AudienceFieldsByAudienceId
        include ::Thrift::Struct, ::Thrift::Struct_Union
        AUDIENCE_FIELDS_BY_AUDIENCE_ID = 1

        FIELDS = {
          AUDIENCE_FIELDS_BY_AUDIENCE_ID => {:type => ::Thrift::Types::MAP, :name => 'audience_fields_by_audience_id', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Audience::AnonymousMemberFields}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field audience_fields_by_audience_id is unset!') unless @audience_fields_by_audience_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      class AnaResponsePackage
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ANA_ID = 1
        CPM = 2
        DIGEST = 3
        STATUS = 4
        PREFERRED = 5
        AUDIENCE_FIELD_VALUES = 7

        FIELDS = {
          ANA_ID => {:type => ::Thrift::Types::I64, :name => 'ana_id'},
          CPM => {:type => ::Thrift::Types::DOUBLE, :name => 'cpm', :optional => true},
          DIGEST => {:type => ::Thrift::Types::I32, :name => 'digest', :optional => true},
          STATUS => {:type => ::Thrift::Types::I32, :name => 'status', :optional => true, :enum_class => ::Rapleaf::Types::Spruce::RotationStatus},
          PREFERRED => {:type => ::Thrift::Types::BOOL, :name => 'preferred', :optional => true},
          AUDIENCE_FIELD_VALUES => {:type => ::Thrift::Types::MAP, :name => 'audience_field_values', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Liveramp::Audience::AnonymousMemberFields}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field ana_id is unset!') unless @ana_id
          unless @status.nil? || ::Rapleaf::Types::Spruce::RotationStatus::VALID_VALUES.include?(@status)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field status!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class RecookierEvalLogData
        include ::Thrift::Struct, ::Thrift::Struct_Union
        AUDIENCES_BY_ANA = 1
        AUDIENCE_KEY_BY_AUDIENCE = 2

        FIELDS = {
          AUDIENCES_BY_ANA => {:type => ::Thrift::Types::MAP, :name => 'audiences_by_ana', :key => {:type => ::Thrift::Types::I32}, :value => {:type => ::Thrift::Types::SET, :element => {:type => ::Thrift::Types::I64}}, :optional => true},
          AUDIENCE_KEY_BY_AUDIENCE => {:type => ::Thrift::Types::MAP, :name => 'audience_key_by_audience', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRING, :binary => true}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class PmeCountLogData
        include ::Thrift::Struct, ::Thrift::Struct_Union
        HEID_MAP = 1
        AUDIENCES = 2

        FIELDS = {
          HEID_MAP => {:type => ::Thrift::Types::MAP, :name => 'heid_map', :key => {:type => ::Thrift::Types::I64}, :value => {:type => ::Thrift::Types::STRING, :binary => true}},
          AUDIENCES => {:type => ::Thrift::Types::SET, :name => 'audiences', :element => {:type => ::Thrift::Types::I32}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field heid_map is unset!') unless @heid_map
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field audiences is unset!') unless @audiences
        end

        ::Thrift::Struct.generate_accessors self
      end

      class DatedHeid
        include ::Thrift::Struct, ::Thrift::Struct_Union
        HEID = 1
        LAST_SEEN = 2

        FIELDS = {
          HEID => {:type => ::Thrift::Types::STRING, :name => 'heid', :binary => true},
          LAST_SEEN => {:type => ::Thrift::Types::I64, :name => 'last_seen'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field heid is unset!') unless @heid
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field last_seen is unset!') unless @last_seen
        end

        ::Thrift::Struct.generate_accessors self
      end

    end
  end
end
