#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'

module Rapleaf
  module Types
    module GeoPostal
      module GeoPostalResponseAccuracy
        # This means that there was some sort of nasty failure.  Usually it probably
# means that the response string couldn't be parsed.  Ideally, this only
# happens when the string isn't actually an address.
        FAILURE = 0
        # Means that the address could be parsed, but couldn't be found in the
# geocoding (TIGER/Line) database.
        NOT_FOUND = 1
        # This is probably the type of response you want to get.  It means the
# query string was successfully forced AND found in the TIGER/Line
# database.
        FOUND = 2
        # This means that the exact query string was parsed, but couldn't be
# found in the TIGER/Line database.  However, it IS found after
# fuzzy searching techniques.
        FOUND_WITH_FUZZY_SEARCH = 3
        VALUE_MAP = {0 => "FAILURE", 1 => "NOT_FOUND", 2 => "FOUND", 3 => "FOUND_WITH_FUZZY_SEARCH"}
        VALID_VALUES = Set.new([FAILURE, NOT_FOUND, FOUND, FOUND_WITH_FUZZY_SEARCH]).freeze
      end

      class GeoPostalQuery; end

      class GeoPostalResponse; end

      class TigerlineCorpusEntry; end

      class TigerlineCorpusEntryList; end

      # Defines a query to the geocoder service
      class GeoPostalQuery
        include ::Thrift::Struct, ::Thrift::Struct_Union
        QUERY_STRING = 1

        FIELDS = {
          QUERY_STRING => {:type => ::Thrift::Types::STRING, :name => 'query_string'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field query_string is unset!') unless @query_string
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Defines a response from the query service
      class GeoPostalResponse
        include ::Thrift::Struct, ::Thrift::Struct_Union
        STATE_CODE = 1
        CITY = 2
        PREDIR = 3
        TYPE = 4
        LATITUDE = 5
        LONGITUDE = 6
        NUMBER = 7
        ZIP = 8
        COUNTY = 9
        TLID = 10
        NAME = 11
        STREET = 12
        POSTDIR = 13
        ACCURACY = 14

        FIELDS = {
          STATE_CODE => {:type => ::Thrift::Types::STRING, :name => 'state_code', :optional => true},
          CITY => {:type => ::Thrift::Types::STRING, :name => 'city', :optional => true},
          PREDIR => {:type => ::Thrift::Types::STRING, :name => 'predir', :optional => true},
          TYPE => {:type => ::Thrift::Types::STRING, :name => 'type', :optional => true},
          LATITUDE => {:type => ::Thrift::Types::DOUBLE, :name => 'latitude', :optional => true},
          LONGITUDE => {:type => ::Thrift::Types::DOUBLE, :name => 'longitude', :optional => true},
          NUMBER => {:type => ::Thrift::Types::STRING, :name => 'number', :optional => true},
          ZIP => {:type => ::Thrift::Types::STRING, :name => 'zip', :optional => true},
          COUNTY => {:type => ::Thrift::Types::STRING, :name => 'county', :optional => true},
          TLID => {:type => ::Thrift::Types::I32, :name => 'tlid', :optional => true},
          NAME => {:type => ::Thrift::Types::STRING, :name => 'name', :optional => true},
          STREET => {:type => ::Thrift::Types::STRING, :name => 'street', :optional => true},
          POSTDIR => {:type => ::Thrift::Types::STRING, :name => 'postdir', :optional => true},
          ACCURACY => {:type => ::Thrift::Types::I32, :name => 'accuracy', :enum_class => ::Rapleaf::Types::GeoPostal::GeoPostalResponseAccuracy}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field accuracy is unset!') unless @accuracy
          unless @accuracy.nil? || ::Rapleaf::Types::GeoPostal::GeoPostalResponseAccuracy::VALID_VALUES.include?(@accuracy)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field accuracy!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Defines the fields available in a corpus entry.
      class TigerlineCorpusEntry
        include ::Thrift::Struct, ::Thrift::Struct_Union
        TIGERLINE_ID = 1
        SEQUENCE_NUM = 2
        RANGE_MIN = 3
        RANGE_MAX = 4
        DIRECTION_PREFIX = 5
        NAME = 6
        TYPE = 7
        DIRECTION_SUFFIX = 8
        SIDE = 9
        PARITY = 10
        PLACE_NAME = 11
        FIPS55_CODE = 12
        FIPS_COUNTY_CODE = 13
        FIPS_STATE_CODE = 14
        CFCC = 15
        ZIPCODE = 16
        LATITUDE_MIN = 17
        LATITUDE_MAX = 18
        LONGITUDE_MIN = 19
        LONGITUDE_MAX = 20
        ZIP4 = 21

        FIELDS = {
          # The internal unique id used by the census bureau.  This might be
# useful for updating or cleaning the database in the future.
          TIGERLINE_ID => {:type => ::Thrift::Types::I32, :name => 'tigerline_id'},
          # This is a secondary internal identifier used by the census bureau.
# Specifically, it uniquely identifies an address range between a
# RT1/RT6 record pair.
          SEQUENCE_NUM => {:type => ::Thrift::Types::I32, :name => 'sequence_num'},
          # The smallest integer in this range.
          RANGE_MIN => {:type => ::Thrift::Types::I32, :name => 'range_min'},
          # The largest integer in this range.
          RANGE_MAX => {:type => ::Thrift::Types::I32, :name => 'range_max'},
          # Direction that comes BEFORE the feature name.  For example,
# 123 "S" Main St.  (Here, "S" is the direction prefix)
          DIRECTION_PREFIX => {:type => ::Thrift::Types::STRING, :name => 'direction_prefix', :optional => true},
          # The name of the feature.  For example, 123 "Main" St.
# (Here, "Main" is the name).
          NAME => {:type => ::Thrift::Types::STRING, :name => 'name', :optional => true},
          # The type of this feature. For example, 123 Main "St". Here,
# "St" is the type.
          TYPE => {:type => ::Thrift::Types::STRING, :name => 'type', :optional => true},
          # The direction that comes AFTER the feature name.  For example,
# 123 Main St "NW".  ("NW" is the direction suffix.)
          DIRECTION_SUFFIX => {:type => ::Thrift::Types::STRING, :name => 'direction_suffix', :optional => true},
          # TIGER/Line data usually comes with fields that have left/right
# side pairs.  Split this up to make things easier.
          SIDE => {:type => ::Thrift::Types::STRING, :name => 'side', :optional => true},
          # The parity of the range.  If the range starts and ends with
# odd numbers, then the parity should be 1.  If they both start
# and end with even numbers, it shoudl be 0.  Otherwise, it
# should be -1.
          PARITY => {:type => ::Thrift::Types::I32, :name => 'parity', :optional => true},
          # This is the string that results from resolving the fips55 code.
          PLACE_NAME => {:type => ::Thrift::Types::STRING, :name => 'place_name', :optional => true},
          # This is basically a unique identifier for a "populated place" (in
# many cases, this is a city).  For more information, see:
# http://www.itl.nist.gov/fipspubs/fip55-3.htm
          FIPS55_CODE => {:type => ::Thrift::Types::I32, :name => 'fips55_code', :optional => true},
          # This is a unique identifier for the county this record lies in.  For
# more information, see:
# http://www.census.gov/geo/www/ansi/countylookup.html
          FIPS_COUNTY_CODE => {:type => ::Thrift::Types::I32, :name => 'fips_county_code', :optional => true},
          # FIPs identifier for state.
          FIPS_STATE_CODE => {:type => ::Thrift::Types::I32, :name => 'fips_state_code', :optional => true},
          # The "Census Feature Class Code".  This basically indicates whether or not
# this entry corresponds to a highway, rurual route, etc.
          CFCC => {:type => ::Thrift::Types::STRING, :name => 'cfcc', :optional => true},
          # 5-digit zipcode for this entry.
          ZIPCODE => {:type => ::Thrift::Types::STRING, :name => 'zipcode'},
          # The latitude for this point.  Notice that this corresponds to range_min.
          LATITUDE_MIN => {:type => ::Thrift::Types::I32, :name => 'latitude_min'},
          LATITUDE_MAX => {:type => ::Thrift::Types::I32, :name => 'latitude_max'},
          LONGITUDE_MIN => {:type => ::Thrift::Types::I32, :name => 'longitude_min'},
          LONGITUDE_MAX => {:type => ::Thrift::Types::I32, :name => 'longitude_max'},
          # A zip4 postal code
          ZIP4 => {:type => ::Thrift::Types::I32, :name => 'zip4', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tigerline_id is unset!') unless @tigerline_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sequence_num is unset!') unless @sequence_num
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field range_min is unset!') unless @range_min
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field range_max is unset!') unless @range_max
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field zipcode is unset!') unless @zipcode
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field latitude_min is unset!') unless @latitude_min
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field latitude_max is unset!') unless @latitude_max
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field longitude_min is unset!') unless @longitude_min
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field longitude_max is unset!') unless @longitude_max
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A wrapper to hold a list of TigerlineCorpusEntrys.
# 
# "Yeah.... I GUESS you can do that."
#                   -- Takashi
# 
# signed:               witness:
# CHRIS MULLINS         ARMAAN SARKAR
# 
      class TigerlineCorpusEntryList
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ENTRY_LIST = 1

        FIELDS = {
          ENTRY_LIST => {:type => ::Thrift::Types::LIST, :name => 'entry_list', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::GeoPostal::TigerlineCorpusEntry}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field entry_list is unset!') unless @entry_list
        end

        ::Thrift::Struct.generate_accessors self
      end

    end
  end
end
