#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'
require File.join File.dirname(__FILE__), 'enums_types'
require File.join File.dirname(__FILE__), 'doc_ids_types'


module Rapleaf
  module Types
    module NewPersonData
      module ControlGroupSplitType
        CONTROL = 1
        TEST = 2
        VALUE_MAP = {1 => "CONTROL", 2 => "TEST"}
        VALID_VALUES = Set.new([CONTROL, TEST]).freeze
      end

      module LRCFieldType
        BINARY = 1
        STRING = 2
        NUMERIC = 3
        STRING_ENUM = 4
        NUMERIC_ENUM = 5
        DERIVED_STRING_ENUM = 6
        RETARGET = 7
        ID_SYNC = 8
        CROSS_DEVICE_ID = 9
        STATISTICAL_CROSS_DEVICE_ID = 10
        CONTROL_GROUP_SPLIT = 11
        HADRON_SEGMENT_PLACEHOLDER = 12
        VALUE_MAP = {1 => "BINARY", 2 => "STRING", 3 => "NUMERIC", 4 => "STRING_ENUM", 5 => "NUMERIC_ENUM", 6 => "DERIVED_STRING_ENUM", 7 => "RETARGET", 8 => "ID_SYNC", 9 => "CROSS_DEVICE_ID", 10 => "STATISTICAL_CROSS_DEVICE_ID", 11 => "CONTROL_GROUP_SPLIT", 12 => "HADRON_SEGMENT_PLACEHOLDER"}
        VALID_VALUES = Set.new([BINARY, STRING, NUMERIC, STRING_ENUM, NUMERIC_ENUM, DERIVED_STRING_ENUM, RETARGET, ID_SYNC, CROSS_DEVICE_ID, STATISTICAL_CROSS_DEVICE_ID, CONTROL_GROUP_SPLIT, HADRON_SEGMENT_PLACEHOLDER]).freeze
      end

      module ValueUniqueness
        SINGLE_VALUED = 1
        MULTI_VALUED_NO_DUPLICATION = 2
        MULTI_VALUED_WITH_DUPLICATION = 3
        VALUE_MAP = {1 => "SINGLE_VALUED", 2 => "MULTI_VALUED_NO_DUPLICATION", 3 => "MULTI_VALUED_WITH_DUPLICATION"}
        VALID_VALUES = Set.new([SINGLE_VALUED, MULTI_VALUED_NO_DUPLICATION, MULTI_VALUED_WITH_DUPLICATION]).freeze
      end

      class XDate; end

      class TargusInfoCookieData; end

      class UserIdOrName < ::Thrift::Union; end

      class EsPIN; end

      class MessengerID; end

      class TwitterListSiteObject; end

      class SiteObject < ::Thrift::Union; end

      class HashedEmailPIN < ::Thrift::Union; end

      class DataPartnerPIN; end

      class NAPkin; end

      class Household; end

      class NameAndCity; end

      class GroupPIN < ::Thrift::Union; end

      class SPEL; end

      class AbiliTecId; end

      class PhoneNumber; end

      class ERL; end

      class PostalAddress < ::Thrift::Union; end

      class InternationalNap; end

      class NameAndEmail; end

      class NameAndPhone; end

      class NameAndHashedEmail; end

      class PIN < ::Thrift::Union; end

      class RawLocation; end

      class NormalizedLocation; end

      class RawName; end

      class NormalizedName; end

      class SerializableBytes; end

      class StringList; end

      class IntList; end

      class IntSet; end

      class LongSet; end

      class IntPair; end

      class LongOrDouble < ::Thrift::Union; end

      class PartnerDeviceId; end

      class LRCFieldValue < ::Thrift::Union; end

      class LRCFieldSource; end

      class LRCField; end

      class LRCFieldList; end

      class FieldAndValueId; end

      class DustinInternalEquiv; end

      class PINList; end

      class PINSet; end

      class NapKeyToEids; end

      class PINAndOwners; end

      class PINAndOwner; end

      class IdentitySumm; end

      class PinToPinList; end

      class LegacyHeidMapping; end

      class DemergeStat; end

      class DemergeStatList; end

      class EmailToPin; end

      # A date with arbitrary precision, but 100% accuracy. That is, we might
# only know the year and month OR the month and day, but those values are
# assumed to be 100% trustworthy.
      class XDate
        include ::Thrift::Struct, ::Thrift::Struct_Union
        YEAR = 1
        MONTH = 2
        DAY = 3

        FIELDS = {
          # The year with century.
          YEAR => {:type => ::Thrift::Types::I32, :name => 'year', :optional => true},
          # The month of the year, 1-12.
          MONTH => {:type => ::Thrift::Types::I32, :name => 'month', :optional => true},
          # The day of the month, 1-31
          DAY => {:type => ::Thrift::Types::I32, :name => 'day', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class TargusInfoCookieData
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ENCRYPTED_BLOCK = 1

        FIELDS = {
          # Block of encrypted data that they want
# us to drop. We don't know what's in it.
          ENCRYPTED_BLOCK => {:type => ::Thrift::Types::STRING, :name => 'encrypted_block'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field encrypted_block is unset!') unless @encrypted_block
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A union struct that could represent either a username or a userid. The
# general distinction is that a username is user selected, whereas a userid is
# assigned by the site. For use in EsPINs.
      class UserIdOrName < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def userid(val)
            UserIdOrName.new(:userid, val)
          end

          def username(val)
            UserIdOrName.new(:username, val)
          end
        end

        USERID = 1
        USERNAME = 2

        FIELDS = {
          USERID => {:type => ::Thrift::Types::STRING, :name => 'userid', :optional => true},
          USERNAME => {:type => ::Thrift::Types::STRING, :name => 'username', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      # This is the "isu"-type of PIN. specifically for sites in the EsSite
# enumeration. Use exactly one of the userid or username fields as
# appropriate.
      class EsPIN
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SITE = 1
        IDENTIFIER = 2

        FIELDS = {
          SITE => {:type => ::Thrift::Types::I32, :name => 'site', :enum_class => ::Rapleaf::Types::PersonData::EsSite},
          IDENTIFIER => {:type => ::Thrift::Types::STRUCT, :name => 'identifier', :class => ::Rapleaf::Types::NewPersonData::UserIdOrName}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field site is unset!') unless @site
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field identifier is unset!') unless @identifier
          unless @site.nil? || ::Rapleaf::Types::PersonData::EsSite::VALID_VALUES.include?(@site)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field site!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Name says it all.
      class MessengerID
        include ::Thrift::Struct, ::Thrift::Struct_Union
        VALUE = 1
        MESSENGER_SERVICE = 2

        FIELDS = {
          VALUE => {:type => ::Thrift::Types::STRING, :name => 'value'},
          MESSENGER_SERVICE => {:type => ::Thrift::Types::I32, :name => 'messenger_service', :enum_class => ::Rapleaf::Types::PersonData::MessengerService}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field value is unset!') unless @value
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field messenger_service is unset!') unless @messenger_service
          unless @messenger_service.nil? || ::Rapleaf::Types::PersonData::MessengerService::VALID_VALUES.include?(@messenger_service)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field messenger_service!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A TwitterList is a pseudo-user on Twitter. They are created by a regular
# user, and can follow and be followed like a regular user.
      class TwitterListSiteObject
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ID = 1

        FIELDS = {
          ID => {:type => ::Thrift::Types::STRING, :name => 'id'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field id is unset!') unless @id
        end

        ::Thrift::Struct.generate_accessors self
      end

      # SiteObject is the class of PINs that describe non-person entities that exist
# on various sites. Each possible field describes a different class of objects
# as well as their implied sites.
      class SiteObject < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def twitter_list(val)
            SiteObject.new(:twitter_list, val)
          end
        end

        TWITTER_LIST = 1

        FIELDS = {
          TWITTER_LIST => {:type => ::Thrift::Types::STRUCT, :name => 'twitter_list', :class => ::Rapleaf::Types::NewPersonData::TwitterListSiteObject, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      # A HashedEmailPIN is the PIN subclass that represents an email that has been
# normalized and then hashed with one of the constituent hashing algorithms.
      class HashedEmailPIN < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def sha1(val)
            HashedEmailPIN.new(:sha1, val)
          end

          def md5(val)
            HashedEmailPIN.new(:md5, val)
          end

          def sha256(val)
            HashedEmailPIN.new(:sha256, val)
          end
        end

        SHA1 = 1
        MD5 = 2
        SHA256 = 3

        FIELDS = {
          SHA1 => {:type => ::Thrift::Types::STRING, :name => 'sha1', :binary => true, :optional => true},
          MD5 => {:type => ::Thrift::Types::STRING, :name => 'md5', :binary => true, :optional => true},
          SHA256 => {:type => ::Thrift::Types::STRING, :name => 'sha256', :binary => true, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      # A DataPartnerPIN is the PIN subclass that represents an internal identifier
# used by one of our data partners.  We will only use this identifier if it
# satisfies the requirements for a PIN, unique, unchanging, and represents
# a single individual.
      class DataPartnerPIN
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PARTNER = 1
        ID = 2

        FIELDS = {
          PARTNER => {:type => ::Thrift::Types::I32, :name => 'partner', :enum_class => ::Rapleaf::Types::PersonData::DataPartner},
          ID => {:type => ::Thrift::Types::STRING, :name => 'id'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field partner is unset!') unless @partner
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field id is unset!') unless @id
          unless @partner.nil? || ::Rapleaf::Types::PersonData::DataPartner::VALID_VALUES.include?(@partner)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field partner!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # NAPkin is a Name and Postals kind of PIN.  It's not exactly
# a PIN since it can't be used to uniquely identify a person,
# but we do use it for matching purposes.
      class NAPkin
        include ::Thrift::Struct, ::Thrift::Struct_Union
        FIRST_NAME = 1
        LAST_NAME = 2
        STREET = 3
        CITY = 4
        STATE = 5
        ZIP = 6

        FIELDS = {
          FIRST_NAME => {:type => ::Thrift::Types::STRING, :name => 'first_name', :optional => true},
          LAST_NAME => {:type => ::Thrift::Types::STRING, :name => 'last_name', :optional => true},
          STREET => {:type => ::Thrift::Types::STRING, :name => 'street', :optional => true},
          CITY => {:type => ::Thrift::Types::STRING, :name => 'city', :optional => true},
          STATE => {:type => ::Thrift::Types::STRING, :name => 'state', :optional => true},
          ZIP => {:type => ::Thrift::Types::STRING, :name => 'zip', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class Household
        include ::Thrift::Struct, ::Thrift::Struct_Union
        LAST_NAME = 1
        STREET = 2
        CITY = 3
        STATE = 4
        ZIP = 5

        FIELDS = {
          LAST_NAME => {:type => ::Thrift::Types::STRING, :name => 'last_name', :optional => true},
          STREET => {:type => ::Thrift::Types::STRING, :name => 'street', :optional => true},
          CITY => {:type => ::Thrift::Types::STRING, :name => 'city', :optional => true},
          STATE => {:type => ::Thrift::Types::STRING, :name => 'state', :optional => true},
          ZIP => {:type => ::Thrift::Types::STRING, :name => 'zip', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class NameAndCity
        include ::Thrift::Struct, ::Thrift::Struct_Union
        FIRST_NAME = 1
        LAST_NAME = 2
        CITY = 3
        STATE = 4

        FIELDS = {
          FIRST_NAME => {:type => ::Thrift::Types::STRING, :name => 'first_name'},
          LAST_NAME => {:type => ::Thrift::Types::STRING, :name => 'last_name'},
          CITY => {:type => ::Thrift::Types::STRING, :name => 'city'},
          STATE => {:type => ::Thrift::Types::STRING, :name => 'state'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field first_name is unset!') unless @first_name
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field last_name is unset!') unless @last_name
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field city is unset!') unless @city
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field state is unset!') unless @state
        end

        ::Thrift::Struct.generate_accessors self
      end

      class GroupPIN < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def zip(val)
            GroupPIN.new(:zip, val)
          end

          def zip_plus_4(val)
            GroupPIN.new(:zip_plus_4, val)
          end

          def zip_plus_6(val)
            GroupPIN.new(:zip_plus_6, val)
          end

          def household(val)
            GroupPIN.new(:household, val)
          end

          def name_and_city(val)
            GroupPIN.new(:name_and_city, val)
          end
        end

        ZIP = 1
        ZIP_PLUS_4 = 2
        ZIP_PLUS_6 = 3
        HOUSEHOLD = 4
        NAME_AND_CITY = 5

        FIELDS = {
          ZIP => {:type => ::Thrift::Types::STRING, :name => 'zip', :optional => true},
          ZIP_PLUS_4 => {:type => ::Thrift::Types::STRING, :name => 'zip_plus_4', :optional => true},
          ZIP_PLUS_6 => {:type => ::Thrift::Types::STRING, :name => 'zip_plus_6', :optional => true},
          HOUSEHOLD => {:type => ::Thrift::Types::STRUCT, :name => 'household', :class => ::Rapleaf::Types::NewPersonData::Household, :optional => true},
          NAME_AND_CITY => {:type => ::Thrift::Types::STRUCT, :name => 'name_and_city', :class => ::Rapleaf::Types::NewPersonData::NameAndCity, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class SPEL
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SPEL = 1

        FIELDS = {
          SPEL => {:type => ::Thrift::Types::STRING, :name => 'spel'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field spel is unset!') unless @spel
        end

        ::Thrift::Struct.generate_accessors self
      end

      # An Acxiom CLink.
# 
      class AbiliTecId
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ID = 1

        FIELDS = {
          ID => {:type => ::Thrift::Types::STRING, :name => 'id'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field id is unset!') unless @id
        end

        ::Thrift::Struct.generate_accessors self
      end

      class PhoneNumber
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PHONE_NUMBER = 1

        FIELDS = {
          PHONE_NUMBER => {:type => ::Thrift::Types::STRING, :name => 'phone_number'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field phone_number is unset!') unless @phone_number
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ERL
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ERL = 1

        FIELDS = {
          ERL => {:type => ::Thrift::Types::STRING, :name => 'erl'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field erl is unset!') unless @erl
        end

        ::Thrift::Struct.generate_accessors self
      end

      # An address can come in either as a single string with each line already combine
# or as a list of strings that each give an individual address line.
      class PostalAddress < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def address(val)
            PostalAddress.new(:address, val)
          end

          def address_lines(val)
            PostalAddress.new(:address_lines, val)
          end
        end

        ADDRESS = 1
        ADDRESS_LINES = 2

        FIELDS = {
          ADDRESS => {:type => ::Thrift::Types::STRING, :name => 'address', :optional => true},
          ADDRESS_LINES => {:type => ::Thrift::Types::LIST, :name => 'address_lines', :element => {:type => ::Thrift::Types::STRING}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      # Like a NAPkin, but without the first, last distinction in the name
# and with a country
# 
      class InternationalNap
        include ::Thrift::Struct, ::Thrift::Struct_Union
        FULL_NAME = 1
        POSTAL_ADDRESS = 2
        CITY = 3
        STATE = 4
        POSTCODE = 5
        COUNTRY_CODE = 6
        MIX_AMK_CMK = 7
        AMK = 8
        CMK = 9

        FIELDS = {
          FULL_NAME => {:type => ::Thrift::Types::STRING, :name => 'full_name', :optional => true},
          POSTAL_ADDRESS => {:type => ::Thrift::Types::STRUCT, :name => 'postal_address', :class => ::Rapleaf::Types::NewPersonData::PostalAddress, :optional => true},
          CITY => {:type => ::Thrift::Types::STRING, :name => 'city', :optional => true},
          STATE => {:type => ::Thrift::Types::STRING, :name => 'state', :optional => true},
          POSTCODE => {:type => ::Thrift::Types::STRING, :name => 'postcode', :optional => true},
          COUNTRY_CODE => {:type => ::Thrift::Types::STRING, :name => 'country_code', :optional => true},
          MIX_AMK_CMK => {:type => ::Thrift::Types::STRING, :name => 'mix_amk_cmk', :optional => true},
          AMK => {:type => ::Thrift::Types::STRING, :name => 'amk', :optional => true},
          CMK => {:type => ::Thrift::Types::STRING, :name => 'cmk', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class NameAndEmail
        include ::Thrift::Struct, ::Thrift::Struct_Union
        FULL_NAME = 1
        EMAIL = 2

        FIELDS = {
          FULL_NAME => {:type => ::Thrift::Types::STRING, :name => 'full_name'},
          EMAIL => {:type => ::Thrift::Types::STRING, :name => 'email'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field full_name is unset!') unless @full_name
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field email is unset!') unless @email
        end

        ::Thrift::Struct.generate_accessors self
      end

      class NameAndPhone
        include ::Thrift::Struct, ::Thrift::Struct_Union
        FULL_NAME = 1
        PHONE = 2

        FIELDS = {
          FULL_NAME => {:type => ::Thrift::Types::STRING, :name => 'full_name'},
          PHONE => {:type => ::Thrift::Types::STRUCT, :name => 'phone', :class => ::Rapleaf::Types::NewPersonData::PhoneNumber}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field full_name is unset!') unless @full_name
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field phone is unset!') unless @phone
        end

        ::Thrift::Struct.generate_accessors self
      end

      class NameAndHashedEmail
        include ::Thrift::Struct, ::Thrift::Struct_Union
        FULL_NAME = 1
        HASHED_EMAIL = 2

        FIELDS = {
          FULL_NAME => {:type => ::Thrift::Types::STRING, :name => 'full_name'},
          HASHED_EMAIL => {:type => ::Thrift::Types::STRUCT, :name => 'hashed_email', :class => ::Rapleaf::Types::NewPersonData::HashedEmailPIN}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field full_name is unset!') unless @full_name
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field hashed_email is unset!') unless @hashed_email
        end

        ::Thrift::Struct.generate_accessors self
      end

      # PIN stands for Proxy Identity Name.
# Examples: email/bryan@rapleaf.com, aim_name/xuddux
      class PIN < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def email(val)
            PIN.new(:email, val)
          end

          def entity_id(val)
            PIN.new(:entity_id, val)
          end

          def es_pin(val)
            PIN.new(:es_pin, val)
          end

          def url(val)
            PIN.new(:url, val)
          end

          def messenger_id(val)
            PIN.new(:messenger_id, val)
          end

          def site_object(val)
            PIN.new(:site_object, val)
          end

          def hashed_email(val)
            PIN.new(:hashed_email, val)
          end

          def data_partner_pin(val)
            PIN.new(:data_partner_pin, val)
          end

          def napkin(val)
            PIN.new(:napkin, val)
          end

          def group(val)
            PIN.new(:group, val)
          end

          def spel(val)
            PIN.new(:spel, val)
          end

          def abilitec(val)
            PIN.new(:abilitec, val)
          end

          def fake_pin(val)
            PIN.new(:fake_pin, val)
          end

          def phone_number(val)
            PIN.new(:phone_number, val)
          end

          def erl(val)
            PIN.new(:erl, val)
          end

          def individual_pii_doc(val)
            PIN.new(:individual_pii_doc, val)
          end

          def household_pii_doc(val)
            PIN.new(:household_pii_doc, val)
          end

          def international_nap(val)
            PIN.new(:international_nap, val)
          end

          def name_and_email(val)
            PIN.new(:name_and_email, val)
          end

          def name_and_phone(val)
            PIN.new(:name_and_phone, val)
          end

          def name_and_hashed_email(val)
            PIN.new(:name_and_hashed_email, val)
          end
        end

        EMAIL = 2
        ENTITY_ID = 3
        ES_PIN = 4
        URL = 5
        MESSENGER_ID = 8
        SITE_OBJECT = 9
        HASHED_EMAIL = 10
        DATA_PARTNER_PIN = 11
        NAPKIN = 12
        GROUP = 14
        SPEL = 15
        ABILITEC = 16
        FAKE_PIN = 17
        PHONE_NUMBER = 18
        ERL = 19
        INDIVIDUAL_PII_DOC = 20
        HOUSEHOLD_PII_DOC = 21
        INTERNATIONAL_NAP = 22
        NAME_AND_EMAIL = 23
        NAME_AND_PHONE = 24
        NAME_AND_HASHED_EMAIL = 25

        FIELDS = {
          EMAIL => {:type => ::Thrift::Types::STRING, :name => 'email', :optional => true},
          ENTITY_ID => {:type => ::Thrift::Types::STRING, :name => 'entity_id', :binary => true, :optional => true},
          ES_PIN => {:type => ::Thrift::Types::STRUCT, :name => 'es_pin', :class => ::Rapleaf::Types::NewPersonData::EsPIN, :optional => true},
          URL => {:type => ::Thrift::Types::STRING, :name => 'url', :optional => true},
          MESSENGER_ID => {:type => ::Thrift::Types::STRUCT, :name => 'messenger_id', :class => ::Rapleaf::Types::NewPersonData::MessengerID, :optional => true},
          SITE_OBJECT => {:type => ::Thrift::Types::STRUCT, :name => 'site_object', :class => ::Rapleaf::Types::NewPersonData::SiteObject, :optional => true},
          HASHED_EMAIL => {:type => ::Thrift::Types::STRUCT, :name => 'hashed_email', :class => ::Rapleaf::Types::NewPersonData::HashedEmailPIN, :optional => true},
          DATA_PARTNER_PIN => {:type => ::Thrift::Types::STRUCT, :name => 'data_partner_pin', :class => ::Rapleaf::Types::NewPersonData::DataPartnerPIN, :optional => true},
          NAPKIN => {:type => ::Thrift::Types::STRUCT, :name => 'napkin', :class => ::Rapleaf::Types::NewPersonData::NAPkin, :optional => true},
          GROUP => {:type => ::Thrift::Types::STRUCT, :name => 'group', :class => ::Rapleaf::Types::NewPersonData::GroupPIN, :optional => true},
          SPEL => {:type => ::Thrift::Types::STRUCT, :name => 'spel', :class => ::Rapleaf::Types::NewPersonData::SPEL, :optional => true},
          ABILITEC => {:type => ::Thrift::Types::STRUCT, :name => 'abilitec', :class => ::Rapleaf::Types::NewPersonData::AbiliTecId, :optional => true},
          FAKE_PIN => {:type => ::Thrift::Types::STRING, :name => 'fake_pin', :optional => true},
          PHONE_NUMBER => {:type => ::Thrift::Types::STRUCT, :name => 'phone_number', :class => ::Rapleaf::Types::NewPersonData::PhoneNumber, :optional => true},
          ERL => {:type => ::Thrift::Types::STRUCT, :name => 'erl', :class => ::Rapleaf::Types::NewPersonData::ERL, :optional => true},
          INDIVIDUAL_PII_DOC => {:type => ::Thrift::Types::STRUCT, :name => 'individual_pii_doc', :class => ::Liveramp::DocIds::PiiDoc, :optional => true},
          HOUSEHOLD_PII_DOC => {:type => ::Thrift::Types::STRUCT, :name => 'household_pii_doc', :class => ::Liveramp::DocIds::HouseholdPiiDoc, :optional => true},
          INTERNATIONAL_NAP => {:type => ::Thrift::Types::STRUCT, :name => 'international_nap', :class => ::Rapleaf::Types::NewPersonData::InternationalNap, :optional => true},
          NAME_AND_EMAIL => {:type => ::Thrift::Types::STRUCT, :name => 'name_and_email', :class => ::Rapleaf::Types::NewPersonData::NameAndEmail, :optional => true},
          NAME_AND_PHONE => {:type => ::Thrift::Types::STRUCT, :name => 'name_and_phone', :class => ::Rapleaf::Types::NewPersonData::NameAndPhone, :optional => true},
          NAME_AND_HASHED_EMAIL => {:type => ::Thrift::Types::STRUCT, :name => 'name_and_hashed_email', :class => ::Rapleaf::Types::NewPersonData::NameAndHashedEmail, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      # Location information that has been pulled raw from some datasource.
# TODO: union of raw location type?
      class RawLocation
        include ::Thrift::Struct, ::Thrift::Struct_Union
        LOCATION_STRING = 1
        CITY = 2
        STATE = 3
        ZIP = 4
        COUNTRY = 5
        ADDRESS = 6
        LOCALITY = 7
        REGION = 8
        LATITUDE = 9
        LONGITUDE = 10
        PLACE_TYPE = 11

        FIELDS = {
          # If you don't have distinct fields, put the value here.
          LOCATION_STRING => {:type => ::Thrift::Types::STRING, :name => 'location_string', :optional => true},
          CITY => {:type => ::Thrift::Types::STRING, :name => 'city', :optional => true},
          STATE => {:type => ::Thrift::Types::STRING, :name => 'state', :optional => true},
          ZIP => {:type => ::Thrift::Types::STRING, :name => 'zip', :optional => true},
          COUNTRY => {:type => ::Thrift::Types::STRING, :name => 'country', :optional => true},
          # This is only a street address.  For full mailing addresses, put the
# street address here and put the city, state, zip, etc in their
# respective fields.
          ADDRESS => {:type => ::Thrift::Types::STRING, :name => 'address', :optional => true},
          # For Facebook-style locations
          LOCALITY => {:type => ::Thrift::Types::STRING, :name => 'locality', :optional => true},
          # For Facebook-style locations
          REGION => {:type => ::Thrift::Types::STRING, :name => 'region', :optional => true},
          LATITUDE => {:type => ::Thrift::Types::DOUBLE, :name => 'latitude', :optional => true},
          LONGITUDE => {:type => ::Thrift::Types::DOUBLE, :name => 'longitude', :optional => true},
          # Indicates the granularity level of a location.
# This currently is used by Twitter when they put location tags on
# their tweets.
          PLACE_TYPE => {:type => ::Thrift::Types::I32, :name => 'place_type', :optional => true, :enum_class => ::Rapleaf::Types::PersonData::PlaceType}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @place_type.nil? || ::Rapleaf::Types::PersonData::PlaceType::VALID_VALUES.include?(@place_type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field place_type!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A normalized location produced from processing an original RawLocation. You
# should never "collect" a NormalizedLocation - leave it to the location
# normalizer to create them as necessary.
      class NormalizedLocation
        include ::Thrift::Struct, ::Thrift::Struct_Union
        GEONAMEID = 1
        LATITUDE = 4
        LONGITUDE = 5
        COUNTRY_CODE = 6
        ADMIN1_CODE = 7
        ADMIN2_CODE = 8
        STREET_ADDRESS = 9
        PRETTY_SUB_REGION = 10
        PRETTY_REGION = 11
        PRETTY_COUNTRY = 12
        ZIP_CODE = 13

        FIELDS = {
          # integer id of record in geonames database
          GEONAMEID => {:type => ::Thrift::Types::I32, :name => 'geonameid'},
          # Latitude in decimal degrees (wgs84)
          LATITUDE => {:type => ::Thrift::Types::DOUBLE, :name => 'latitude'},
          # Longitude in decimal degrees (wgs84)
          LONGITUDE => {:type => ::Thrift::Types::DOUBLE, :name => 'longitude'},
          # ISO-3166 2-letter country code, 2 characters.
# Not required, because believe it or not, there are places NOT in a country.
          COUNTRY_CODE => {:type => ::Thrift::Types::STRING, :name => 'country_code', :optional => true},
          # fipscode (subject to change to iso code), isocode for the us and ch, see
# file admin1Codes.txt for display names of this code.
          ADMIN1_CODE => {:type => ::Thrift::Types::STRING, :name => 'admin1_code', :optional => true},
          # Code for the second administrative division, a county in the US, see file admin2Codes.txt
          ADMIN2_CODE => {:type => ::Thrift::Types::STRING, :name => 'admin2_code', :optional => true},
          # Specifically the street address portion of a location.
          STREET_ADDRESS => {:type => ::Thrift::Types::STRING, :name => 'street_address', :optional => true},
          # String to represent the location at the level more granular than region.
# This can be a city, county, etc.
          PRETTY_SUB_REGION => {:type => ::Thrift::Types::STRING, :name => 'pretty_sub_region', :optional => true},
          # String to represent the location at the region level.
# This is the string representation for the admin1_code, which
# will indicate the region (one step more granular than country).
# In the case of the US, this is the state.
          PRETTY_REGION => {:type => ::Thrift::Types::STRING, :name => 'pretty_region', :optional => true},
          # String to represent the country that this location is in.
          PRETTY_COUNTRY => {:type => ::Thrift::Types::STRING, :name => 'pretty_country', :optional => true},
          ZIP_CODE => {:type => ::Thrift::Types::STRING, :name => 'zip_code', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field geonameid is unset!') unless @geonameid
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field latitude is unset!') unless @latitude
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field longitude is unset!') unless @longitude
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The components of the individual's name, if you have them, or a raw string
# containing all the parts.
      class RawName
        include ::Thrift::Struct, ::Thrift::Struct_Union
        FIRST = 1
        LAST = 2
        MIDDLE = 3
        MIDDLE_INITIAL = 4
        SUFFIX = 5
        PREFIX = 6
        LAST_NAME_INITIAL = 7
        RAW = 8
        VERIFIED = 9

        FIELDS = {
          FIRST => {:type => ::Thrift::Types::STRING, :name => 'first', :optional => true},
          LAST => {:type => ::Thrift::Types::STRING, :name => 'last', :optional => true},
          MIDDLE => {:type => ::Thrift::Types::STRING, :name => 'middle', :optional => true},
          MIDDLE_INITIAL => {:type => ::Thrift::Types::STRING, :name => 'middle_initial', :optional => true},
          SUFFIX => {:type => ::Thrift::Types::STRING, :name => 'suffix', :optional => true},
          PREFIX => {:type => ::Thrift::Types::STRING, :name => 'prefix', :optional => true},
          LAST_NAME_INITIAL => {:type => ::Thrift::Types::STRING, :name => 'last_name_initial', :optional => true},
          RAW => {:type => ::Thrift::Types::STRING, :name => 'raw', :optional => true},
          # Set to true if this name has been verified by the source.
# For example, Google has verified names if they have checked
# with a credit card company to confirm the name you give.
          VERIFIED => {:type => ::Thrift::Types::BOOL, :name => 'verified', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The components of an individual's name parsed out to the best of our
# knowledge.
      class NormalizedName
        include ::Thrift::Struct, ::Thrift::Struct_Union
        FIRST = 1
        LAST = 2
        MIDDLE = 3
        MIDDLE_INITIAL = 4
        SUFFIX = 5
        PREFIX = 6
        LAST_NAME_INITIAL = 7
        VERIFIED = 8

        FIELDS = {
          FIRST => {:type => ::Thrift::Types::STRING, :name => 'first', :optional => true},
          LAST => {:type => ::Thrift::Types::STRING, :name => 'last', :optional => true},
          MIDDLE => {:type => ::Thrift::Types::STRING, :name => 'middle', :optional => true},
          MIDDLE_INITIAL => {:type => ::Thrift::Types::STRING, :name => 'middle_initial', :optional => true},
          SUFFIX => {:type => ::Thrift::Types::STRING, :name => 'suffix', :optional => true},
          PREFIX => {:type => ::Thrift::Types::STRING, :name => 'prefix', :optional => true},
          LAST_NAME_INITIAL => {:type => ::Thrift::Types::STRING, :name => 'last_name_initial', :optional => true},
          VERIFIED => {:type => ::Thrift::Types::BOOL, :name => 'verified', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class SerializableBytes
        include ::Thrift::Struct, ::Thrift::Struct_Union
        BYTES = 1

        FIELDS = {
          BYTES => {:type => ::Thrift::Types::STRING, :name => 'bytes', :binary => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field bytes is unset!') unless @bytes
        end

        ::Thrift::Struct.generate_accessors self
      end

      class StringList
        include ::Thrift::Struct, ::Thrift::Struct_Union
        STRINGS = 1

        FIELDS = {
          STRINGS => {:type => ::Thrift::Types::LIST, :name => 'strings', :element => {:type => ::Thrift::Types::STRING}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field strings is unset!') unless @strings
        end

        ::Thrift::Struct.generate_accessors self
      end

      class IntList
        include ::Thrift::Struct, ::Thrift::Struct_Union
        INTS = 1

        FIELDS = {
          INTS => {:type => ::Thrift::Types::LIST, :name => 'ints', :element => {:type => ::Thrift::Types::I32}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field ints is unset!') unless @ints
        end

        ::Thrift::Struct.generate_accessors self
      end

      class IntSet
        include ::Thrift::Struct, ::Thrift::Struct_Union
        INTS = 1

        FIELDS = {
          INTS => {:type => ::Thrift::Types::SET, :name => 'ints', :element => {:type => ::Thrift::Types::I32}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field ints is unset!') unless @ints
        end

        ::Thrift::Struct.generate_accessors self
      end

      class LongSet
        include ::Thrift::Struct, ::Thrift::Struct_Union
        LONGS = 1

        FIELDS = {
          LONGS => {:type => ::Thrift::Types::SET, :name => 'longs', :element => {:type => ::Thrift::Types::I64}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field longs is unset!') unless @longs
        end

        ::Thrift::Struct.generate_accessors self
      end

      class IntPair
        include ::Thrift::Struct, ::Thrift::Struct_Union
        FIRST = 1
        SECOND = 2

        FIELDS = {
          FIRST => {:type => ::Thrift::Types::I32, :name => 'first'},
          SECOND => {:type => ::Thrift::Types::I32, :name => 'second'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field first is unset!') unless @first
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field second is unset!') unless @second
        end

        ::Thrift::Struct.generate_accessors self
      end

      class LongOrDouble < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def long_value(val)
            LongOrDouble.new(:long_value, val)
          end

          def double_value(val)
            LongOrDouble.new(:double_value, val)
          end
        end

        LONG_VALUE = 1
        DOUBLE_VALUE = 2

        FIELDS = {
          LONG_VALUE => {:type => ::Thrift::Types::I64, :name => 'long_value', :optional => true},
          DOUBLE_VALUE => {:type => ::Thrift::Types::DOUBLE, :name => 'double_value', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class PartnerDeviceId
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PARTNER_DEVICE_ID = 1
        LAST_SYNCED_AT = 2

        FIELDS = {
          PARTNER_DEVICE_ID => {:type => ::Thrift::Types::STRING, :name => 'partner_device_id'},
          LAST_SYNCED_AT => {:type => ::Thrift::Types::I32, :name => 'last_synced_at', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field partner_device_id is unset!') unless @partner_device_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      class LRCFieldValue < ::Thrift::Union
        include ::Thrift::Struct_Union
        class << self
          def in_binary_field(val)
            LRCFieldValue.new(:in_binary_field, val)
          end

          def string_value(val)
            LRCFieldValue.new(:string_value, val)
          end

          def numeric_value(val)
            LRCFieldValue.new(:numeric_value, val)
          end

          def lrcf_string_enum_value_id(val)
            LRCFieldValue.new(:lrcf_string_enum_value_id, val)
          end

          def lrcf_numeric_enum_value_id(val)
            LRCFieldValue.new(:lrcf_numeric_enum_value_id, val)
          end

          def derived_string_enum_value_id(val)
            LRCFieldValue.new(:derived_string_enum_value_id, val)
          end

          def partner_device_id(val)
            LRCFieldValue.new(:partner_device_id, val)
          end

          def control_group_split_enum_value_id(val)
            LRCFieldValue.new(:control_group_split_enum_value_id, val)
          end
        end

        IN_BINARY_FIELD = 1
        STRING_VALUE = 2
        NUMERIC_VALUE = 3
        LRCF_STRING_ENUM_VALUE_ID = 4
        LRCF_NUMERIC_ENUM_VALUE_ID = 5
        DERIVED_STRING_ENUM_VALUE_ID = 6
        PARTNER_DEVICE_ID = 7
        CONTROL_GROUP_SPLIT_ENUM_VALUE_ID = 8

        FIELDS = {
          IN_BINARY_FIELD => {:type => ::Thrift::Types::BOOL, :name => 'in_binary_field', :optional => true},
          STRING_VALUE => {:type => ::Thrift::Types::STRING, :name => 'string_value', :optional => true},
          NUMERIC_VALUE => {:type => ::Thrift::Types::STRUCT, :name => 'numeric_value', :class => ::Rapleaf::Types::NewPersonData::LongOrDouble, :optional => true},
          LRCF_STRING_ENUM_VALUE_ID => {:type => ::Thrift::Types::I32, :name => 'lrcf_string_enum_value_id', :optional => true},
          LRCF_NUMERIC_ENUM_VALUE_ID => {:type => ::Thrift::Types::I32, :name => 'lrcf_numeric_enum_value_id', :optional => true},
          DERIVED_STRING_ENUM_VALUE_ID => {:type => ::Thrift::Types::I32, :name => 'derived_string_enum_value_id', :optional => true},
          PARTNER_DEVICE_ID => {:type => ::Thrift::Types::STRUCT, :name => 'partner_device_id', :class => ::Rapleaf::Types::NewPersonData::PartnerDeviceId, :optional => true},
          CONTROL_GROUP_SPLIT_ENUM_VALUE_ID => {:type => ::Thrift::Types::I32, :name => 'control_group_split_enum_value_id', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
        end

        ::Thrift::Union.generate_accessors self
      end

      class LRCFieldSource
        include ::Thrift::Struct, ::Thrift::Struct_Union
        IRC_ID = 1
        INSTANCE_INDEX = 2
        PELS = 3

        FIELDS = {
          IRC_ID => {:type => ::Thrift::Types::I64, :name => 'irc_id'},
          INSTANCE_INDEX => {:type => ::Thrift::Types::I32, :name => 'instance_index', :default => 0, :optional => true},
          PELS => {:type => ::Thrift::Types::SET, :name => 'pels', :element => {:type => ::Thrift::Types::STRING}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field irc_id is unset!') unless @irc_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      class LRCField
        include ::Thrift::Struct, ::Thrift::Struct_Union
        FIELD_ID = 1
        VALUE = 2
        SOURCE = 4

        FIELDS = {
          FIELD_ID => {:type => ::Thrift::Types::I32, :name => 'field_id'},
          VALUE => {:type => ::Thrift::Types::STRUCT, :name => 'value', :class => ::Rapleaf::Types::NewPersonData::LRCFieldValue},
          SOURCE => {:type => ::Thrift::Types::STRUCT, :name => 'source', :class => ::Rapleaf::Types::NewPersonData::LRCFieldSource, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field field_id is unset!') unless @field_id
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field value is unset!') unless @value
        end

        ::Thrift::Struct.generate_accessors self
      end

      class LRCFieldList
        include ::Thrift::Struct, ::Thrift::Struct_Union
        FIELD_LIST = 1

        FIELDS = {
          FIELD_LIST => {:type => ::Thrift::Types::LIST, :name => 'field_list', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::NewPersonData::LRCField}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field field_list is unset!') unless @field_list
        end

        ::Thrift::Struct.generate_accessors self
      end

      class FieldAndValueId
        include ::Thrift::Struct, ::Thrift::Struct_Union
        FIELD_ID = 1
        VALUE_ID = 2

        FIELDS = {
          FIELD_ID => {:type => ::Thrift::Types::I64, :name => 'field_id'},
          VALUE_ID => {:type => ::Thrift::Types::I64, :name => 'value_id', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field field_id is unset!') unless @field_id
        end

        ::Thrift::Struct.generate_accessors self
      end

      # This structure is used internally by Dustin for its "equivalence sets" it
# produces each iteration.
# Deprecated! Plan to use PTE instead.
      class DustinInternalEquiv
        include ::Thrift::Struct, ::Thrift::Struct_Union
        EID = 1
        PIN = 2
        CREATION_TIME = 3

        FIELDS = {
          EID => {:type => ::Thrift::Types::STRING, :name => 'eid', :binary => true},
          PIN => {:type => ::Thrift::Types::STRUCT, :name => 'pin', :class => ::Rapleaf::Types::NewPersonData::PIN},
          CREATION_TIME => {:type => ::Thrift::Types::I32, :name => 'creation_time'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field eid is unset!') unless @eid
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field pin is unset!') unless @pin
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field creation_time is unset!') unless @creation_time
        end

        ::Thrift::Struct.generate_accessors self
      end

      class PINList
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PINS = 1

        FIELDS = {
          PINS => {:type => ::Thrift::Types::LIST, :name => 'pins', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::NewPersonData::PIN}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field pins is unset!') unless @pins
        end

        ::Thrift::Struct.generate_accessors self
      end

      class PINSet
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PINS = 1

        FIELDS = {
          PINS => {:type => ::Thrift::Types::SET, :name => 'pins', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::NewPersonData::PIN}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field pins is unset!') unless @pins
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Used by NAPToEid to store mappings
      class NapKeyToEids
        include ::Thrift::Struct, ::Thrift::Struct_Union
        KEY = 1
        EIDS = 2

        FIELDS = {
          KEY => {:type => ::Thrift::Types::STRING, :name => 'key'},
          EIDS => {:type => ::Thrift::Types::LIST, :name => 'eids', :element => {:type => ::Thrift::Types::STRING, :binary => true}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field key is unset!') unless @key
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field eids is unset!') unless @eids
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Used to pair a PIN with the set of DataPartners that lay claim to ownership
# of said PIN.
      class PINAndOwners
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PIN = 1
        OWNERS = 2
        AUDIENCES = 3

        FIELDS = {
          PIN => {:type => ::Thrift::Types::STRUCT, :name => 'pin', :class => ::Rapleaf::Types::NewPersonData::PIN},
          # The set of DataParnters that own the PIN. If this field is unset, or is
# set to an empty set, then it is owned by Rapleaf.
          OWNERS => {:type => ::Thrift::Types::SET, :name => 'owners', :element => {:type => ::Thrift::Types::I32, :enum_class => ::Rapleaf::Types::PersonData::DataPartner}, :optional => true},
          AUDIENCES => {:type => ::Thrift::Types::SET, :name => 'audiences', :element => {:type => ::Thrift::Types::I64}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field pin is unset!') unless @pin
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Used to pair a PIN with its owner, which can be a data partner or Rapleaf.
      class PINAndOwner
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PIN = 1
        OWNER = 2

        FIELDS = {
          PIN => {:type => ::Thrift::Types::STRUCT, :name => 'pin', :class => ::Rapleaf::Types::NewPersonData::PIN},
          # The owner of this PIN..
          OWNER => {:type => ::Thrift::Types::I32, :name => 'owner', :enum_class => ::Rapleaf::Types::PersonData::DataPartner}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field pin is unset!') unless @pin
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field owner is unset!') unless @owner
          unless @owner.nil? || ::Rapleaf::Types::PersonData::DataPartner::VALID_VALUES.include?(@owner)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field owner!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A structure produced by the identity merger flow for each pemap, with an eid and
# all pins associated with the eid and all their owners.
      class IdentitySumm
        include ::Thrift::Struct, ::Thrift::Struct_Union
        EID = 1
        PIN_AND_OWNERS = 2
        FRINGE_PIN_AND_OWNERS = 3
        RESTRICTED = 4

        FIELDS = {
          EID => {:type => ::Thrift::Types::STRING, :name => 'eid', :binary => true},
          PIN_AND_OWNERS => {:type => ::Thrift::Types::LIST, :name => 'pin_and_owners', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::NewPersonData::PINAndOwners}},
          FRINGE_PIN_AND_OWNERS => {:type => ::Thrift::Types::LIST, :name => 'fringe_pin_and_owners', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::NewPersonData::PINAndOwners}, :optional => true},
          RESTRICTED => {:type => ::Thrift::Types::BOOL, :name => 'restricted', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field eid is unset!') unless @eid
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field pin_and_owners is unset!') unless @pin_and_owners
        end

        ::Thrift::Struct.generate_accessors self
      end

      class PinToPinList
        include ::Thrift::Struct, ::Thrift::Struct_Union
        KEY = 1
        VALUES = 2
        TYPE = 3

        FIELDS = {
          KEY => {:type => ::Thrift::Types::STRUCT, :name => 'key', :class => ::Rapleaf::Types::NewPersonData::PIN},
          VALUES => {:type => ::Thrift::Types::LIST, :name => 'values', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::NewPersonData::PIN}},
          TYPE => {:type => ::Thrift::Types::BYTE, :name => 'type', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field key is unset!') unless @key
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field values is unset!') unless @values
        end

        ::Thrift::Struct.generate_accessors self
      end

      class LegacyHeidMapping
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CURRENT = 1
        OLDEST = 2

        FIELDS = {
          CURRENT => {:type => ::Thrift::Types::STRING, :name => 'current', :binary => true},
          OLDEST => {:type => ::Thrift::Types::STRING, :name => 'oldest', :binary => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field current is unset!') unless @current
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field oldest is unset!') unless @oldest
        end

        ::Thrift::Struct.generate_accessors self
      end

      class DemergeStat
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PIN1 = 1
        PIN2 = 2
        MATCH_PARTNER = 3
        DEMERGE_TYPE = 4

        FIELDS = {
          PIN1 => {:type => ::Thrift::Types::STRUCT, :name => 'pin1', :class => ::Rapleaf::Types::NewPersonData::PIN},
          PIN2 => {:type => ::Thrift::Types::STRUCT, :name => 'pin2', :class => ::Rapleaf::Types::NewPersonData::PIN},
          MATCH_PARTNER => {:type => ::Thrift::Types::I32, :name => 'match_partner', :enum_class => ::Rapleaf::Types::PersonData::DataPartner},
          DEMERGE_TYPE => {:type => ::Thrift::Types::STRING, :name => 'demerge_type'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field pin1 is unset!') unless @pin1
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field pin2 is unset!') unless @pin2
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field match_partner is unset!') unless @match_partner
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field demerge_type is unset!') unless @demerge_type
          unless @match_partner.nil? || ::Rapleaf::Types::PersonData::DataPartner::VALID_VALUES.include?(@match_partner)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field match_partner!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class DemergeStatList
        include ::Thrift::Struct, ::Thrift::Struct_Union
        STATS = 1

        FIELDS = {
          STATS => {:type => ::Thrift::Types::LIST, :name => 'stats', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Rapleaf::Types::NewPersonData::DemergeStat}}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field stats is unset!') unless @stats
        end

        ::Thrift::Struct.generate_accessors self
      end

      class EmailToPin
        include ::Thrift::Struct, ::Thrift::Struct_Union
        EMAIL = 1
        PIN = 2

        FIELDS = {
          EMAIL => {:type => ::Thrift::Types::STRING, :name => 'email'},
          PIN => {:type => ::Thrift::Types::STRUCT, :name => 'pin', :class => ::Rapleaf::Types::NewPersonData::PIN}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field email is unset!') unless @email
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field pin is unset!') unless @pin
        end

        ::Thrift::Struct.generate_accessors self
      end

    end
  end
end
